<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pale Bule Dot</title>
  
  
  <link href="https://youxt-njnu.github.io/atom.xml" rel="self"/>
  
  <link href="https://youxt-njnu.github.io/"/>
  <updated>2024-10-25T14:24:10.324Z</updated>
  <id>https://youxt-njnu.github.io/</id>
  
  <author>
    <name>Shealin You</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>threejs源码学习</title>
    <link href="https://youxt-njnu.github.io/2024/10/25/threejs%E6%BA%90%E7%A0%811/"/>
    <id>https://youxt-njnu.github.io/2024/10/25/threejs%E6%BA%90%E7%A0%811/</id>
    <published>2024-10-25T02:34:05.000Z</published>
    <updated>2024-10-25T14:24:10.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对很多知识点只有模糊的概念，除了日常写写demo，就来看看源码培养些感觉；</p><p>从BoxGeometry入手;</p><p>现阶段的大纲图：</p><p><img src="https://s2.loli.net/2024/10/25/iQyVkM8svcFLNKG.png" alt="1729864326918.jpg"></p><h1 id="BoxGeometry"><a href="#BoxGeometry" class="headerlink" title="BoxGeometry"></a>BoxGeometry</h1><p>标了阅读思路，主要是理解buildPlane函数的参数是怎么设定的、顶点是怎么计算的、坐标系是怎么放的、UV是怎么算的，还有就是怎么利用索引来减少存储。</p><p><img src="https://s2.loli.net/2024/10/25/Hj4Tq2ofp37be5a.jpg" alt="e081babf6c7c640380917d4eb24af47.jpg"></p><p>主要是懒，而且写个完整思路和笔记博客太费时间了。。。。</p><p>高清版在<a href="https://github.com/youxt-njnu/ProjectSnapshot/blob/master/threejs-BoxGeometry.pdf">GitHub</a>自取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;对很多知识点只有模糊的概念，除了日常写写demo，就来看看源码培养些感觉；&lt;/p&gt;
&lt;p&gt;从BoxGeometry入手;&lt;/p&gt;
&lt;p&gt;现阶</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>快捷键记录</title>
    <link href="https://youxt-njnu.github.io/2024/10/23/%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://youxt-njnu.github.io/2024/10/23/%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2024-10-23T02:30:23.000Z</published>
    <updated>2024-10-23T02:11:43.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adobe-Illustrator"><a href="#Adobe-Illustrator" class="headerlink" title="Adobe Illustrator"></a>Adobe Illustrator</h1><p>重复上一步：ctrl+d<br>将选中物体隐藏：ctrl+3<br>将选中物体锁定：ctrl+2</p><h1 id="Sticky-Notes"><a href="#Sticky-Notes" class="headerlink" title="Sticky Notes"></a>Sticky Notes</h1><p>新建笔记：alt+n<br>从剪切板新建：alt+v<br>展示所有笔记：alt+s<br>隐藏所有笔记：alt+h<br>去往下一个笔记：alt+g<br>探索：alt+x<br>重命名：f2<br>设置提醒：alt+a</p><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><p>copy+paste: ctrl+d<br>物体操作面板：q,w,e,r</p><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><p>类似vscode, 试试看应该也能通用<br>文本对齐：ctrl+k, ctrl+d<br>注释所选代码：ctrl &#x2F;<br>取消注释：ctrl &#x2F;<br>代码折叠：<br><code># region</code><br><code># endregion</code><br>显示命令面板：ctrl+shift+p, F1<br>显示&#x2F;隐藏侧边栏：ctrl+b<br>创建多个编辑器：ctrl+\，方便抄代码<br>ctrl+1,ctrl+2:快速聚焦到第？个编辑器<br>放缩工作区：ctrl +&#x2F;-<br>重新开一个软件的窗口：ctrl+shift+N<br>关闭软件的当前窗口：ctrl+shift+W<br>新建文件：ctrl+N<br>关闭当前文件：ctrl+W<br>ctrl+pagedown&#x2F;pageup: 在已经打开的多个文件之间进行切换<br>ctrl+shift+O: 在当前文件的各种方法之间进行跳转<br>ctrl+G: 跳转到指定行</p><p><a href="https://zhuanlan.zhihu.com/p/62913725">https://zhuanlan.zhihu.com/p/62913725</a></p><h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>对于 行 的操作：<br>重开一行：光标在行尾的话，回车即可；不在行尾，ctrl + enter 向下重开一行；ctrl+shift + enter 则是在上一行重开一行<br>删除一行：光标没有选择内容时，ctrl + x 剪切一行；ctrl +shift + k 直接删除一行<br>移动一行：alt + ↑ 向上移动一行；alt + ↓ 向下移动一行<br>复制一行：shift + alt + ↓ 向下复制一行；shift + alt + ↑ 向上复制一行<br>ctrl + z 回退</p><p>对于 词 的操作：<br>选中一个词：ctrl + d<br>搜索或者替换：<br>ctrl + f ：搜索<br>ctrl + alt + f： 替换<br>ctrl + shift + f：在项目内搜索<br>通过Ctrl + &#96; 可以打开或关闭终端<br>Ctrl+P 快速打开最近打开的文件<br>Ctrl+Shift+N 打开新的编辑器窗口<br>Ctrl+Shift+W 关闭编辑器<br>Home 光标跳转到行头<br>End 光标跳转到行尾<br>Ctrl + Home 跳转到页头<br>Ctrl + End 跳转到页尾<br>Ctrl + Shift + [ 折叠区域代码<br>Ctrl + Shift + ] 展开区域代码<br>Ctrl + &#x2F; 添加关闭行注释<br>Shift + Alt +A 块区域注释</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Adobe-Illustrator&quot;&gt;&lt;a href=&quot;#Adobe-Illustrator&quot; class=&quot;headerlink&quot; title=&quot;Adobe Illustrator&quot;&gt;&lt;/a&gt;Adobe Illustrator&lt;/h1&gt;&lt;p&gt;重复上一步：ctrl</summary>
      
    
    
    
    <category term="周边扩展" scheme="https://youxt-njnu.github.io/categories/%E5%91%A8%E8%BE%B9%E6%89%A9%E5%B1%95/"/>
    
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏坑①</title>
    <link href="https://youxt-njnu.github.io/2024/09/21/three-%E8%B5%9B%E5%8D%9A%E5%A4%A7%E5%B1%8F%E5%A1%AB%E5%9D%911/"/>
    <id>https://youxt-njnu.github.io/2024/09/21/three-%E8%B5%9B%E5%8D%9A%E5%A4%A7%E5%B1%8F%E5%A1%AB%E5%9D%911/</id>
    <published>2024-09-21T06:02:05.000Z</published>
    <updated>2024-10-05T12:06:36.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-第一批"><a href="#问题-第一批" class="headerlink" title="问题(第一批)"></a>问题(第一批)</h1><h2 id="球体的陆地和海洋并没有区分出来"><a href="#球体的陆地和海洋并没有区分出来" class="headerlink" title="球体的陆地和海洋并没有区分出来"></a>球体的陆地和海洋并没有区分出来</h2><p>尝试1：看看texture是否正确加载</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> earthTexture = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(earthImg, <span class="keyword">function</span> (<span class="params">texture</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;texture loaded successfully&#x27;</span>);</span><br><span class="line">    &#125;, <span class="literal">undefined</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;texture load failed&#x27;</span>, err); &#125;);</span><br></pre></td></tr></table></figure><p>问题是对UV的计算错了：<br>错处1：<code> let uv = [(sph + Math.PI) / (2 * Math.PI), 1 - (sph.theta / Math.PI)];</code></p><p>需要使用new Three.Vector2(),而不是直接构建数组；如果是直接构建数组，那下面就访问不到.x和.y，需要使用[0]和[1]来访问对应的内容。</p><p>错处2：<code>let uv = new Three.Vector2(sph + Math.PI) / (2 * Math.PI), 1 - (sph.theta / Math.PI));</code></p><p>这里对UV的映射计算错了</p><blockquote><p>在 Three.js 中，<code>Spherical</code> 类表示的球坐标系统是基于三维右手笛卡尔坐标系，其中 <code>phi</code>（仰角）和 <code>theta</code>（方位角）的定义具体如下：</p><ol><li><strong><code>phi</code>（仰角）</strong> - 这是从正Y轴向下至点P的线段与Y轴之间的角度。在 Three.js 中，<code>phi</code> 的范围通常是从0到π（即从0到180度），其中0对应于正Y轴（向上）的方向，而π对应于负Y轴（向下）的方向。</li><li><strong><code>theta</code>（方位角）</strong> - 这是在XZ平面上，从正Z轴向正X轴的角度。<code>theta</code> 的范围是从0到2π（即从0到360度），其中0开始于正Z轴，增加方向是逆时针（从屏幕向里到屏幕向外看为正Z方向）。<br>因此，<code>Spherical</code> 的 <code>phi</code> 和 <code>theta</code> 的直观理解如下：</li></ol><ul><li><code>phi = 0</code>：点位于Y轴的正方向（向上）。</li><li><code>phi = π/2</code>：点位于XZ平面。</li><li><code>phi = π</code>：点位于Y轴的负方向（向下）。</li><li><code>theta = 0</code>：点位于Z轴的正方向（向屏幕外）。</li><li><code>theta = π/2</code>：点位于X轴的正方向（向右）。</li><li><code>theta = π</code>：点位于Z轴的负方向（向屏幕里）。</li><li><code>theta = 3π/2</code>：点位于X轴的负方向（向左）。<br>这种球坐标系统非常有用于处理与球面或者环绕运动相关的场景，如天体模拟、相机环绕目标物体的动作等。</li></ul></blockquote><p>正确写法：<code>let uv = new Three.Vector2((sph.theta + Math.PI) / (2 * Math.PI), 1 - (sph.phi / Math.PI));</code> </p><p>为了正确理解这段代码 <code>let uv = [(sph.theta + Math.PI) / (2 * Math.PI), 1 - (sph.phi / Math.PI)];</code> 并将二维贴图UV映射到球面上，让我们逐一分析每个部分：</p><ol><li><p><strong><code>(sph.theta + Math.PI) / (2 * Math.PI)</code></strong>:</p><ul><li><code>sph.theta</code> 表示球坐标中的方位角，通常的取值范围是从 0 到 2π，表示从正Z轴顺时针到X轴再回到Z轴的全周角度。</li><li><code>+ Math.PI</code> 的作用是将θ的起始点从正Z轴（前面）调整到负Z轴（后面）。通常，这种调整是为了使UV映射的起点对应于模型的后方，从而使得当模型前向朝向观察者时，贴图的“前面”能够正对观察者。</li><li>除以 <code>(2 * Math.PI)</code> 将调整后的θ值归一化到 [0, 1] 的范围内，这样可以映射到贴图的水平坐标U。</li></ul></li><li><p><strong><code>1 - (sph.phi / Math.PI)</code></strong>:</p><ul><li><code>sph.phi</code> 是从正Y轴向球面的点的仰角，取值范围是从 0 到 π。</li><li><code>(sph.phi / Math.PI)</code> 将φ值归一化到 [0, 1] 范围内，其中0代表北极，1代表南极。</li><li><code>1 -</code> 的作用是反转V坐标，使得在UV贴图中，V &#x3D; 0 对应于球体的北极，V &#x3D; 1 对应于球体的南极。这样的反转是必要的，因为在大多数图形处理系统中，贴图的V坐标从下到上增加，而球坐标系统中的φ是从上到下增加的。</li></ul></li></ol><p>(Three.js地理坐标和三维空间坐标的转换)[<a href="https://blog.csdn.net/qihoo_tech/article/details/101443066]">https://blog.csdn.net/qihoo_tech/article/details/101443066]</a></p><p><img src="https://s2.loli.net/2024/09/09/pbtr2HfNW7xTSkC.png" alt="image-20240908162225403.png"></p><h2 id="trail没显示出来"><a href="#trail没显示出来" class="headerlink" title="trail没显示出来"></a>trail没显示出来</h2><p>vLineDistance &#x2F;&#x2F; 在使用 Three.js 的 LineDashedMaterial 时，确保顶点着色器正确地计算并传递 vLineDistance 变量到片元着色器是非常关键的，因为这个变量决定了线段的虚线效果。</p><p>原先是再setPath里修改点的位置，然后计算lineDistance，由于lineDistance计算有问题，所以在fragment shader里，vLineDistance就都是0</p><p>在setPath的代码里，求division需要用pos.count来-1，之前是pos直接-1，导致了错误，使得trail的pos都没有正确更新；</p><h2 id="按钮切换效果不出来"><a href="#按钮切换效果不出来" class="headerlink" title="按钮切换效果不出来"></a>按钮切换效果不出来</h2><p>如果在 <code>useEffect</code> 中的依赖数组（第二个参数）设置为空数组 <code>[]</code>，这意味着 <code>useEffect</code> 只会在组件首次挂载时运行一次，而不会在组件的状态或属性更新时再次运行。这常用于执行那些只需一次的初始化操作，如 API 调用或设置初始配置。</p><p>在您的情况中，如果 <code>animate</code> 函数在 <code>useEffect</code> 内定义，并且依赖数组为空，这会导致 <code>animate</code> 函数捕获到初始渲染时的状态值，例如 <code>renderGlithPass</code> 的初始值（<code>false</code>）。即使后续 <code>renderGlithPass</code> 状态更新，<code>animate</code> 函数中的值也不会更新，因为 <code>useEffect</code> 不会重新执行来更新闭包中的状态值。</p><p>解决方法</p><p>要让 <code>animate</code> 函数能够访问最新的 <code>renderGlithPass</code> 状态，您有两个选择：</p><ol><li><strong>更新 <code>useEffect</code> 的依赖数组</strong>：在依赖数组中包含 <code>renderGlithPass</code>，这样每次 <code>renderGlithPass</code> 改变时，<code>useEffect</code> 都会重新执行，<code>animate</code> 函数也将重新定义，从而捕获到最新的状态值。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(renderGlithPass);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> animationId = <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">cancelAnimationFrame</span>(animationId);</span><br><span class="line">&#125;, [renderGlithPass]); <span class="comment">// 现在包含 renderGlithPass 作为依赖</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用 <code>useRef</code> 追踪最新的状态</strong>：如之前所述，您可以使用 <code>useRef</code> 来追踪 <code>renderGlithPass</code> 的最新值，这样 <code>animate</code> 函数可以通过 ref 访问当前的状态，而无需重新定义 <code>animate</code> 函数。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderGlithPassRef = <span class="title function_">useRef</span>(renderGlithPass);</span><br><span class="line">renderGlithPassRef.<span class="property">current</span> = renderGlithPass;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(renderGlithPassRef.<span class="property">current</span>); <span class="comment">// 使用 ref 访问最新状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> animationId = <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">cancelAnimationFrame</span>(animationId);</span><br><span class="line">&#125;, []); <span class="comment">// 依赖数组仍然为空</span></span><br></pre></td></tr></table></figure><p>这两种方法各有优势，选择哪一种取决于您的具体需求和组件的其他逻辑。如果 <code>animate</code> 函数对性能要求较高并且状态更新频繁，使用 <code>useRef</code> 可能是一个更好的选择。如果状态更新对 <code>animate</code> 的影响比较大，并且确保每次都是最新的状态很重要，那么更新 <code>useEffect</code> 的依赖数组可能更适合。</p><h2 id="animate里的renderGlithPass总是false，未更新"><a href="#animate里的renderGlithPass总是false，未更新" class="headerlink" title="animate里的renderGlithPass总是false，未更新"></a>animate里的renderGlithPass总是false，未更新</h2><p>在你的React代码中，你遇到的问题是由于闭包（closure）引起的。在JavaScript和React中，闭包会捕获它们创建时的环境状态。当你在 <code>useEffect</code> 钩子里调用 <code>animate()</code> 函数时，这个函数被“固定”在了那一刻的状态，包括 <code>renderGlithPass</code> 的值。</p><p>因为 <code>useEffect</code> 仅在组件挂载时执行一次（因为它的依赖列表是空的 <code>[]</code>），所以 <code>animate</code> 函数只会捕获 <code>renderGlithPass</code> 最初的值，即 <code>false</code>。之后即使状态更新了，<code>animate</code> 函数中捕获的 <code>renderGlithPass</code> 的值仍然是最初的 <code>false</code>。</p><p>解决这个问题的一个方法是使用 <code>useRef</code> 钩子来持久化 <code>renderGlithPass</code> 的值，这样 <code>animate</code> 函数总是能获取到最新的状态。这里是如何修改你的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [renderGlitchPass, setRenderGlitchPass] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> renderGlitchPassRef = <span class="title function_">useRef</span>(renderGlitchPass);  <span class="comment">// 使用 useRef 来持久化状态</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  renderGlitchPassRef.<span class="property">current</span> = renderGlitchPass;  <span class="comment">// 更新 ref 的值</span></span><br><span class="line">&#125;, [renderGlitchPass]);  <span class="comment">// 每当 renderGlitchPass 更新时，更新 ref</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable constant_">TWEEN</span>.<span class="title function_">update</span>();</span><br><span class="line">    earth.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.001</span>;</span><br><span class="line">    renderer &amp;&amp; scene &amp;&amp; camera &amp;&amp; renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ref 的 current 值来获取最新状态</span></span><br><span class="line">    renderGlitchPassRef.<span class="property">current</span> &amp;&amp; composer.<span class="title function_">render</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">animate</span>();  <span class="comment">// 启动动画循环</span></span><br><span class="line">&#125;, []);  <span class="comment">// 空依赖列表，仅在组件挂载时执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleStartButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setRenderGlitchPass</span>(!renderGlitchPass);  <span class="comment">// 切换状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题-第一批&quot;&gt;&lt;a href=&quot;#问题-第一批&quot; class=&quot;headerlink&quot; title=&quot;问题(第一批)&quot;&gt;&lt;/a&gt;问题(第一批)&lt;/h1&gt;&lt;h2 id=&quot;球体的陆地和海洋并没有区分出来&quot;&gt;&lt;a href=&quot;#球体的陆地和海洋并没有区分出来&quot; cla</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/09/17/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%953/"/>
    <id>https://youxt-njnu.github.io/2024/09/17/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%953/</id>
    <published>2024-09-17T10:02:05.000Z</published>
    <updated>2024-10-05T12:05:02.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="机甲风head和card"><a href="#机甲风head和card" class="headerlink" title="机甲风head和card"></a>机甲风head和card</h1><p>新建constant.js，存放一些固定的内容文本数组；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> weekMap =&#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> tips = [...];</span><br></pre></td></tr></table></figure><p>设置state存放显示的内容；<br>在 React 中，组件可以是类组件或函数式组件。在函数式组件中，传统的类组件中的 state 和生命周期方法被 React Hooks 提供的功能所替代。最常用的 Hook 是 useState，它用于在函数式组件中添加状态管理功能。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [week, setWeek] = <span class="title function_">useState</span>(weekMap[<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>()]);</span><br><span class="line"><span class="keyword">const</span> [time, setTime] = <span class="title function_">useState</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>());</span><br><span class="line"><span class="keyword">const</span> [showModal, setShowModal] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [modelText, setModelText] = <span class="title function_">useState</span>(tips[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> [renderGlithPass, setRenderGlithPass] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>header结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&quot;hud-header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;`$&#123;week&#125;曜日`&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;time&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Kepler-90 +49°18′18.58″<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scss里写clip-path</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">  <span class="variable">$yellow-color</span>: <span class="number">#f9f002</span>;</span><br><span class="line">  <span class="variable">$border-color</span>: <span class="number">#8ae66e</span>;</span><br><span class="line">  <span class="variable">$blue-color</span>: <span class="number">#00e6f6</span>;</span><br><span class="line">  <span class="variable">$header-height</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="variable">$aside-width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="variable">$glitched-duration</span>: <span class="number">0.9s</span>;</span><br><span class="line">  <span class="variable">$clip-height</span>: <span class="number">18px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.earth-digital</span> &#123;</span><br><span class="line">  <span class="comment">// overflow: hidden; // 这样子就没有了右侧拖动条，多出来的直接消失了</span></span><br><span class="line">  <span class="comment">// user-select: none; // 禁止选中文字</span></span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">0.85</span>); <span class="comment">// 饱和度 体现在哪儿？？</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hud</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  &amp;<span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$header-height</span>;</span><br><span class="line">    <span class="attribute">color</span>: black; <span class="comment">// 里面的文字颜色</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$yellow-color</span>; <span class="comment">// header 的背景颜色</span></span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;<span class="variable">$clip-height</span>&#125;),<span class="number">75%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;), <span class="number">72.5%</span> <span class="number">100%</span>, <span class="number">27.5%</span> <span class="number">100%</span>, <span class="number">25%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;),<span class="number">0</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;),<span class="number">0</span> <span class="number">0</span>); <span class="comment">// 使用calc的时候，里面操作符前后要有空格</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/11/ZL9FgtrxEBW2ame.jpg" alt="27e2baa8c3a79d08953b367291a0195.jpg"></p><p>logo和aside部分的结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;logo-pic&quot; title=&#x27;Cyberpunk 2077&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside left&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;cover&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div className=&quot;info&quot;&gt;</span><br><span class="line">      &lt;p&gt;&lt;b&gt;Cyberpunk&lt;/b&gt; is a subgenre of science fiction in a dystopian futuristic setting that tends to focus on a &quot;combination of lowlife and high tech&quot;, featuring futuristic technological and scientific achievements, such as artificial intelligence and cybernetics, juxtaposed with societal collapse or decay. &lt;/p&gt;</span><br><span class="line">      &lt;button&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside right&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br></pre></td></tr></table></figure><h1 id="button点击后出现故障风"><a href="#button点击后出现故障风" class="headerlink" title="button点击后出现故障风"></a>button点击后出现故障风</h1><p>点击触发函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const handleStartButtonClick = () =&gt; &#123;</span><br><span class="line">    setRenderGlithPass(!renderGlithPass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>动画中更新：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const animate = () =&gt; &#123;</span><br><span class="line"> ......</span><br><span class="line">  renderGlithPass &amp;&amp; composer.render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后处理效果"><a href="#后处理效果" class="headerlink" title="后处理效果"></a>后处理效果</h2><p>导入composer和pass</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EffectComposer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/EffectComposer.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RenderPass</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/RenderPass.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GlitchPass</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/GlitchPass.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>initThree里初始化</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">composer = <span class="keyword">new</span> <span class="title class_">EffectComposer</span>(renderer);</span><br><span class="line">composer.<span class="title function_">addPass</span>(<span class="keyword">new</span> <span class="title class_">RenderPass</span>(scene, camera));</span><br><span class="line">composer.<span class="title function_">addPass</span>(<span class="keyword">new</span> <span class="title class_">GlitchPass</span>());</span><br></pre></td></tr></table></figure><h2 id="btn的样式"><a href="#btn的样式" class="headerlink" title="btn的样式"></a>btn的样式</h2><p>利用linear-gradient，实现了45度方向上，从透明到红色的按钮的突变（5%，5%），这个和《CSS揭秘》里的内容呼应了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.startBtn</span>,</span><br><span class="line"><span class="selector-class">.startBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">5%</span>, <span class="number">#FF013C</span> <span class="number">5%</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">6px</span> <span class="number">0</span> <span class="number">0</span> $blue-color;</span><br><span class="line">  <span class="attribute">outline</span>: transparent;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h1><p><a href="https://echarts.apache.org/handbook/zh/basics/import/">https://echarts.apache.org/handbook/zh/basics/import/</a></p><p>按需引入：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts/core&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入柱状图图表，图表后缀都为 Chart</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BarChart</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/charts&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入标题，提示框，直角坐标系，数据集，内置数据转换器组件，组件后缀都为 Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">TitleComponent</span>,</span><br><span class="line">  <span class="title class_">TooltipComponent</span>,</span><br><span class="line">  <span class="title class_">GridComponent</span>,</span><br><span class="line">  <span class="title class_">DatasetComponent</span>,</span><br><span class="line">  <span class="title class_">TransformComponent</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/components&#x27;</span>;</span><br><span class="line"><span class="comment">// 标签自动布局、全局过渡动画等特性</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LabelLayout</span>, <span class="title class_">UniversalTransition</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/features&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CanvasRenderer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/renderers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册必须的组件</span></span><br><span class="line">echarts.<span class="title function_">use</span>([</span><br><span class="line">  <span class="title class_">TitleComponent</span>,</span><br><span class="line">  <span class="title class_">TooltipComponent</span>,</span><br><span class="line">  <span class="title class_">GridComponent</span>,</span><br><span class="line">  <span class="title class_">DatasetComponent</span>,</span><br><span class="line">  <span class="title class_">TransformComponent</span>,</span><br><span class="line">  <span class="title class_">BarChart</span>,</span><br><span class="line">  <span class="title class_">LabelLayout</span>,</span><br><span class="line">  <span class="title class_">UniversalTransition</span>,</span><br><span class="line">  <span class="title class_">CanvasRenderer</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>构建数据 constant.js</p><p>导入：<br><code>import &#123; chart_1_option, chart_2_option, chart_3_option, chart_4_option, chart_5_option, weekMap, tips &#125; from &#39;@/containers/EarthDigital/scripts/config&#39;;</code></p><p>初始化chart</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const chart_1 = echarts.init(document.getElementsByClassName(&#x27;chart_1&#x27;)[0], &#x27;dark&#x27;);</span><br><span class="line">   chart_1 &amp;&amp; chart_1.setOption(chart_1_option);</span><br></pre></td></tr></table></figure><p>使用useRef进行简化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let chartsRef = Array.from(&#123; length: 5 &#125;).map(() =&gt; useRef(null));</span><br><span class="line">const initChart = () =&gt; &#123;</span><br><span class="line">  const chartsOption = [chart_1_option, chart_2_option, chart_3_option, chart_4_option, chart_5_option];</span><br><span class="line">  const charts = chartsRef.map(ref =&gt; ref.current &amp;&amp; echarts.init(ref.current, &#x27;dark&#x27;));</span><br><span class="line">  charts.forEach((chart, idx) =&gt; &#123;</span><br><span class="line">    chart &amp;&amp; chart.setOption(chartsOption[idx]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的aside</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aside className=&quot;hud aside left&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box box_0 inverse&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;cover&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div className=&quot;info&quot;&gt;</span><br><span class="line">      &lt;p className=&#x27;text&#x27;&gt;&lt;b&gt;Cyberpunk&lt;/b&gt; is a subgenre of science fiction in a dystopian futuristic setting that tends to focus on a &quot;combination of lowlife and high tech&quot;, featuring futuristic technological and scientific achievements, such as artificial intelligence and cybernetics, juxtaposed with societal collapse or decay. &lt;/p&gt;</span><br><span class="line">      &lt;button className=&quot;startBtn&quot; onClick=&#123;handleStartButtonClick&#125;&gt;START&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[0]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[1]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside right&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[2]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[3]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[4]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br></pre></td></tr></table></figure><p>echarts里的option配置</p><p><img src="https://s2.loli.net/2024/09/26/29DpPhmGLj16kyb.jpg" alt="7d30adb4f9c8155b133b9b7b6a939fa.jpg"></p><p>注意：每一种图表形式的使用，都要按需导入；</p><p>针对areaStyle里的颜色，可以不导入echarts，直接colorStops来实现；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来：</span></span><br><span class="line"><span class="attr">areaStyle</span>: &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.8</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="keyword">new</span> echarts.<span class="property">graphic</span>.<span class="title class_">LinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, [&#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgb(128, 255, 165)&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgb(1, 191, 236)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后：</span></span><br><span class="line"><span class="attr">areaStyle</span>: &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.8</span>,</span><br><span class="line">  <span class="attr">color</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;linear&#x27;</span>, <span class="comment">// 线性渐变</span></span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">x2</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y2</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">colorStops</span>: [</span><br><span class="line">      &#123; <span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">&#x27;rgb(255, 191, 0)&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">offset</span>: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">&#x27;rgb(224, 62, 76)&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h1><p>.。。。。。待更新。。。。。。。</p><h2 id="补充-clip-path属性"><a href="#补充-clip-path属性" class="headerlink" title="补充 | clip-path属性"></a>补充 | clip-path属性</h2><p>CSS 中的 <code>clip-path</code> 属性允许你定义一个元素的可见区域。通过这个属性，你可以指定一个路径，在这个路径内的内容会被显示，而路径外的内容则会被隐藏。这是一个非常强大的工具，因为它可以用来创建各种复杂的形状和动态效果。</p><ol><li><p><strong>创建复杂形状</strong>：使用 <code>clip-path</code>，你可以轻松创建圆形、椭圆、多边形或者自定义路径（使用 SVG 路径语法）等形状。这对于设计先进的用户界面和特殊的图形效果非常有用。</p></li><li><p><strong>交互效果</strong>：你可以结合动画和过渡效果使用 <code>clip-path</code>，以实现视觉上吸引人的交互动画。例如，当用户悬停或点击元素时改变 <code>clip-path</code> 的形状。</p></li><li><p><strong>掩盖和显示内容</strong>：它可以被用来掩盖元素的某部分或只显示某部分，这在创建仪表板、卡片或其他包含隐藏详细信息的界面元素时尤其有用。</p></li></ol><p><strong>基本语法</strong>：<br>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: shape | none;</span><br></pre></td></tr></table></figure><br>  其中 <code>shape</code> 可以是以下几种类型：</p><ul><li><p><strong>圆形</strong>（<code>circle()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50%</span>);</span><br></pre></td></tr></table></figure><p>这会创建一个圆形剪裁区域，其中 <code>50%</code> 是圆的半径。</p></li><li><p><strong>椭圆</strong>（<code>ellipse()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(<span class="number">50%</span> <span class="number">25%</span>);</span><br></pre></td></tr></table></figure><p>这将创建一个椭圆剪裁区域，其中第一个值是水平半径，第二个值是垂直半径。</p></li><li><p><strong>多边形</strong>（<code>polygon()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">50%</span> <span class="number">100%</span>, <span class="number">0%</span> <span class="number">50%</span>);</span><br></pre></td></tr></table></figure><p>这将创建一个菱形剪裁区域，每个百分比对是多边形一个顶点的坐标。</p></li><li><p><strong>使用 URL</strong>（SVG 剪裁路径）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">url</span>(<span class="string">#clip-shape</span>);</span><br></pre></td></tr></table></figure><p>这里 <code>#clip-shape</code> 是 SVG 内的 <code>&lt;clipPath&gt;</code> 元素的 ID，允许你使用 SVG 的复杂路径定义剪裁形状。</p></li></ul><p>通过使用 <code>clip-path</code>，开发者可以在不需要额外图像或 SVG 文件的情况下，直接在 CSS 中创建视觉上吸引人的形状和效果。这使得页面加载更快，也使得动态效果的实现更为简便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/09/11/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%952/"/>
    <id>https://youxt-njnu.github.io/2024/09/11/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%952/</id>
    <published>2024-09-11T02:02:05.000Z</published>
    <updated>2024-10-05T12:02:34.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><p>🔁 后话2-callback 🍵</p><ul><li>unforms统一存shader里uniform的初始值</li></ul><p>🔁 后话1-callback 🍵</p><ul><li>构造位于半径为5的球面上的冲击点、冲击最大半径、冲击比例、之前的点位置、飞线的比例和长度</li></ul><p>安装dat.gui的库：<code>npm i dat.gui @types/dat.gui</code></p><p>添加进入gui；</p><p>gui设置隐藏，通过键盘H键唤起；</p><h1 id="飞线"><a href="#飞线" class="headerlink" title="飞线"></a>飞线</h1><p>🔁 后话1-callback 🍵</p><ul><li>取消注释</li></ul><p><img src="C:\Users\Xiangting\AppData\Roaming\Typora\typora-user-images\image-20240913170816909.png" alt="image-20240913170816909"></p><h3 id="制作飞线"><a href="#制作飞线" class="headerlink" title="制作飞线"></a>制作飞线</h3><p>初始化100个点，得到一条路径；添加index属性，形成起止正确的路径，加入trails</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeTrail</span> (idx) &#123;</span><br><span class="line">  <span class="keyword">let</span> pts = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100</span>*<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>); </span><br><span class="line">  <span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line">  g.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Float32BufferAttribute</span>(pts,<span class="number">3</span>));</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">LineDashedMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: params.<span class="property">colors</span>.<span class="property">gradOuter</span>,</span><br><span class="line">    <span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">onBeforeCompile</span>: <span class="function"><span class="params">shader</span> =&gt;</span> &#123;</span><br><span class="line">      shader.<span class="property">uniforms</span>.<span class="property">actionRatio</span> = impacts[idx].<span class="property">trailRatio</span>;</span><br><span class="line">      shader.<span class="property">uniforms</span>.<span class="property">lineLength</span> = impacts[idx].<span class="property">trailLength</span>;</span><br><span class="line">      shader.<span class="property">fragmentShader</span> = lineFragmentShader;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> l = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Line</span>(g,m);</span><br><span class="line">  l.<span class="property">userData</span>.<span class="property">idx</span> = idx;</span><br><span class="line">  <span class="title function_">setPath</span>(l,impacts[idx].<span class="property">prevPosition</span>,impacts[idx].<span class="property">impactPosition</span>);</span><br><span class="line">  trails.<span class="title function_">push</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置路径上点的位置和长度：传入当前路径、起点、终点、峰高、出现后经过几次弧度再进入后消失</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setPath</span> = (<span class="params">l, startPoint, endPoint, peakHeight,cycles</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">position</span>; <span class="comment">//预存点的最新位置</span></span><br><span class="line">  <span class="keyword">let</span> division = pos - <span class="number">1</span>; <span class="comment">//l上的分段数目</span></span><br><span class="line">  <span class="keyword">let</span> cycle = cycles || <span class="number">1</span>; <span class="comment">// cycle=4:↷↷↷↷</span></span><br><span class="line">  <span class="keyword">let</span> peak = peakHeight || <span class="number">1</span>; <span class="comment">//峰高</span></span><br><span class="line">  <span class="keyword">let</span> radius = startPoint.<span class="title function_">length</span>(); <span class="comment">// 对应球的半径</span></span><br><span class="line">  <span class="keyword">let</span> angle = startPoint.<span class="title function_">angleTo</span>(endPoint); <span class="comment">//起始点和终点的夹角</span></span><br><span class="line">  <span class="keyword">let</span> arcLength = radius * angle; <span class="comment">//弧长</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> diameterMinor = arcLength / <span class="title class_">Math</span>.<span class="property">PI</span>; <span class="comment">// 新圆的直径</span></span><br><span class="line">  <span class="keyword">let</span> radiusMinor = diameterMinor / <span class="number">2</span> / cycle; <span class="comment">// 考虑cycle下新圆的半径</span></span><br><span class="line">  <span class="keyword">let</span> peakRatio = peak / diameterMinor; <span class="comment">// 峰高比例</span></span><br><span class="line">  <span class="keyword">let</span> radiusMajor = radius + radiusMinor; <span class="comment">// 大圆的半径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> basisMajor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">setLength</span>(radiusMajor); <span class="comment">// trail的点基准1</span></span><br><span class="line">  <span class="keyword">let</span> basisMinor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">negate</span>().<span class="title function_">setLength</span>(radiusMinor); <span class="comment">// trail的点基准2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tri = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Triangle</span>(startPoint, endPoint, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>()); <span class="comment">// 三角形</span></span><br><span class="line">  <span class="keyword">let</span> nrm = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  tri.<span class="title function_">getNormal</span>(nrm); <span class="comment">// 拿到法线</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> v3Major = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">//里面的v3表示vec3 </span></span><br><span class="line">  <span class="keyword">let</span> v3Minor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  <span class="keyword">let</span> v3Inter = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  <span class="keyword">let</span> vFinal = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">// 里面v也可理解为varying</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=division;i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> divisionRatio = i / division; <span class="comment">// 分段比例</span></span><br><span class="line">    <span class="keyword">let</span> angleValue = divisionRatio * angle; <span class="comment">// 分段角度</span></span><br><span class="line">    v3Major.<span class="title function_">copy</span>(basisMajor).<span class="title function_">applyAxisAngle</span>(nrm, angleValue); <span class="comment">// 在basisMajor的基础上绕着法线旋转</span></span><br><span class="line">    v3Minor.<span class="title function_">copy</span>(basisMinor).<span class="title function_">applyAxisAngle</span>(nrm, angleValue+<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>*divisionRatio*cycle); <span class="comment">// 在basisMinor的基础上绕着法线旋转</span></span><br><span class="line">    v3Inter.<span class="title function_">addVectors</span>(v3Major, v3Minor); <span class="comment">// 两个向量相加</span></span><br><span class="line">    <span class="keyword">let</span> newLength = (v3Inter.<span class="title function_">length</span>() - radius) * peakRatio + radius; <span class="comment">// 新的长度</span></span><br><span class="line">    vFinal.<span class="title function_">copy</span>(v3Inter).<span class="title function_">setLength</span>(newLength); <span class="comment">// 设置新的长度</span></span><br><span class="line">    pos.<span class="title function_">setXYZ</span>(i,vFinal.<span class="property">x</span>,vFinal.<span class="property">y</span>,vFinal.<span class="property">z</span>); <span class="comment">// 设置新的位置</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新完了点数据后需要加上这句</span></span><br><span class="line">  pos.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  l.<span class="title function_">computeLineDistances</span>();  <span class="comment">// 计算每个顶点到起点的累加距离</span></span><br><span class="line">  l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line">  impacts[l.<span class="property">userData</span>.<span class="property">idx</span>].<span class="property">trailLength</span>.<span class="property">value</span> = l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">array</span>[<span class="number">99</span>];</span><br><span class="line">  l.<span class="property">material</span>.<span class="property">dashSize</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/28/GWszxuwCZIaV1EB.png" alt="202408281104602.png"></p><h4 id="飞线shader"><a href="#飞线shader" class="headerlink" title="飞线shader"></a>飞线shader</h4><p>下面是如何在你的 Vite 配置中添加对 <code>.glsl</code> 文件的支持的步骤：</p><ol><li>安装 <code>vite-plugin-glsl</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vite-plugin-glsl</span><br></pre></td></tr></table></figure></li><li>在你的 Vite 配置文件中（通常是 <code>vite.config.js</code> 或 <code>vite.config.ts</code>）添加插件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class="line">import glsl from &#x27;vite-plugin-glsl&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">    glsl()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这样配置后，当你导入 <code>.glsl</code> 文件时，<code>vite-plugin-glsl</code> 将自动处理它们，确保 GLSL 代码被作为字符串正确导入，避免 JavaScript 解析错误。</p><p>确保在你的 Vue 组件或 JavaScript 文件中按照下面的方式导入 <code>.glsl</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import textFragmentShader from &#x27;./Shader/text.frag.glsl&#x27;</span><br><span class="line">import textVertexShader from &#x27;./Shader/text.vert.glsl&#x27;</span><br></pre></td></tr></table></figure><p>这些文件现在应该会被正确地作为字符串导入，可以直接使用在 Three.js 的 <code>ShaderMaterial</code> 中。这应该解决你遇到的关于 GLSL 代码导入的问题。</p><p>页面中导入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lineFragmentShader from &#x27;./line.frag.glsl&#x27;;</span><br></pre></td></tr></table></figure><p>shader内容：</p><p>actionRatio 代码中是0 _ 动画中修改 </p><p>vLineDistance &#x2F;&#x2F; 在使用 Three.js 的 LineDashedMaterial 时，确保顶点着色器正确地计算并传递 vLineDistance 变量到片元着色器是非常关键的，因为这个变量决定了线段的虚线效果。</p><p>totalSize 一整个没用到</p><p>lineLength 到起点的累积距离</p><p>这段代码是一个在 Three.js 中使用的 GLSL shader，具体是用来处理具有虚线效果的线条材料（<code>LineDashedMaterial</code>）。这个 shader 控制着如何根据距离和虚线模式显示线条的片段。</p><ul><li><strong>uniforms</strong> 是从 Three.js 的 JavaScript 代码传递到 shader 的变量。<ul><li><code>mediump float</code>: 精度指示符，表明浮点运算使用中等精度。</li><li><code>actionRatio</code>: 控制线条的动画或进度的参数。</li><li><code>lineLength</code>: 线条的总长度。</li><li><code>diffuse</code>: 线条的颜色。</li><li><code>opacity</code>: 线条的不透明度。</li><li><code>dashSize</code>: 单个虚线的长度。</li><li><code>totalSize</code>: 虚线和间隔的总和长度。</li></ul></li><li><strong>varying</strong><ul><li><code>vLineDistance</code>: 表示当前片段在整个线条中的位置。</li></ul></li></ul><p><strong>虚线计算</strong>:</p><ul><li>首先计算出当前应显示的虚线位置。</li><li>根据 <code>vLineDistance</code> 和虚线参数计算出当前片段是否在虚线中还是在空白间隔中。如果在间隔中，使用 <code>discard</code> 抛弃这个片段，不进行渲染。</li><li>使用渐变 (<code>grad</code>) 来处理虚线的边缘，使得虚线边缘平滑过渡。</li></ul><ol><li>顶点着色器中的计算:</li></ol><p>在顶点着色器中，每个顶点的位置被用来计算它在整条线中的相对位置或距离，这个距离累计到 vLineDistance。例如，如果线条由多个段组成，每个段的长度会被累加到起点距离，直到当前顶点的位置。</p><ol start="2"><li>传递到片段着色器:</li></ol><p>这个计算出的距离 (vLineDistance) 作为一个 varying 变量，被传递到片段着色器。在图形管线中，顶点着色器处理后的结果（如位置、颜色、距离等）会通过插值传递到片段着色器。</p><ol start="3"><li>在片段着色器中，vLineDistance 用来确定每个片段是否应该被渲染为虚线的一部分：</li></ol><blockquote><p>float currPos &#x3D; (lineLength + dashSize) * actionRatio;<br>这里 currPos 表示虚线开始的位置，是通过线条总长度、虚线大小和动画比例 (actionRatio) 计算的。actionRatio 可能用于动态调整虚线的显示，比如滚动效果。<br>确定片段位置:</p></blockquote><blockquote><p>float d &#x3D; (vLineDistance + halfDash) - currPos;<br>这个计算检查当前片段的位置（vLineDistance + halfDash）相对于当前虚线开始位置的偏移量。halfDash 用于调整计算到虚线中心的距离。<br>判断是否在虚线内部:</p></blockquote><blockquote><p>if (abs(d) &gt; halfDash ) discard;如果偏移量大于 halfDash，则表示当前片段不在虚线内部，应该被丢弃（不渲染）。这样，只有在虚线范围内的片段会被渲染，形成断续的线条效果。</p></blockquote><ol start="4"><li>渐变边缘的处理:</li></ol><p>float grad &#x3D; ((vLineDistance + halfDash) - (currPos - halfDash)) &#x2F; halfDash; 这里 grad 用于计算当前片段在虚线边缘的位置，用于实现边缘的渐变效果。这可以让虚线的开始和结束更加平滑，不会突然截断。</p><p><img src="https://s2.loli.net/2024/09/11/yfOMo2NWJZVekbq.jpg" alt="ac03418e3341f086f3b780056121b39.jpg"></p><h4 id="补充-negate"><a href="#补充-negate" class="headerlink" title="补充 | negate"></a>补充 | <code>negate</code></h4><p><code>negate()</code> 是一个 Three.js 中的向量方法，它用来将向量中的每个分量取反，也就是每个分量乘以 -1。这样做的目的是将向量的方向反转。具体到这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> basisMinor = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">negate</span>().<span class="title function_">setLength</span>(radiusMinor);</span><br></pre></td></tr></table></figure><ul><li><code>new THREE.Vector3()</code> 创建一个新的三维向量，默认为 (0, 0, 0)。</li><li><code>.copy(startPoint)</code> 将 <code>startPoint</code> 的值复制到这个新的向量中。</li><li><code>.negate()</code> 将复制后的向量中的每个分量乘以 -1，实现向量方向的反转。</li><li><code>.setLength(radiusMinor)</code> 将反转后的向量的长度设置为 <code>radiusMinor</code>。</li></ul><p>这样，<code>basisMinor</code> 就变成了一个方向与 <code>startPoint</code> 相反、长度为 <code>radiusMinor</code> 的向量。</p><h4 id="补充-applyAxisAngle"><a href="#补充-applyAxisAngle" class="headerlink" title="补充 | applyAxisAngle"></a>补充 | <code>applyAxisAngle</code></h4><p>在 Three.js 中，<code>applyAxisAngle</code> 方法用于将一个旋转应用到一个向量上。这个方法接受两个参数：一个轴向量和一个角度。它的作用是围绕给定的轴向量旋转原向量指定的角度。</p><ol><li><strong>轴向量</strong> (<code>axis</code>): 这是一个标准化的三维向量，指定了旋转的轴。例如，若轴向量为 <code>(0, 1, 0)</code>，则表示围绕 y 轴进行旋转。</li><li><strong>角度</strong> (<code>angle</code>): 这是旋转的角度，单位是弧度。正值表示逆时针旋转，负值表示顺时针旋转（根据右手规则）。</li></ol><p>当你调用 <code>applyAxisAngle</code> 方法时，它会改变调用它的向量的方向，但保持向量的长度不变。这种旋转是通过右手规则来定义的，即如果你的右手拇指指向轴向量的方向，那么四指的卷曲方向定义了正旋转方向。</p><p>在 Three.js 中使用 <code>applyAxisAngle</code> 方法进行旋转时，向量是绕通过原点 (0, 0, 0) 的轴进行旋转的。轴向量只定义了旋转的方向和轴线，而不是旋转的位置。因此，这种旋转总是认为轴向量通过三维空间的原点。</p><p>旋转的中心点是坐标系统的原点 (0, 0, 0)。向量从它当前的位置开始，绕通过原点的轴旋转。这意味着：</p><ul><li>如果向量的一个端点位于原点，旋转将直接改变向量的方向，而长度保持不变。</li><li>如果向量的一个端点不在原点，向量会在想象中被拉直至原点，然后绕轴旋转，再放回原位置。</li></ul><p>如果你需要绕一个不在原点的点旋转向量，你需要先将系统平移到那个点变成新的原点，执行旋转，然后再平移回去。这可以通过以下步骤完成：</p><ol><li><strong>平移</strong> ：将向量和旋转中心点一同平移到原点附近。</li><li><strong>旋转</strong> ：在新的位置应用旋转。</li><li><strong>逆平移</strong> ：将旋转后的向量移回原始位置。</li></ol><h4 id="补充-needsUpdate"><a href="#补充-needsUpdate" class="headerlink" title="补充 | needsUpdate"></a>补充 | needsUpdate</h4><p>在 Three.js 中，<code>needsUpdate</code> 属性用于告诉引擎某个对象的数据已经改变，需要重新计算或重新上传到 GPU。这个属性常见于与几何体（<code>Geometry</code> 或 <code>BufferGeometry</code>）、材料（<code>Material</code>）、纹理（<code>Texture</code>）等相关的对象。</p><p>当你修改了几何体的顶点数据、纹理的内容、或者材料的参数等，这些改变不会自动反映在渲染的对象上，除非你明确地告诉 Three.js 这些数据已经更新。<code>needsUpdate</code> 属性就是用于这种通知。</p><p>示例 - 几何体顶点数据更新</p><p>假设你更改了一个几何体的顶点位置数据，你需要设置对应属性的 <code>needsUpdate</code> 为 <code>true</code>，以确保这些改变被应用到下一次渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改几何体顶点位置</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span>.<span class="title function_">setXYZ</span>(index, newX, newY, newZ);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记顶点位置数据为需要更新</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例 - 纹理内容更新</p><p>如果你修改了纹理的图像数据，你同样需要设置 <code>needsUpdate</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载一个新的图像到纹理</span></span><br><span class="line">texture.<span class="property">image</span> = newImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉Three.js纹理已更新</span></span><br><span class="line">texture.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例 - 材料属性更新</p><p>当改变材料的一些属性（如颜色、透明度等）后，如果要立即反映这些变化，同样需要更新 <code>needsUpdate</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改材料的颜色</span></span><br><span class="line">material.<span class="property">color</span>.<span class="title function_">setHex</span>(<span class="number">0xff0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记材料需要更新</span></span><br><span class="line">material.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="补充-computeLineDistances"><a href="#补充-computeLineDistances" class="headerlink" title="补充 | computeLineDistances"></a>补充 | <code>computeLineDistances</code></h4><p>在 Three.js 中，<code>Mesh</code> 对象本身并没有 <code>computeLineDistances()</code> 方法；这个方法是属于 <code>Line</code> 类的。<code>Line</code> 类用于创建和处理线段对象，在 3D 场景中表示由多个点连接而成的直线或折线。</p><p>该方法用于计算线段对象中每个顶点到线起点的累计距离，并将这些距离存储在线段的 <code>lineDistances</code> 属性中。这个功能通常与线性材料（<code>LineDashedMaterial</code>）一起使用，用来创建虚线效果。<code>LineDashedMaterial</code> 需要这些距离来正确地渲染每段虚线。</p><p>在 Three.js 中，当你使用 <code>computeLineDistances()</code> 方法计算线段（由 <code>THREE.Line</code> 或 <code>THREE.LineSegments</code> 类创建的对象）的每个顶点到起点的距离时，这些距离会存储在 <code>geometry.attributes.lineDistance</code> 的 <code>array</code> 属性中。这个数组中的每个元素代表从起点到对应顶点的累积距离。</p><p>数组索引是从 0 开始的。因此，数组中的第一个元素（索引 0）对应第一个顶点（通常是线段的起点），第二个元素（索引 1）对应第二个顶点，依此类推。索引 99 的元素就是数组中的第 100 个元素，对应于你的线段的第 100 个顶点。在 <code>array[99]</code> 中获取的值表示从线段的起点到第 100 个顶点的累积距离。</p><p>注意事项：</p><ul><li>如果你更改了线段的顶点位置，需要重新调用 <code>computeLineDistances()</code> 方法来更新距离数据。</li><li>这个方法仅对 <code>THREE.Line</code> 或 <code>THREE.LineSegments</code> 对象有效，对 <code>Mesh</code> 对象不适用。</li></ul><h4 id="补充-预制shader"><a href="#补充-预制shader" class="headerlink" title="补充 | 预制shader"></a>补充 | 预制shader</h4><p>在Three.js的shader编程中，<code>#include</code> 语句用于插入共用的代码块，这些代码块通常封装了一些常用的函数和变量定义，使得shader的编写更加模块化和可复用。下面是你提到的几个常见的include文件的用途：</p><ol><li><p><strong><code>&lt;common&gt;</code></strong>:</p><ul><li>这个文件包括了一些常用的数学函数和宏定义，比如计算线性插值、饱和度计算等，还有一些常用的常量定义，例如PI的值等。</li></ul></li><li><p><strong><code>&lt;color_pars_fragment&gt;</code></strong>:</p><ul><li>这个文件定义了与颜色处理相关的参数和函数，比如处理顶点颜色、漫反射等。</li></ul></li><li><p><strong><code>&lt;fog_pars_fragment&gt;</code></strong>:</p><ul><li>用于定义和计算雾效果(fog)的参数，使得物体在雾中逐渐消失的效果可以在shader中实现。</li></ul></li><li><p><strong><code>&lt;logdepthbuf_pars_fragment&gt;</code></strong>:</p><ul><li>如果启用了logarithmic depth buffer，这个文件包含了相关的实现，用来改善远距离渲染时的深度精度问题。</li></ul></li><li><p><strong><code>&lt;clipping_planes_pars_fragment&gt;</code></strong>:</p><ul><li>这个文件提供了剪裁平面的支持，使得可以在shader中处理剪裁逻辑，仅渲染剪裁平面允许的部分。</li></ul></li></ol><p>要查找Three.js中可用的所有shader chunks，最好的方法是直接查看Three.js的源代码。在GitHub上的Three.js库中，这些shader chunk文件位于<code>src/renderers/shaders/ShaderChunk/</code>目录下。</p><h3 id="飞线动画"><a href="#飞线动画" class="headerlink" title="飞线动画"></a>飞线动画</h3><p>内容结构：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setTrailAnimation</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tweens = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;maxImpactAmount;i++) &#123;</span><br><span class="line">      tweens.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">runTween</span>: <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    tweens.<span class="title function_">forEach</span>(<span class="function"><span class="params">t</span>=&gt;</span>t.<span class="title function_">runTween</span>());</span><br><span class="line">    <span class="title function_">createPoints</span>(); <span class="comment">// 因为runTween会影响到points的效果</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>for循环里的设置</p><p>更新了impacts，同时也影响到了球体的效果；</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxImpactAmount; i++) &#123;</span><br><span class="line">  tweens.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">runTween</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> path = trails[i]; <span class="comment">// 当前路径</span></span><br><span class="line">      <span class="keyword">let</span> speed = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">let</span> len = path.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">array</span>[<span class="number">99</span>];</span><br><span class="line">      <span class="keyword">let</span> dur = len / speed; <span class="comment">// 持续时间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> tweenTrail = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line">        .<span class="title function_">to</span>(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, dur * <span class="number">1000</span>)</span><br><span class="line">        .<span class="title function_">onUpdate</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          impacts[i].<span class="property">trailRatio</span>.<span class="property">value</span> = val.<span class="property">value</span>; <span class="comment">// 通过Tween来控制trailRatio/actionRatio</span></span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">var</span> tweenImpact = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line">        .<span class="title function_">to</span>(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randInt</span>(<span class="number">2500</span>, <span class="number">5000</span>))</span><br><span class="line">        .<span class="title function_">onUpdate</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          uniformsSettings.<span class="property">impacts</span>.<span class="property">value</span>[i].<span class="property">impactRatio</span> = val.<span class="property">value</span>; <span class="comment">// 通过Tween来控制impactRatio</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">onComplete</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          impacts[i].<span class="property">prevPosition</span>.<span class="title function_">copy</span>(impacts[i].<span class="property">impactPosition</span>);</span><br><span class="line">          impacts[i].<span class="property">impactPosition</span>.<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>);</span><br><span class="line">          <span class="title function_">setPath</span>(path, impacts[i].<span class="property">prevPosition</span>, impacts[i].<span class="property">impactPosition</span>, <span class="number">1</span>);</span><br><span class="line">          uniformsSettings.<span class="property">impacts</span>.<span class="property">value</span>[i].<span class="property">impactMaxRadius</span> = <span class="number">5</span> * <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloat</span>(<span class="number">0.5</span>, <span class="number">0.75</span>);</span><br><span class="line">          tweens[i].<span class="title function_">runTween</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      tweenTrail.<span class="title function_">chain</span>(tweenImpact);</span><br><span class="line">      tweenTrail.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅴ</title>
    <link href="https://youxt-njnu.github.io/2024/09/04/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/"/>
    <id>https://youxt-njnu.github.io/2024/09/04/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</id>
    <published>2024-09-04T01:40:26.000Z</published>
    <updated>2024-09-04T14:03:37.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-patterns"><a href="#记录-patterns" class="headerlink" title="记录-patterns"></a>记录-patterns</h1><p>fract(),取小数部分；</p><p>实现pattern的绘制：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circle(<span class="keyword">in</span> <span class="type">vec2</span> _st, <span class="keyword">in</span> <span class="type">float</span> _radius)&#123;</span><br><span class="line">    <span class="type">vec2</span> l = _st-<span class="type">vec2</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>-<span class="built_in">smoothstep</span>(_radius-(_radius*<span class="number">0.01</span>),</span><br><span class="line">                        _radius+(_radius*<span class="number">0.01</span>),</span><br><span class="line">                         <span class="built_in">dot</span>(l,l)*<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> pattern2d(<span class="keyword">in</span> <span class="type">float</span> x, <span class="keyword">in</span> <span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    st.x *= x;   </span><br><span class="line">    st.y *= y; <span class="comment">// Scale up the space by 3</span></span><br><span class="line">    st = <span class="built_in">fract</span>(st); <span class="comment">// Wrap around 1.0</span></span><br><span class="line">    </span><br><span class="line">    color = <span class="type">vec3</span>(st,<span class="number">0.0</span>);</span><br><span class="line">    color = <span class="type">vec3</span>(circle(st,<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec3</span> color = pattern2d(<span class="number">2.1</span>,<span class="number">5.</span>);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在pattern上，结合旋转、平移、缩放，来丰富pattern</p><p>判断奇偶行，可以通过mod取余，加上三元运算符或step，来形成0和1的判断；</p><p>Truchet Tiles的绘制，通过给不同的区间设置index，根据index来判断旋转多少度；</p><h1 id="记录-random"><a href="#记录-random" class="headerlink" title="记录-random"></a>记录-random</h1><p>rand()得到的类似于fract(sin(…))，在一片随机内，部分地方存在着较大波动；</p><p>利用fract, sin, dot来实现2D下的随机；</p><p>可以构建grid形态下的随机灰度填充；</p><h1 id="记录-noise"><a href="#记录-noise" class="headerlink" title="记录-noise"></a>记录-noise</h1><p>mix()进行线性插值；</p><p>在一些 noise 的应用中你会发现程序员喜欢用他们自己的三次多项式函数（func），而不是用 smoothstep()。</p><p>mix(rand(i),rand(i+1.0),func);</p><p>二维插值；</p><p>value noise和gradient noise的区别； simplex noise</p><p>结合distance field来绘制；</p><p>三维插值；</p><h1 id="记录-Cellular-Noise"><a href="#记录-Cellular-Noise" class="headerlink" title="记录-Cellular Noise"></a>记录-Cellular Noise</h1><p>求纹理空间下的坐标，到指定坐标的最小距离，加到颜色上，进行呈现；</p><p>类似于Voronoi图；</p><p>通过遍历周边8个格网，进行综合；</p><p>Voronoi算法；</p><p>voro-nose;</p><h1 id="记录-Fractal-Brownian-Motion-x2F-Fractal-Noise"><a href="#记录-Fractal-Brownian-Motion-x2F-Fractal-Noise" class="headerlink" title="记录-Fractal Brownian Motion&#x2F;Fractal Noise"></a>记录-Fractal Brownian Motion&#x2F;Fractal Noise</h1><p>利用sin函数，修改frequency和amplitude</p><blockquote><p>通过在循环（循环次数为 octaves，一次循环为一个八度）中叠加噪声，并以一定的倍数（lacunarity，间隙度）连续升高频率，同时以一定的比例（gain，增益）降低 噪声 的振幅，最终的结果会有更好的细节。这项技术叫“分形布朗运动（fractal Brownian Motion）”（fBM），或者“分形噪声（fractal noise）”</p></blockquote><blockquote><p>这项技术被广泛地应用于构造程序化风景。fBm 的自相似性能够很完美地模拟山脉，因为山脉形成过程中的腐蚀形成了这种不同尺度上的自相似性</p></blockquote><p>fbm构造山谷和山脊 —— turbulence效果</p><p>使用fbm模拟fbm —— 云的效果</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>图像处理</p><ul><li>纹理</li><li>图像处理</li><li>卷积核</li><li>滤镜</li><li>其他效果</li></ul><p>模拟</p><ul><li>乒乓</li><li>Conway生命游戏</li><li>水波</li><li>水彩</li><li>反应扩散</li></ul><p>3D 图形</p><ul><li>灯光</li><li>法线贴图</li><li>凹凸贴图</li><li>Ray marching</li><li>环境贴图 (spherical and cube)</li><li>折射和反射</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>three+react|加自己模型</title>
    <link href="https://youxt-njnu.github.io/2024/09/02/three-%E5%8A%A0%E8%87%AA%E5%B7%B1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://youxt-njnu.github.io/2024/09/02/three-%E5%8A%A0%E8%87%AA%E5%B7%B1%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-09-02T12:37:05.000Z</published>
    <updated>2024-09-03T01:21:02.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加自己的模型"><a href="#添加自己的模型" class="headerlink" title="添加自己的模型"></a>添加自己的模型</h1><p>前言，在<a href="https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%981/">该项目</a>中加自己的模型，及问题解决；</p><p>先sketchfab上下载模型，在unity里调整位置、贴图、材质、动画，形成prefab；</p><p>利用<a href="https://github.com/Plattar/gltf-exporter?tab=readme-ov-file">插件</a>，导出为gltf；”E:\PersonalCV\models\v1.142.0-unity.unitypackage”</p><p>在vite.config.ts里加入<code>assetsInclude: [&#39;**/*.glb&#39;,&#39;**/*.gltf&#39;],</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useGLTF &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/drei&quot;</span></span><br><span class="line"><span class="keyword">import</span> word2D <span class="keyword">from</span> <span class="string">&#x27;../assets/3d/world_2d/world_2d.gltf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Map2D</span> = (<span class="params">&#123; ...props &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> gltf = <span class="title function_">useGLTF</span>(word2D);</span><br><span class="line">  <span class="keyword">const</span> scene = gltf.<span class="property">scene</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">mesh</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">primitive</span> <span class="attr">object</span>=<span class="string">&#123;scene&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">mesh</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Map2D</span></span><br></pre></td></tr></table></figure><p>法线模型里的顶点，x的坐标都是正确数值的相反数，例如这个<a href="https://sketchfab.com/3d-models/cartoon-low-poly-world-map-e87fa1e143f84348a915b7fe1376d957">模型</a>下下来就这样问题：</p><ol><li>blender里，右上角切换object Mode为Edit Mode</li><li>A全选所有物体</li><li>Mesh -&gt;Mirror-&gt;X Global</li><li>按 <code>Ctrl + A</code> 并选择 <code>All Transforms</code>，应用变换</li></ol><p><img src="https://s2.loli.net/2024/09/02/mZD8AeFVyHXajiz.png" alt="image.png"></p><p>补充，针对法线反了的，1.2.4不变，3 mesh-&gt;Normals-&gt;Flip</p><p>针对贴图反了的，例如这个作者的很多<a href="https://skfb.ly/orJVW">模型</a>，PS里 图像-&gt;图像旋转-&gt;垂直旋转画布&#x2F;水平翻转画布</p><p>此外，在项目中打包的时候，只会打包gltf这一个文件，其附属的bin和png文件会落单；<br>这个时候我采用的是把gltf相关的都放在gltfModels文件夹，将gltfModels文件夹放到了public目录下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;添加自己的模型&quot;&gt;&lt;a href=&quot;#添加自己的模型&quot; class=&quot;headerlink&quot; title=&quot;添加自己的模型&quot;&gt;&lt;/a&gt;添加自己的模型&lt;/h1&gt;&lt;p&gt;前言，在&lt;a href=&quot;https://youxt-njnu.github.io/2024/02/</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅳ</title>
    <link href="https://youxt-njnu.github.io/2024/08/28/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/"/>
    <id>https://youxt-njnu.github.io/2024/08/28/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</id>
    <published>2024-08-28T07:55:26.000Z</published>
    <updated>2024-09-04T01:40:33.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-2D-Matrics"><a href="#记录-2D-Matrics" class="headerlink" title="记录-2D Matrics"></a>记录-2D Matrics</h1><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>利用u_time, sin, cos构造移动，加到st；通过cross把这种移动突出出来；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">// _size=vec2(width,height)</span><br><span class="line">float box(in vec2 _st, in vec2 _size)&#123;</span><br><span class="line">    _size = vec2(0.5) - _size*0.5;</span><br><span class="line">    vec2 uv = smoothstep(_size,</span><br><span class="line">                        _size+vec2(0.01),</span><br><span class="line">                        _st);</span><br><span class="line">    uv *= smoothstep(_size,</span><br><span class="line">                    _size+vec2(0.001),</span><br><span class="line">                    vec2(1.0)-_st);</span><br><span class="line">    return uv.x*uv.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// input: st, crossSize</span><br><span class="line">float cross(in vec2 _st, float _size)&#123;</span><br><span class="line">    return  box(_st, vec2(_size,_size/4.)) +</span><br><span class="line">            box(_st, vec2(_size/4.,_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // To move the cross we move the space</span><br><span class="line">    vec2 translate = vec2(cos(u_time),sin(u_time));</span><br><span class="line">    st += translate*0.3;</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.154)); // 突出translate中心点的移动</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*GfW3IgV8F9bvbg7OijESlA.gif" alt="img"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define PI 3.14159265359</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">mat2 rotate2d(float _angle)&#123;</span><br><span class="line">    return mat2(cos(_angle),-sin(_angle),</span><br><span class="line">                sin(_angle),cos(_angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float box(in vec2 _st, in vec2 _size)&#123;</span><br><span class="line">    _size = vec2(0.5) - _size*0.5;</span><br><span class="line">    vec2 uv = smoothstep(_size,</span><br><span class="line">                        _size+vec2(0.001),</span><br><span class="line">                        _st);</span><br><span class="line">    uv *= smoothstep(_size,</span><br><span class="line">                    _size+vec2(0.001),</span><br><span class="line">                    vec2(1.0)-_st);</span><br><span class="line">    return uv.x*uv.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float cross(in vec2 _st, float _size)&#123;</span><br><span class="line">    return  box(_st, vec2(_size,_size/4.)) +</span><br><span class="line">            box(_st, vec2(_size/4.,_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // move space from the center to the vec2(0.0)</span><br><span class="line">    // st从0~1变成-0.5~0.5</span><br><span class="line">    st -= vec2(0.5);</span><br><span class="line">    // rotate the space,左乘，传入角度</span><br><span class="line">    st = rotate2d( sin(u_time)*1.*PI ) * st;</span><br><span class="line">    // move it back to the original place</span><br><span class="line">    st += vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.4));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*JaawntaOxPEcTdTQAVGs7A.gif" alt="img"></p><p>组合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // To move the cross we move the space</span><br><span class="line">    vec2 translate = vec2(cos(u_time),sin(u_time));</span><br><span class="line">    st += translate*0.35;</span><br><span class="line">  </span><br><span class="line">    st-=vec2(0.5);</span><br><span class="line">    st = rotate2d(u_time*PI)* st;</span><br><span class="line">    st+=vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.25));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*oGGqsWHMYC5C5PXEk6NUcg.gif" alt="img"></p><p>缩放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    st -= vec2(0.5);</span><br><span class="line">    st = scale( vec2(sin(u_time)+1.704) ) * st;</span><br><span class="line">    st += vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.2));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于数字 <code>1.704</code> 的影响：</p><ol><li><strong>缩放调整</strong> ：</li></ol><ul><li><code>sin(u_time) + 1.704</code>：这个表达式通过添加 <code>1.704</code> 来确保 <code>sin</code> 函数的结果（范围在 [-1, 1]）永远是正的，因此 <code>sin(u_time) + 1.704</code> 的结果范围大约在 [0.704, 2.704]。</li><li>这个范围决定了 <code>scale</code> 函数的缩放系数，影响了 <code>st</code> 坐标的伸缩。当你增大 <code>1.704</code>，实际上是在增加最小缩放系数的基线，使动画变得不那么剧烈。</li></ul><ol><li><strong>视觉效果</strong> ：</li></ol><ul><li>当 <code>1.704</code> 增大时，缩放变化的幅度减少，<strong>因为 <code>sin(u_time)</code> 的变动被一个较大的常数稳定了。这导致视觉效果的动态变化较少，从而效果不那么明显</strong>。</li></ul><ol><li><strong>周期性变化</strong> ：</li></ol><ul><li><code>sin</code> 函数是周期性的，其变化对整个场景的动态变化至关重要。增大 <code>1.704</code> 的值降低了 <code>sin</code> 函数变化对整体缩放的影响，从而使得效果变化不那么显著。</li></ul><p>st &#x3D; scale( vec2(-0.1) ) * st;和st &#x3D; scale( vec2(0.1) ) * st;的十字效果是一样的，背景效果翻转了(左正右负)；st &#x3D; scale( vec2(0.) ) * st; 这个时候页面全白；</p><p>所以缩放调整数字大于1或小于-1之下，都是小幅度的缩放；</p></blockquote><p><img src="https://s2.loli.net/2024/08/28/dw31YJQyHomFI8A.png" alt="image.png"></p><p>颜色空间RGB和YUV</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">// YUV to RGB matrix</span><br><span class="line">mat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,</span><br><span class="line">                    1.0, -0.39465, -0.58060,</span><br><span class="line">                    1.0, 2.03211, 0.0);</span><br><span class="line"></span><br><span class="line">// RGB to YUV matrix</span><br><span class="line">mat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722,</span><br><span class="line">                    -0.09991, -0.33609, 0.43600,</span><br><span class="line">                    0.615, -0.5586, -0.05639);</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // UV values goes from -1 to 1</span><br><span class="line">    // So we need to remap st (0.0 to 1.0)</span><br><span class="line">    st -= 0.5;  // becomes -0.5 to 0.5</span><br><span class="line">    st *= 2.0;  // becomes -1.0 to 1.0</span><br><span class="line"></span><br><span class="line">    // we pass st as the y &amp; z values of</span><br><span class="line">    // a three dimensional vector to be</span><br><span class="line">    // properly multiply by a 3x3 matrix</span><br><span class="line">    color = yuv2rgb * vec3(0., st.x, st.y);</span><br><span class="line">    //color = rgb2yuv * vec3(0., st.x, st.y);</span><br><span class="line">  </span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/28/gLFMGhyQDfzAo2k.png" alt="image.png"></p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p><a href="https://www.pinterest.com/patriciogonzv/hud-fui/">790 HUD &amp; FUI ideas | head up display, user interface, interface design (pinterest.com)</a></p><p><a href="https://www.shadertoy.com/view/4s2SRt">Oblivion radar (shadertoy.com)</a></p><p><a href="https://lygia.xyz/space">LYGIA Shader Library</a></p><p><a href="https://patriciogonzalezvivo.com/">Patricio Gonzalez Vivo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/08/28/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%951/"/>
    <id>https://youxt-njnu.github.io/2024/08/28/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%951/</id>
    <published>2024-08-28T03:12:05.000Z</published>
    <updated>2024-10-05T12:02:36.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h1><p>react+vite+three.js+scss</p><p>目录：</p><p>EarthDigital</p><p>–images</p><p>—-earth.jpg</p><p>–index.jsx</p><p>–index.scss</p><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>先导入些基本的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Three</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">OrbitControls</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/controls/OrbitControls&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mergeGeometries &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/utils/BufferGeometryUtils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> earthImg <span class="keyword">from</span> <span class="string">&#x27;/src/assets/3d/EarthDigital/images/earth.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure><p>把项目架子搭起来：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">index</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;earth-digital&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">&#123;canvasRef&#125;</span> <span class="attr">className</span>=<span class="string">&quot;webgl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&quot;hud-header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">aside</span> <span class="attr">className</span>=<span class="string">&quot;hud-aside-left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">aside</span> <span class="attr">className</span>=<span class="string">&quot;hud-aside-right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">footer</span> <span class="attr">className</span>=<span class="string">&quot;hud-footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;background&quot;</span>&gt;</span>section<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> index</span><br></pre></td></tr></table></figure><p>一些前置变量和常规函数：—— initThree(), animate(), handleResize()</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scene = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> camera = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> renderer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> orbitControls = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> earth = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> canvasRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">initThree</span>();</span><br><span class="line">  <span class="title function_">animate</span>();</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>场景初始化：—— scene, camera, renderer, orbitControls</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initThree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  scene = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Scene</span>();</span><br><span class="line">  camera = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">45</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">50</span>);</span><br><span class="line">  camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15.5</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(camera);</span><br><span class="line"></span><br><span class="line">  renderer = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">WebGLRenderer</span>(&#123;</span><br><span class="line">    <span class="attr">canvas</span>: canvasRef.<span class="property">current</span>,</span><br><span class="line">    <span class="attr">antialias</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">alpha</span>: <span class="literal">true</span> <span class="comment">// transparent background</span></span><br><span class="line">  &#125;);</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  renderer.<span class="title function_">setPixelRatio</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>, <span class="number">2</span>));</span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line"></span><br><span class="line">  orbitControls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, renderer.<span class="property">domElement</span>);</span><br><span class="line">  orbitControls.<span class="property">enableDamping</span> = <span class="literal">true</span>;</span><br><span class="line">  orbitControls.<span class="property">enablePan</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上动画：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 更新tween</span></span><br><span class="line">  <span class="comment">// TWEEN.update();</span></span><br><span class="line">  <span class="comment">// 模型动画</span></span><br><span class="line">  <span class="comment">// earth.rotation.y += 0.001;</span></span><br><span class="line">  renderer &amp;&amp; scene &amp;&amp; camera &amp;&amp; renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上窗体适应：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>();</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大地球模型"><a href="#大地球模型" class="headerlink" title="大地球模型"></a>大地球模型</h1><p>加入个函数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">initThree</span>();</span><br><span class="line">  <span class="title function_">createPoints</span>();</span><br><span class="line">  <span class="title function_">animate</span>();</span><br><span class="line"> ......</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="球体上的点"><a href="#球体上的点" class="headerlink" title="球体上的点"></a>球体上的点</h2><p>添加前置变量：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="title function_">createPoints</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> rad = <span class="number">5</span>; <span class="comment">// 球体半径</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">75000</span>; <span class="comment">// 球体上的点数量</span></span><br><span class="line">    <span class="keyword">let</span> dlong = <span class="title class_">Math</span>.<span class="property">PI</span> * (<span class="number">3</span> - <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">5</span>)); <span class="comment">// 经度的增量</span></span><br><span class="line">    <span class="keyword">let</span> dz = <span class="number">2</span> / counter; <span class="comment">// 纬度的增量，也就是z轴的增量</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="number">1</span>- dz / <span class="number">2</span>; <span class="comment">// 初始z值</span></span><br><span class="line">    <span class="keyword">let</span> long = <span class="number">0</span>; <span class="comment">// 初始经度</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span>; <span class="comment">// xy平面上的径向半径，类似于x^2+y^2=r^2(勾股三角),r^2+z^2=1(球半径，先1，后缩放至rad)</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">// 用于存xyz的坐标</span></span><br><span class="line">    <span class="keyword">let</span> sph = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Spherical</span>(); <span class="comment">// 构建把上面的转换成球体坐标</span></span><br><span class="line">    <span class="keyword">let</span> dummyObj = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Object3D</span>(); <span class="comment">// 用于调整后续球面上plane的位置和朝向</span></span><br><span class="line">    <span class="keyword">let</span> geoms = []; <span class="comment">// 存储所有的plane</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> earthTexture = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(earthImg);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>为啥设置经度增量为上式子？</p><blockquote><p>经度增量设置为 <code>Math.PI * (3 - Math.sqrt(5))</code> 实际上是基于黄金角，这种方法常用于在球面上分布点以达到尽可能均匀的覆盖。这个值与黄金分割有关，具体如下：</p><ul><li><strong>黄金分割数</strong> (φ) 约为 1.618033988749895。</li><li>但在这里使用的是 <code>3 - Math.sqrt(5)</code>，计算结果大约为 0.7639320225002102，它是黄金分割数的一种数学转换，更具体地说，这个值实际上等于 ( 2 - \phi )。</li><li>当你将这个值乘以 (\pi) （圆周率），得到的角度是通过黄金分割原理计算得来的。这个角度有助于在球面上均匀地分布点，因为它避免了经纬线的对齐，从而在视觉上看起来更为均匀。</li></ul><p>黄金角是黄金分割数在圆上的应用。在自然界中，例如向日葵的种子排列、松果的鳞片布局等，都可以见到黄金角的应用。它能够优化空间利用率并减少重叠，因此在算法生成均匀分布的点时也经常使用这一角度。</p><p>在球面分布点时使用黄金角可以避免聚类并尽可能覆盖整个球面。这样的排列减少了任何给定区域内点过多聚集的情况，从而使点的分布更加均匀，这对于很多涉及到空间分布优化的领域，如计算机图形学、地理信息系统等是非常有用的。</p></blockquote><p>为什么z的初始值设置为这个let z &#x3D; 1 - dz &#x2F; 2;，而不是从0开始</p><blockquote><p>在构建球面分布时，将 <code>z</code> 的初始值设置为 <code>1 - dz / 2</code> 而不是从 0 开始的原因是为了确保点均匀覆盖整个球体，包括顶部和底部。具体原因包括：</p><p>避免极点的聚集</p><ul><li>球体的顶部和底部（即极点）是特殊的位置，如果从 z &#x3D; 0 或 z &#x3D; 1 开始，可能会在这些极点处导致点过度聚集或分布不均。</li><li>通过将 <code>z</code> 的初始值设置为 <code>1 - dz / 2</code>，相当于在 z 轴上对点的位置进行了微小的偏移，使得第一个点和最后一个点都不会精确地位于球体的极点上，而是稍微偏离中心。这有助于改善球面上点的分布均匀性。</li></ul><p>确保覆盖全球</p><ul><li>由于 <code>dz = 2 / counter</code>，这意味着 z 值将从 1 开始，逐渐递减至 -1，覆盖整个球体。</li><li>初始值 <code>1 - dz / 2</code> 实际上将第一个点的 z 值设置为接近 1，但略低于 1，确保点从球体的顶部开始，同时不会与球顶重合。</li></ul><p>均匀分布</p><ul><li>此方法确保了点在垂直方向上也是均匀分布的。通过从 <code>1 - dz / 2</code> 开始，每个点的 z 值都是均匀地在 z 轴上偏移的，从而避免了在接近极点区域的不均匀密度。</li></ul></blockquote><p>➡️ 后话1 ☕️</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxImpactAmount = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> impacts = [];</span><br><span class="line"><span class="comment">// let trails = [];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxImpactAmount; i++) &#123;</span><br><span class="line">  impacts.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">impactPosition</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>),</span><br><span class="line">    <span class="attr">impactMaxRadius</span>: <span class="number">5</span> * <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloat</span>(<span class="number">0.5</span>, <span class="number">0.75</span>), <span class="comment">// Three.Math.randFloat会报错</span></span><br><span class="line">    <span class="attr">impactRatio</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">prevPosition</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>),</span><br><span class="line">    <span class="attr">trailRatio</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    <span class="attr">trailLength</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// makeTrail(i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➡️ 后话2 ☕️</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> params = &#123;</span><br><span class="line">  <span class="attr">colors</span>: &#123;<span class="attr">base</span>: <span class="string">&#x27;#f9f002&#x27;</span>, <span class="attr">gradInner</span>: <span class="string">&#x27;#8ae66e&#x27;</span>, <span class="attr">gradOuter</span>: <span class="string">&#x27;#03c03c&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">reset</span>: <span class="function">()=&gt;</span> &#123; orbitControls.<span class="title function_">reset</span>() &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uniforms = &#123;</span><br><span class="line">  <span class="attr">impacts</span>: &#123;<span class="attr">value</span>: impacts&#125;,</span><br><span class="line">  <span class="attr">maxSize</span>: &#123;<span class="attr">value</span>: <span class="number">.04</span>&#125;, <span class="comment">// 陆地色块大小</span></span><br><span class="line">  <span class="attr">minSize</span>: &#123; <span class="attr">value</span>: <span class="number">.025</span>&#125;, <span class="comment">// 海洋色块大小</span></span><br><span class="line">  <span class="attr">waveHeight</span>: &#123;<span class="attr">value</span>: <span class="number">.1</span>&#125;, <span class="comment">// 冲击波高度</span></span><br><span class="line">  <span class="attr">scaling</span>: &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, <span class="comment">// 冲击波范围</span></span><br><span class="line">  <span class="attr">gradInner</span>: &#123; <span class="attr">value</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">gradInner</span>)&#125;, <span class="comment">// 冲击波径向渐变内侧颜色</span></span><br><span class="line">  <span class="attr">gradOuter</span>: &#123; <span class="attr">value</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">gradOuter</span>)&#125;, <span class="comment">// 冲击波径向渐变外侧颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造点：</p><ol><li>根据z的不同，得到r，再求得three坐标系下（）的三维坐标p，转成球体phi和theta的坐标sph;</li><li>修改long和z，保存p的朝向和模型矩阵；</li><li>利用plane构造球面上的点，通过新建、变换、设置中心点和uv坐标实现</li><li>plane里传入了两个属性：center(每个点对应的位置), uv(这个点的球面坐标，缩放到0-1范围内)</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;counter;i++) &#123;</span><br><span class="line">  r = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">  p.<span class="title function_">set</span>(r * <span class="title class_">Math</span>.<span class="title function_">cos</span>(long), z, -r * <span class="title class_">Math</span>.<span class="title function_">sin</span>(long)).<span class="title function_">multiplyScalar</span>(rad);</span><br><span class="line">  sph.<span class="title function_">setFromVector3</span>(p);</span><br><span class="line">  long = long + dlong;</span><br><span class="line">  z = z - dz;</span><br><span class="line">  dummyObj.<span class="title function_">lookAt</span>(p);</span><br><span class="line">  dummyObj.<span class="title function_">updateMatrix</span>();</span><br><span class="line">  <span class="comment">// 构建球面上的plane，同时设置uv坐标</span></span><br><span class="line">  <span class="keyword">let</span> plane = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  plane.<span class="title function_">applyMatrix4</span>(dummyObj.<span class="property">matrix</span>);</span><br><span class="line">  plane.<span class="title function_">translate</span>(p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>);</span><br><span class="line">  <span class="keyword">let</span> centers = [p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>];</span><br><span class="line">  plane.<span class="title function_">setAttribute</span>(<span class="string">&#x27;center&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferAttribute</span>(<span class="keyword">new</span> <span class="title class_">Float32Array</span>(centers), <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">let</span> uv = [(sph+<span class="title class_">Math</span>.<span class="property">PI</span>)/(<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>),<span class="number">1</span>-(sph.<span class="property">theta</span>/<span class="title class_">Math</span>.<span class="property">PI</span>)];</span><br><span class="line">  <span class="keyword">let</span> uvs = [uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>];</span><br><span class="line">  plane.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baseUv&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferAttribute</span>(<span class="keyword">new</span> <span class="title class_">Float32Array</span>(uvs), <span class="number">2</span>));</span><br><span class="line">  geoms.<span class="title function_">push</span>(plane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="球材质和构造"><a href="#球材质和构造" class="headerlink" title="球材质和构造"></a>球材质和构造</h2><p>构造Mesh</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> g = <span class="title function_">mergeGeometries</span>(geoms);</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">base</span>),</span><br><span class="line">    <span class="attr">onBeforeCompile</span>: <span class="function"><span class="params">shader</span> =&gt;</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  m.<span class="property">defines</span> = &#123;<span class="string">&#x27;USE_UV&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">  earth = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Mesh</span>(g, m);</span><br><span class="line">  earth.<span class="property">rotation</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">  <span class="comment">// trails.forEach( t =&gt; earth.add(t));</span></span><br><span class="line">  earth.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, -<span class="number">0.4</span>, <span class="number">0</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(earth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>球体材质</p><p>基本量</p><ul><li><strong><code>struct impact</code></strong>: 定义了一个包含冲击点数据的结构，包括冲击的位置(<code>impactPosition</code>)、冲击的最大半径(<code>impactMaxRadius</code>)和冲击比例(<code>impactRatio</code>)。</li><li><strong><code>uniform impact impacts[]</code></strong>: 一个包含多个冲击点的数组。</li><li><strong><code>uniform sampler2D tex</code></strong>: 一个二维纹理，通常用于存储和检索数据（比如图像或者根据纹理生成的数据）。</li><li><strong><code>uniform float maxSize, minSize</code></strong>: 最大和最小尺寸。</li><li><strong><code>uniform float waveHeight</code></strong>: 波高。</li><li><strong><code>uniform float scaling</code></strong>: 缩放系数。</li><li><strong><code>attribute vec3 center</code></strong>: 顶点的中心位置。</li><li><strong><code>attribute vec2 baseUv</code></strong>: 顶点的基本UV坐标。</li><li><strong><code>varying float vFinalStep</code></strong> 和 <strong><code>varying float vMap</code></strong>: 这些是从顶点着色器传递到片段着色器的变量，用于进一步的渲染计算。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">uniforms</span>.<span class="property">impacts</span> = uniforms.<span class="property">impacts</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">maxSize</span> = uniforms.<span class="property">maxSize</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">minSize</span> = uniforms.<span class="property">minSize</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">waveHeight</span> = uniforms.<span class="property">waveHeight</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">scaling</span> = uniforms.<span class="property">scaling</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">gradInner</span> = uniforms.<span class="property">gradInner</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">gradOuter</span> = uniforms.<span class="property">gradOuter</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">tex</span> = &#123; <span class="attr">value</span>: earthTexture &#125;;</span><br></pre></td></tr></table></figure><p>顶点着色器逻辑</p><ul><li><strong>循环遍历每个冲击点</strong>：计算每个顶点与每个冲击点的距离，根据距离和冲击点的影响范围计算一个平滑的步进(<code>sstep</code>)。这个步进是基于 <code>smoothstep</code> 函数，用于创建冲击波的边界更加平滑的过渡效果。</li><li><strong><code>finalStep</code>的计算</strong>：累加所有冲击点对当前顶点的影响，使用 <code>clamp</code> 函数确保值在0到1之间。</li><li><strong><code>map</code>变量的计算</strong>：从纹理中获取当前顶点的green值，用于决定顶点的尺寸是 <code>maxSize</code> 还是 <code>minSize</code>，区分了陆地和海洋。</li><li><strong>顶点位置(<code>transformed</code>)的更新</strong>：根据 <code>map</code> 的结果和计算出的 <code>finalStep</code> 调整顶点位置，以实现位置的缩放和波纹效果。使用 <code>mix</code> 函数根据冲击波影响程度在原始尺寸和放大后的尺寸之间进行插值。波高(<code>waveHeight</code>)和 <code>finalStep</code> 的乘积决定了顶点沿法线方向的位移量。</li><li>这段代码通过计算每个顶点与一组冲击波的相对位置和影响，动态调整顶点位置和大小，从而在渲染过程中创建出动态的波纹效果。这种类型的着色器编程允许开发者创建复杂和动态的视觉效果，用于游戏开发、视觉艺术和模拟等领域。</li><li>补充：<code>baseUv</code> 在 Three.js 中是作为每个顶点的二维纹理坐标（<code>vec2</code>）被处理的。这些坐标是作为顶点属性上传到 GPU 的，后续在 GLSL 着色器中可以直接访问。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">vertexShader</span> = <span class="string">`</span></span><br><span class="line"><span class="string">    struct impact &#123;</span></span><br><span class="line"><span class="string">      vec3 impactPosition;</span></span><br><span class="line"><span class="string">      float impactMaxRadius;</span></span><br><span class="line"><span class="string">      float impactRatio;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    uniform impact impacts[<span class="subst">$&#123;maxImpactAmount&#125;</span>];</span></span><br><span class="line"><span class="string">    uniform sampler2D tex;</span></span><br><span class="line"><span class="string">    uniform float maxSize;</span></span><br><span class="line"><span class="string">    uniform float minSize;</span></span><br><span class="line"><span class="string">    uniform float waveHeight;</span></span><br><span class="line"><span class="string">    uniform float scaling;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    attribute vec3 center;</span></span><br><span class="line"><span class="string">    attribute vec2 baseUv;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    varying float vFinalStep;</span></span><br><span class="line"><span class="string">    varying float vMap;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;shader.vertexShader&#125;</span></span></span><br><span class="line"><span class="string">  `</span>.<span class="title function_">replace</span>(</span><br><span class="line">    <span class="string">`#include &lt;begin_vertex&gt;`</span>,</span><br><span class="line">    <span class="string">`#include &lt;begin_vertex&gt;</span></span><br><span class="line"><span class="string">    float finalStep = 0.0;</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; <span class="subst">$&#123;maxImpactAmount&#125;</span>;i++)&#123;</span></span><br><span class="line"><span class="string">      float dist = distance(center, impacts[i].impactPosition);</span></span><br><span class="line"><span class="string">      float curRadius = impacts[i].impactMaxRadius * impacts[i].impactRatio;</span></span><br><span class="line"><span class="string">      float sstep = smoothstep(0., curRadius, dist) - smoothstep(curRadius - ( 0.25 * impacts[i].impactRatio ), curRadius, dist);</span></span><br><span class="line"><span class="string">      sstep *= 1. - impacts[i].impactRatio;</span></span><br><span class="line"><span class="string">      finalStep += sstep;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    finalStep = clamp(finalStep, 0., 1.);</span></span><br><span class="line"><span class="string">    vFinalStep = finalStep;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    float map = texture(tex, baseUv).g;</span></span><br><span class="line"><span class="string">    vMap = map;</span></span><br><span class="line"><span class="string">    float pSize = map &lt; 0.5 ? maxSize : minSize;</span></span><br><span class="line"><span class="string">    float scale = scaling;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    transformed = (position - center) * pSize * mix(1., scale * 1.25, finalStep) + center; // scale on wave</span></span><br><span class="line"><span class="string">    transformed += normal * finalStep * waveHeight; // lift on wave</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>片元着色器逻辑</p><ul><li>传入对逐个点起作用的冲击强度和顶点纹理的g值；</li><li><strong>形状处理</strong> :</li><li>计算以屏幕中心为原点的 UV 坐标 <code>hUv</code>。（vUv是一个从0到1的二维向量，表示纹理坐标或顶点着色器传递给片段着色器的顶点位置）</li><li>N&#x3D;8常用于表示某种图形或模式中重复元素的数量</li><li><code>a</code> 是计算得到的向量 <code>hUv</code>的角度（相对于原点），使用的是反正切函数 <code>atan</code>，它返回从x轴到向量的角度。</li><li><code>r</code> 是每个扇区的角度范围，计算为 <code>2π</code> 除以扇区数量 <code>N</code>。</li><li><code>d</code> 是当前点到最近扇区边界的距离。</li><li><code>f</code> 是扇区中心到边界的距离。</li><li>如果 <code>d</code> 大于 <code>f</code>，则丢弃该片元（<code>discard</code>），只有距离扇区中心非常近的像素才能通过测试，这样可以创建更加锐利和明显的边界；</li><li>这有助于创建具有 N 边形形状的效果。</li><li><strong>颜色和渐变处理</strong>:</li><li><code>grad</code> 是内外渐变颜色的混合，基于 <code>d / f</code> 的值进行插值。</li><li><code>diffuseMap</code> 是根据 <code>vMap</code> 调整的漫反射颜色。 区分了陆地和海洋</li><li><code>col</code> 是漫反射颜色和渐变颜色的最终混合，其中使用了 <code>vFinalStep</code> 进行插值。</li><li>使用最终计算出的颜色 <code>col</code> 和原始的不透明度 <code>opacity</code> 创建新的 <code>vec4 diffuseColor</code>。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">fragmentShader</span> = <span class="string">`</span></span><br><span class="line"><span class="string">            uniform vec3 gradInner;</span></span><br><span class="line"><span class="string">            uniform vec3 gradOuter;</span></span><br><span class="line"><span class="string">            varying float vFinalStep;</span></span><br><span class="line"><span class="string">            varying float vMap;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;shader.fragmentShader&#125;</span></span></span><br><span class="line"><span class="string">            `</span>.<span class="title function_">replace</span>(</span><br><span class="line">            <span class="string">`vec4 diffuseColor = vec4( diffuse, opacity );`</span>,</span><br><span class="line">            <span class="string">`</span></span><br><span class="line"><span class="string">            // shaping the point, pretty much from The Book of Shaders</span></span><br><span class="line"><span class="string">            vec2 hUv = (vUv - 0.5);</span></span><br><span class="line"><span class="string">            int N = 8;</span></span><br><span class="line"><span class="string">            float a = atan(hUv.x,hUv.y);</span></span><br><span class="line"><span class="string">            float r = PI2/float(N);</span></span><br><span class="line"><span class="string">            float d = cos(floor(.5+a/r)*r-a)*length(hUv);</span></span><br><span class="line"><span class="string">            float f = cos(PI / float(N)) * 0.5;</span></span><br><span class="line"><span class="string">            if (d &gt; f) discard;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            vec3 grad = mix(gradInner, gradOuter, clamp( d / f, 0., 1.)); // gradient</span></span><br><span class="line"><span class="string">            vec3 diffuseMap = diffuse * ((vMap &gt; 0.5) ? 0.5 : 1.);</span></span><br><span class="line"><span class="string">            vec3 col = mix(diffuseMap, grad, vFinalStep); // color on wave</span></span><br><span class="line"><span class="string">            //if (!gl_FrontFacing) col *= 0.25; // moderate the color on backside</span></span><br><span class="line"><span class="string">            vec4 diffuseColor = vec4( col , opacity );</span></span><br><span class="line"><span class="string">            `</span>);</span><br></pre></td></tr></table></figure><h3 id="补充-replace方法"><a href="#补充-replace方法" class="headerlink" title="补充 | replace方法"></a>补充 | replace方法</h3><p>上述vertex shader代码replace前：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shader.vertexShader:  #include &lt;common&gt;</span><br><span class="line">#include &lt;batching_pars_vertex&gt;</span><br><span class="line">#include &lt;uv_pars_vertex&gt;</span><br><span class="line">#include &lt;envmap_pars_vertex&gt;</span><br><span class="line">#include &lt;color_pars_vertex&gt;</span><br><span class="line">#include &lt;fog_pars_vertex&gt;</span><br><span class="line">#include &lt;morphtarget_pars_vertex&gt;</span><br><span class="line">#include &lt;skinning_pars_vertex&gt;</span><br><span class="line">#include &lt;logdepthbuf_pars_vertex&gt;</span><br><span class="line">#include &lt;clipping_planes_pars_vertex&gt;</span><br><span class="line">void main() &#123;</span><br><span class="line">#include &lt;uv_vertex&gt;</span><br><span class="line">#include &lt;color_vertex&gt;</span><br><span class="line">#include &lt;morphinstance_vertex&gt;</span><br><span class="line">#include &lt;morphcolor_vertex&gt;</span><br><span class="line">#include &lt;batching_vertex&gt;</span><br><span class="line">#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )</span><br><span class="line">#include &lt;beginnormal_vertex&gt;</span><br><span class="line">#include &lt;morphnormal_vertex&gt;</span><br><span class="line">#include &lt;skinbase_vertex&gt;</span><br><span class="line">#include &lt;skinnormal_vertex&gt;</span><br><span class="line">#include &lt;defaultnormal_vertex&gt;</span><br><span class="line">#endif</span><br><span class="line">#include &lt;begin_vertex&gt;</span><br><span class="line">#include &lt;morphtarget_vertex&gt;</span><br><span class="line">#include &lt;skinning_vertex&gt;</span><br><span class="line">#include &lt;project_vertex&gt;</span><br><span class="line">#include &lt;logdepthbuf_vertex&gt;</span><br><span class="line">#include &lt;clipping_planes_vertex&gt;</span><br><span class="line">#include &lt;worldpos_vertex&gt;</span><br><span class="line">#include &lt;envmap_vertex&gt;</span><br><span class="line">#include &lt;fog_vertex&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述fragment shader代码replace前：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">shader.fragmentShader:  <span class="keyword">uniform</span> <span class="type">vec3</span> diffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> opacity;</span><br><span class="line"><span class="meta">#ifndef FLAT_SHADED</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#include &lt;common&gt;</span></span><br><span class="line"><span class="meta">#include &lt;dithering_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;color_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;uv_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;map_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphamap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphatest_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphahash_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;aomap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;lightmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;envmap_common_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;envmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;fog_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;specularmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;logdepthbuf_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;clipping_planes_pars_fragment&gt;</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> diffuseColor = <span class="type">vec4</span>( diffuse, opacity );</span><br><span class="line"><span class="meta">#include &lt;clipping_planes_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;logdepthbuf_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;map_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;color_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphamap_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphatest_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphahash_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;specularmap_fragment&gt;</span></span><br><span class="line">ReflectedLight reflectedLight = ReflectedLight( <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ) );</span><br><span class="line"><span class="meta">#ifdef USE_LIGHTMAP</span></span><br><span class="line"><span class="type">vec4</span> lightMapTexel = <span class="built_in">texture2D</span>( lightMap, vLightMapUv );</span><br><span class="line">reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">reflectedLight.indirectDiffuse += <span class="type">vec3</span>( <span class="number">1.0</span> );</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#include &lt;aomap_fragment&gt;</span></span><br><span class="line">reflectedLight.indirectDiffuse *= diffuseColor.rgb;</span><br><span class="line"><span class="type">vec3</span> outgoingLight = reflectedLight.indirectDiffuse;</span><br><span class="line"><span class="meta">#include &lt;envmap_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;opaque_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;tonemapping_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;colorspace_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;fog_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;premultiplied_alpha_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;dithering_fragment&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 WebGL 或 OpenGL 的着色器编程中，使用 <code>.replace</code> 方法来修改着色器代码是一种常见的技术，尤其是在处理复杂的、可配置的着色器系统时。这种方法提供了灵活性和动态生成或调整着色器代码的能力。这里的 <code>.replace</code> 方法的使用具体有以下几个目的和优点：</p><ol><li><strong>动态内容注入</strong></li></ol><p>通过 <code>.replace</code>，可以根据程序的需求或配置动态地插入特定的代码片段。在着色器中，这种能力特别有用，因为它允许在不改变原始着色器代码文件的基础上，根据不同的渲染需求修改着色器行为。</p><ol start="2"><li><strong>条件编译</strong></li></ol><p>在多个不同的渲染场景下，可能需要着色器表现出不同的行为。使用 <code>.replace</code> 可以根据运行时条件选择性地添加或修改着色器代码，从而实现条件编译的效果。比如，根据对象是否受到特定影响，决定是否启用某些计算。</p><ol start="3"><li><strong>避免硬编码</strong></li></ol><p>硬编码在着色器中是不灵活的，特别是在涉及到循环次数或数组大小等参数时。通过 <code>.replace</code> 方法，开发者可以在着色器代码运行前插入这些值，使着色器代码更加通用和可配置。例如，通过插入 <code>$&#123;maxImpactAmount&#125;</code> 来确定循环的次数，这使得同一份着色器代码可以适应不同数量的冲击点。</p><ol start="4"><li><strong>模块化和代码复用</strong></li></ol><p>在大型项目中，可能需要在多个着色器之间共享或重用代码片段。通过使用 <code>.replace</code> 方法，可以从外部插入共享的代码片段或在多个着色器之间复用代码，提高维护性和一致性。</p><p>在你的示例中，<code>.replace</code> 方法被用来注入计算顶点最终位置的逻辑到一个基本的顶点着色器模板中。这种方式可以使主着色器代码保持相对不变，而特定的计算和行为可以根据需要动态地注入，如处理不同数量的冲击点或应用不同的动态效果。</p><h3 id="补充-define的作用"><a href="#补充-define的作用" class="headerlink" title="补充 | define的作用"></a>补充 | define的作用</h3><p>在 Three.js 中，<code>defines</code> 属性用于自定义着色器的预处理宏。这些宏是着色器代码中的条件编译指令，可以在编译着色器之前进行设置。通过设置这些宏，你可以启用或修改着色器的某些部分，从而调整其行为或性能，而无需改动着色器的主体代码。这为灵活性和重用提供了很好的支持。</p><p>使用场景</p><ol><li><strong>条件编译</strong>：<code>defines</code> 允许你根据需求启用或禁用着色器代码中的特定部分。例如，如果某个特性（如纹理映射）只在特定条件下使用，你可以通过 <code>defines</code> 来控制这一部分代码的编译。</li><li><strong>性能优化</strong>：通过禁用不需要的特性，可以减少着色器的复杂性，从而提高执行效率。例如，如果你知道你的材质不需要处理UV坐标，可以通过设置相应的宏来阻止编译这部分代码。</li></ol><p>在代码中，<code>m.defines = &#123;&#39;USE_UV&#39;: &#39;&#39;&#125;;</code>  这行代码设置了一个名为 <code>USE_UV</code> 的宏，虽然后面紧跟着的是一个空字符串，但它的存在足以让着色器编译器在预处理时认为 <code>USE_UV</code> 被定义了。在着色器代码中，可以使用预处理指令来检查这个宏：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef USE_UV</span></span><br><span class="line">  <span class="comment">// 执行使用 UV 坐标的代码</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="comment">// 执行不使用 UV 坐标的代码</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>通过这种方式，如果 <code>m.defines</code> 包含 <code>USE_UV</code>，则着色器中依赖 UV 坐标的部分会被编译和执行；如果没有定义 <code>USE_UV</code>，则相关代码块不会被执行，从而可能减少计算负担。这种技术非常适合在运行时根据不同的材质属性或图形设置调整着色器行为，是图形编程中一种常见且强大的优化手段。</p><h3 id="补充-内部代码定义的变量"><a href="#补充-内部代码定义的变量" class="headerlink" title="补充 | 内部代码定义的变量"></a>补充 | 内部代码定义的变量</h3><p>在上述提供的 Three.js 的默认着色器代码中，<code>vUv</code> 变量的定义和使用确实存在，但它是通过 Three.js 的标准着色器系统内部的代码片段进行的。这里是具体的分析：</p><p>在顶点着色器代码中，有如下几行代码是关键：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;uv_pars_vertex&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#include &lt;uv_vertex&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>&lt;uv_pars_vertex&gt;</code></strong>: 这个代码片段通常包含了与 UV 相关的参数定义，包括对 <code>vUv</code> 的声明。这个片段的作用是准备所有必要的 UV 相关数据，以便在顶点着色器中使用。</li><li><strong><code>&lt;uv_vertex&gt;</code></strong>: 这个代码片段负责将 UV 数据从顶点属性传递到 <code>vUv</code> 变量中。这通常包括从顶点数据中读取 UV 坐标，并将其赋值给 <code>vUv</code>。</li></ul><p>在片元着色器中，相关的代码片段包括：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;uv_pars_fragment&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><strong><code>&lt;uv_pars_fragment&gt;</code></strong>: 这个代码片段包括对 <code>vUv</code> 的使用，它从顶点着色器传递的数据中接收 UV 坐标。这在处理纹理映射和其他基于 UV 的操作时非常关键。</li></ul><p>在你的代码中，<code>vUv</code> 的处理是通过标准的 Three.js 着色器代码片段间接实现的。这种方法的优点是你无需直接在你的着色器代码中声明和定义 <code>vUv</code>，Three.js 已经在其着色器库中处理了所有这些操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/08/23/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/"/>
    <id>https://youxt-njnu.github.io/2024/08/23/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</id>
    <published>2024-08-23T06:33:26.000Z</published>
    <updated>2024-08-27T06:07:37.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-shapes"><a href="#记录-shapes" class="headerlink" title="记录-shapes"></a>记录-shapes</h1><p>step(float edge, float x)类似于if</p><p>vec3(float * float) 相当于把两个进行and</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniform vec2 u_resolution;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // Each result will return 1.0 (white) or 0.0 (black).</span><br><span class="line">    float left = step(0.1,st.x);   // Similar to ( X greater than 0.1 )</span><br><span class="line">    float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )</span><br><span class="line"></span><br><span class="line">    // The multiplication of left*bottom will be similar to the logical AND.</span><br><span class="line">    color = vec3( left * bottom );</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把使用这两个left, bottom，简化为使用1个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec2 bl = step(vec2(0.1),st)</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // bottom-left</span><br><span class="line">    vec2 bl = step(vec2(0.1),st);</span><br><span class="line">    float pct = bl.x * bl.y;</span><br><span class="line"></span><br><span class="line">    // top-right</span><br><span class="line">    // vec2 tr = step(vec2(0.1),1.0-st);</span><br><span class="line">    // pct *= tr.x * tr.y;</span><br><span class="line"></span><br><span class="line">    color = vec3(pct);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/1IsKBDcLtamyz4v.png" alt="image.png"></p><p>smoothstep()的形状效果：边缘更平缓</p><p>floor()的形状效果：阶梯式</p><p><img src="https://s2.loli.net/2024/08/23/lWRELpChy643jBM.png" alt="image.png"></p><p>绘制圆：</p><ul><li>参考圆规的思路，以st中心点为圆心，判断st范围内的每个点，是否在圆的范围内；—— distance(), sqrt(), length()</li><li>通过step切出来</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line"> <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">float</span> pct = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. The DISTANCE from the pixel to the center</span></span><br><span class="line">    pct = <span class="built_in">distance</span>(st,<span class="type">vec2</span>(<span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. The LENGTH of the vector</span></span><br><span class="line">    <span class="comment">//    from the pixel to the center</span></span><br><span class="line">    <span class="comment">// vec2 toCenter = vec2(0.5)-st;</span></span><br><span class="line">    <span class="comment">// pct = length(toCenter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. The SQUARE ROOT of the vector</span></span><br><span class="line">    <span class="comment">//    from the pixel to the center</span></span><br><span class="line">    <span class="comment">// vec2 tC = vec2(0.5)-st;</span></span><br><span class="line">    <span class="comment">// pct = sqrt(tC.x*tC.x+tC.y*tC.y);</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">float</span> clipRes = <span class="number">1.</span>-<span class="built_in">step</span>(<span class="number">0.5</span>,pct);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(pct);</span><br><span class="line">    <span class="comment">// color = vec3(1.-clipRes*pct);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>( color, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左边是三种方法求距离后的color，右边是加入了step和1.-的使用；</p><p><img src="https://s2.loli.net/2024/08/26/jvztG13xlTeMI7W.png" alt="image.png"></p><p>“distance field”，类似缓冲区；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">  // st.x *= u_resolution.x/u_resolution.y;</span><br><span class="line">  vec3 color = vec3(0.0);</span><br><span class="line">  float d = 0.0;</span><br><span class="line"></span><br><span class="line">  // Remap the space to -1. to 1.</span><br><span class="line">  st = st *2.-1.;</span><br><span class="line"></span><br><span class="line">  // Make the distance field</span><br><span class="line">  d = length( abs(st)-.3 );</span><br><span class="line">  //d = length( min(abs(st)-.3,0.) );</span><br><span class="line">  //d = length( max(abs(st)-.3,0.) );</span><br><span class="line"></span><br><span class="line">  // Visualize the distance field</span><br><span class="line">  gl_FragColor = vec4(vec3(d),1.0);</span><br><span class="line">  // gl_FragColor = vec4(vec3(fract(d*12.216)),1.0); // *的数值越大，d略微变化下呈现的小数部分就更多样</span><br><span class="line"></span><br><span class="line">  // Drawing with the distance field</span><br><span class="line">  gl_FragColor = vec4(vec3( step(.3,d) ),1.0);</span><br><span class="line">  gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);</span><br><span class="line">  gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/27/CZM4AR9LVQlF3e2.png" alt="img"></p><p>不同曲线设置下的形状表现，可以用来做花朵、雪花、齿轮这些。。。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    vec2 pos = vec2(0.5)-st; // -0.5~0.5</span><br><span class="line"></span><br><span class="line">    float r = length(pos)*2.0;</span><br><span class="line">    float a = atan(pos.y,pos.x);</span><br><span class="line"></span><br><span class="line">    float f = cos(a*3.);</span><br><span class="line">    f = abs(cos(a*3.));</span><br><span class="line">   f = abs(cos(a*2.5))*0.236+0.116;</span><br><span class="line">   f = abs(cos(a*12.)*sin(a*3.))*.8+.1;</span><br><span class="line">    f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;</span><br><span class="line"></span><br><span class="line">    //color = vec3(smoothstep(f,f+.01,r));</span><br><span class="line">    color = vec3(1.-smoothstep(f,f+0.01,r) );</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/27/LoCVqmx6WvzeMKh.png" alt="image.png"></p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p>实现下面的效果：</p><p><img src="https://thebookofshaders.com/07/mondrian.jpg" alt="img"></p><p><a href="https://thndl.com/square-shaped-shaders.html">Square shaped shaders | thndl</a></p><p><a href="https://mstdn.thndl.com/@baldand">https://mstdn.thndl.com/@baldand</a></p><p><a href="https://www.mattdesl.com/">https://www.mattdesl.com/</a></p><p>lygia: <a href="https://lygia.xyz/draw">LYGIA Shader Library</a>, <a href="https://lygia.xyz/draw">LYGIA Shader Library sdf函数</a></p><p><a href="https://pixelspiritdeck.com/">像素精神 (pixelspiritdeck.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
    <id>https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</id>
    <published>2024-08-19T03:55:26.000Z</published>
    <updated>2024-08-21T06:18:49.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-color部分"><a href="#记录-color部分" class="headerlink" title="记录-color部分"></a>记录-color部分</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec4 vector;</span><br><span class="line">vector[0] = vector.r = vector.x = vector.s;</span><br><span class="line">vector[1] = vector.g = vector.y = vector.t;</span><br><span class="line">vector[2] = vector.b = vector.z = vector.p;</span><br><span class="line">vector[3] = vector.a = vector.w = vector.q;</span><br></pre></td></tr></table></figure><p>支持swizzle(搅动)：vec3 yellow&#x3D;vec3(1.,1.,0.); yellow.rgb, yellow.rgr, yellow.bgr ……</p><p>利用mix()进行color混合：mix(color1,color2,value) ，value从0到1，value越小color1值越多</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>); <span class="comment">// blue</span></span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>); <span class="comment">// yellow</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct = <span class="built_in">abs</span>(<span class="built_in">sin</span>(u_time)); <span class="comment">// 从0到1，sin(x)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mix uses pct (a value from 0-1) to</span></span><br><span class="line">    <span class="comment">// mix the two colors</span></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="easing-function"><a href="#easing-function" class="headerlink" title="easing function"></a>easing function</h2><p>用于计算动画的缓动函数<a href="https://easings.net/">easing function</a></p><ul><li>下面的式子有些作者进行了sin&#x2F;cos之间的变换，以及命名的风格是sineIn就是上面链接里的easeInSine</li><li>上面网页里，每个函数都有对应的css用法，postcss用法，在元素变换动画里的效果，在颜色渐变混合里的效果，使用该函数进行变换的样例（缩放、移动、透明度变化）,也可以调整参数点击go进行对比</li><li>最后一排：css的实现是通过@keyframes，设置不同的条件；函数里面是通过一系列的判断来赋值；</li><li>前四排的都是<a href="https://cubic-bezier.com/#.25,.1,.25,1">cube-bezier</a>函数设置不同的参数得到的效果</li></ul><blockquote><p>在 CSS 中，<code>cubic-bezier</code> 函数用于定义一个三次贝塞尔曲线，广泛应用于动画和过渡效果的时间函数（timing function）。这个函数的四个参数控制曲线的形状，从而影响动画的速度变化。</p><p>具体来说，<code>cubic-bezier(.12, 0, .33, 0)</code> 中的四个参数表示的是两个控制点的坐标：</p><ul><li>第一个控制点的坐标为 (0.12, 0)</li><li>第二个控制点的坐标为 (0.33, 0)</li></ul><p>这四个参数可以这样解释：</p><ol><li>**第一个参数 (0.12)**：这是第一个控制点的横坐标，它影响动画开始阶段的加速度。值为 0.12 表示在动画开始阶段，速度从零开始缓慢增加。</li><li>**第二个参数 (0)**：这是第一个控制点的纵坐标，它在这里设为 0，意味着控制点位于起始线上，因此动画起始时会比较平缓，没有立即加速。</li><li>**第三个参数 (0.33)**：这是第二个控制点的横坐标，影响动画结束前的减速过程。值较小（0.33）表明动画在结束前不久开始减速。</li><li>**第四个参数 (0)**：这是第二个控制点的纵坐标，同样为 0，意味着结束时速度减到 0，动画结束的过程也是比较平缓的。</li></ol><p>通过调整这些参数，开发者可以精确控制动画的速度曲线，从而创造出各种动画效果。在这个具体例子中，由于两个控制点的纵坐标都是 0，这种曲线通常用于创建某些具有明显起始和结束阶段的动画效果。</p></blockquote><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.141592653589793</span></span><br><span class="line"><span class="meta">#define HALF_PI 1.5707963267948966</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Robert Penner&#x27;s easing functions in GLSL</span></span><br><span class="line"><span class="comment">// https://github.com/stackgl/glsl-easings</span></span><br><span class="line"><span class="type">float</span> linear(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> ? t : <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">1.0</span> ? t : <span class="number">1.0</span> - <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> || t == <span class="number">1.0</span></span><br><span class="line">    ? t</span><br><span class="line">    : t &lt; <span class="number">0.5</span></span><br><span class="line">      ? +<span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, (<span class="number">20.0</span> * t) - <span class="number">10.0</span>)</span><br><span class="line">      : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> - (t * <span class="number">20.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>((t - <span class="number">1.0</span>) * HALF_PI) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(t * HALF_PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-0.5</span> * (<span class="built_in">cos</span>(PI * t) - <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">5.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">16.0</span> * <span class="built_in">pow</span>(t, <span class="number">5.0</span>)</span><br><span class="line">    : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">5.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">3.0</span>) * (<span class="number">1.0</span> - t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">8.0</span> * <span class="built_in">pow</span>(t, <span class="number">4.0</span>)</span><br><span class="line">    : <span class="number">-8.0</span> * <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">4.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> p = <span class="number">2.0</span> * t * t;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span> ? p : -p + (<span class="number">4.0</span> * t) - <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> -t * (t - <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t - <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">return</span> f * f * f + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">4.0</span> * t * t * t</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">3.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">13.0</span> * t * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">-13.0</span> * (t + <span class="number">1.0</span>) * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * <span class="built_in">sin</span>(+<span class="number">13.0</span> * HALF_PI * <span class="number">2.0</span> * t) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">sin</span>(<span class="number">-13.0</span> * HALF_PI * ((<span class="number">2.0</span> * t - <span class="number">1.0</span>) + <span class="number">1.0</span>)) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - t * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="number">2.0</span> - t) * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - <span class="number">4.0</span> * t * t))</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="built_in">sqrt</span>((<span class="number">3.0</span> - <span class="number">2.0</span> * t) * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> a = <span class="number">4.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> b = <span class="number">8.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> c = <span class="number">9.0</span> / <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> ca = <span class="number">4356.0</span> / <span class="number">361.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cb = <span class="number">35442.0</span> / <span class="number">1805.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cc = <span class="number">16061.0</span> / <span class="number">1805.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> t2 = t * t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; a</span><br><span class="line">    ? <span class="number">7.5625</span> * t2</span><br><span class="line">    : t &lt; b</span><br><span class="line">      ? <span class="number">9.075</span> * t2 - <span class="number">9.9</span> * t + <span class="number">3.4</span></span><br><span class="line">      : t &lt; c</span><br><span class="line">        ? ca * t2 - cb * t + cc</span><br><span class="line">        : <span class="number">10.8</span> * t * t - <span class="number">20.52</span> * t + <span class="number">10.72</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t * <span class="number">2.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * bounceOut(t * <span class="number">2.0</span> - <span class="number">1.0</span>) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">3.0</span>) - t * <span class="built_in">sin</span>(t * PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">1.0</span> - t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">2.0</span> * t</span><br><span class="line">    : <span class="number">1.0</span> - (<span class="number">2.0</span> * t - <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> g = <span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * g</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="number">1.0</span> - g) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充说明：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> t = u_time * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间缩放 (<code>t = u_time * 0.5</code>)**：这里 <code>u_time</code> 被乘以 0.5，意味着 <code>t</code> 的变化速度是 <code>u_time</code> 的一半。如果 <code>u_time</code> 是一个随时间增加的变量，那么 <code>t</code> 的增长速度更慢。</li><li>**计算 <code>pct</code>**：<code>fract(t)</code> 获取 <code>t</code> 的小数部分，这样即使 <code>t</code> 增长到 1 以上，<code>fract(t)</code> 也会重新从 0 开始，实现周期性重置。乘以 2.0 然后减 1.0 是为了将周期变化从 <code>[0,1]</code> 调整到 <code>[-1,1]</code>，这样 <code>abs(...)</code> 后的值将在 <code>[0,1]</code> 之间振荡，实现了先增加到 1 然后减少到 0 的周期性变化。</li><li><strong><code>cubicInOut</code> 动画曲线</strong>：这个函数通常定义了一个缓入缓出的三次曲线，意味着动画开始和结束时速度较慢，中间速度较快。</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">t = u_time;</span><br><span class="line">pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间设置 (<code>t = u_time</code>)**：这里没有对 <code>u_time</code> 进行缩放，因此 <code>t</code> 以原始速度增加。</li><li>**计算 <code>pct</code>**：这里仅使用了 <code>fract(t)</code> 减去 1.0，与上面的代码相比，这样处理会产生从 <code>-1</code> 到 0 的周期性变化（因为 <code>fract(t)</code> 产生 <code>[0,1)</code>，减 1 后变为 <code>[-1,0)</code>）。应用 <code>abs(...)</code> 后，变化将在 <code>[0,1)</code> 间发生，实现了周期性的从 0 增加到 1。</li></ol><p>效果差异：</p><ul><li><strong>变化速率</strong>：上面的代码中 <code>t</code> 的变化速度为原始时间的一半，这导致整体动画速度更慢。</li><li><strong>振荡方式</strong>：上面的代码使得振荡从 0 增加到 1 然后减少到 0，形成一个完整的循环，而下面的代码只从 0 增加到 1。</li></ul><p>结合这些分析，上面的代码提供了一个更平滑和对称的振荡模式，适用于需要循环动画效果的场景，如呼吸灯效果。下面的代码则更适合于单向的渐进或渐出效果，如日出效果。</p><h2 id="颜色的渐变"><a href="#颜色的渐变" class="headerlink" title="颜色的渐变"></a>颜色的渐变</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">void main() &#123;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"> vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    float pct = cubicInOut(st.y); </span><br><span class="line">    pct = circularInOut(st.y); // 因为InOut那边的曲线是在很小范围内的自变量下发生了较大的因变量变化，所以分界线会明显，相对上面的来说</span><br><span class="line">    // Mix uses pct (a value from 0-1) to</span><br><span class="line">    // mix the two colors</span><br><span class="line">    color = mix(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/OmhPTZGRKIo1rfN.png"></p><h2 id="mix对RGB三个通道的控制"><a href="#mix对RGB三个通道的控制" class="headerlink" title="mix对RGB三个通道的控制"></a>mix对RGB三个通道的控制</h2><p>可以分别设置RGB三通道的混合方式</p><p><img src="https://thebookofshaders.com/06/mix-vec.jpg" alt="img"></p><p>示例</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> plot (<span class="type">vec2</span> st, <span class="type">float</span> pct)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">smoothstep</span>( pct<span class="number">-0.01</span>, pct, st.y) -</span><br><span class="line">          <span class="built_in">smoothstep</span>( pct, pct+<span class="number">0.01</span>, st.y); <span class="comment">// smoothstep(a-极小值,a,纹理坐标)-smoothstep(a,a+极小值,纹理坐标)，可以画出a的曲线（也就是代码里的pct）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> pct = <span class="type">vec3</span>(st.x);</span><br><span class="line"></span><br><span class="line">    pct.r = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,<span class="number">1.0</span>, st.x);</span><br><span class="line">    pct.g = <span class="built_in">sin</span>(st.x*PI);</span><br><span class="line">    pct.b = <span class="built_in">pow</span>(st.x,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Plot transition lines for each channel</span></span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.r));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.g));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.b));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/NtLrd5aD4mFjuSX.png"></p><p>混合加变换的组合</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="built_in">mix</span>(color1,color2,st.y);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="built_in">mix</span>(color1,color2,<span class="number">1.</span>-st.y*st.x);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*2WK3NdpR_Oxt0QKN8r6Rgg.gif" alt="img"></p><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><blockquote><p>shadertoy代码：</p><p><a href="https://www.shadertoy.com/view/MsS3Wc">Smooth HSV (shadertoy.com)</a></p><p><a href="https://blog.csdn.net/ColdWindHA/article/details/82080176">OpenCV学习笔记——HSV颜色空间超极详解&amp;inRange函数用法及实战_hsv值是什么-CSDN博客</a></p><p><a href="https://www.cnblogs.com/dablyo/p/6854947.html">HSV色彩空间和颜色分量范围 - 友善的狗W - 博客园 (cnblogs.com)</a></p></blockquote><p><img src="https://s2.loli.net/2024/08/21/AleHoLjbR9I67Su.png" alt="image.png"></p><p>RGB和HSV的互转</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> rgb2hsb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> p = <span class="built_in">mix</span>(<span class="type">vec4</span>(c.bg, K.wz),</span><br><span class="line">                 <span class="type">vec4</span>(c.gb, K.xy),</span><br><span class="line">                 <span class="built_in">step</span>(c.b, c.g));</span><br><span class="line">    <span class="type">vec4</span> q = <span class="built_in">mix</span>(<span class="type">vec4</span>(p.xyw, c.r),</span><br><span class="line">                 <span class="type">vec4</span>(c.r, p.yzx),</span><br><span class="line">                 <span class="built_in">step</span>(p.x, c.r));</span><br><span class="line">    <span class="type">float</span> d = q.x - <span class="built_in">min</span>(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)),</span><br><span class="line">                d / (q.x + e),</span><br><span class="line">                q.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Function from Iñigo Quiles</span></span><br><span class="line"><span class="comment">//  https://www.shadertoy.com/view/MsS3Wc</span></span><br><span class="line"><span class="type">vec3</span> hsb2rgb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec3</span> rgb = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(c.x*<span class="number">6.0</span>+<span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">4.0</span>,<span class="number">2.0</span>),</span><br><span class="line">                             <span class="number">6.0</span>)<span class="number">-3.0</span>)<span class="number">-1.0</span>,</span><br><span class="line">                     <span class="number">0.0</span>,</span><br><span class="line">                     <span class="number">1.0</span> );</span><br><span class="line">    rgb = rgb*rgb*(<span class="number">3.0</span><span class="number">-2.0</span>*rgb);</span><br><span class="line">    <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">1.0</span>), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We map x (0.0 - 1.0) to the hue (0.0 - 1.0)</span></span><br><span class="line">    <span class="comment">// And the y (0.0 - 1.0) to the brightness</span></span><br><span class="line">    color = hsb2rgb(<span class="type">vec3</span>(st.x,<span class="number">1.0</span>,st.y)); <span class="comment">// 传入的体现了h,s,b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/8ZdlghIPOemGJwt.png" alt="image.png"></p><p>HSB从笛卡尔坐标映射到极坐标：</p><ul><li>获取角度和到屏幕中心点的距离</li><li>使用length()和atan(y,x)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define TWO_PI 6.28318530718</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">//  Function from Iñigo Quiles</span><br><span class="line">//  https://www.shadertoy.com/view/MsS3Wc</span><br><span class="line">vec3 hsb2rgb( in vec3 c )&#123;</span><br><span class="line">    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),</span><br><span class="line">                             6.0)-3.0)-1.0,</span><br><span class="line">                     0.0,</span><br><span class="line">                     1.0 );</span><br><span class="line">    rgb = rgb*rgb*(3.0-2.0*rgb);</span><br><span class="line">    return c.z * mix( vec3(1.0), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // Use polar coordinates instead of cartesian</span><br><span class="line">    vec2 toCenter = vec2(0.5)-st; // 把纹理坐标空间移到-.5到.5</span><br><span class="line">    float angle = atan(toCenter.y,toCenter.x); // 求每个点相对于中心点的角度</span><br><span class="line">    float radius = length(toCenter)*2.0; // 长度的范围是0~1</span><br><span class="line"></span><br><span class="line">    // Map the angle (-PI to PI) to the Hue (from 0 to 1)</span><br><span class="line">    // and the Saturation to the radius</span><br><span class="line">    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0)); // 第一个表示h，根据相对于中心点的角度来赋予颜色，同时缩放到了0-1，然后传入；radius: 离中心点越远，radius越大，s值越大;</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/fTMw6RpQmVY3JWH.png" alt="image.png"></p><p><code>var toCenter = st - vec2(0.5);</code></p><p>这样子，把上述的图旋转180度的效果；</p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p>结合shaping function，呈现不同的颜色过渡；</p><p><img src="https://thebookofshaders.com/06/spectrums.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</id>
    <published>2024-08-16T07:52:26.000Z</published>
    <updated>2024-08-19T05:51:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><p><a href="https://thebookofshaders.com/edit.php">GLSL Editor (thebookofshaders.com)</a> 在线的shader编辑调试</p><p><a href="https://github.com/patriciogonzalezvivo/glslGallery">patriciogonzalezvivo&#x2F;glslGallery (github.com)</a> 看着不错，但是提交自己的上去后，提交不到对应的服务器（直白些就是俺试完了用不了。。。。。</p><p><a href="https://patriciogonzalezvivo.github.io/glslGallery/">GLSL Gallery (patriciogonzalezvivo.github.io)</a> 作者的一些shader，可以借鉴学习</p><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><h2 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h2><p>GPU特点：blind（不知道其他的pipe&#x2F;thread在干啥），memoryless（不知道以前干了啥）</p><p>片元着色器：</p><ul><li>void main() {} 主函数</li><li>内置全局变量，如gl_FragColor</li><li>默认输出：gl_fragColor</li><li>默认输入：gl_fragCoord  (是varing)     &#x2F;&#x2F;    x,y都从0到1</li><li>数据类型，vec4，精度如float</li><li>标准化normalized, 映射map</li><li>宏，#defines, #ifdef, #endif, #ifndef</li><li>注意，对于浮点的数字最好养成加上.的习惯</li></ul><p>uniform:</p><ul><li>cpu给gpu的</li><li>一些所有thread都一样的，不会变的值</li></ul><p>支持内置数学函数，如sin()</p><h2 id="shaping-functions"><a href="#shaping-functions" class="headerlink" title="shaping functions"></a>shaping functions</h2><h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p>The <a href="https://thebookofshaders.com/glossary/?search=step"><code>step()</code></a> interpolation receives two parameters.</p><p>The first one is the limit or threshold, while the second one is the value we want to check or pass.</p><p>Any value under the limit will return <code>0.0</code> while everything above the limit will return <code>1.0</code>.</p><h3 id="smoothstep"><a href="#smoothstep" class="headerlink" title="smoothstep"></a>smoothstep</h3><p><a href="https://blog.csdn.net/weixin_61427881/article/details/127839417">【Shader Graph】SmoothStep节点详解及其应用-CSDN博客</a></p><h3 id="sin-x2F-cos"><a href="#sin-x2F-cos" class="headerlink" title="sin&#x2F;cos"></a>sin&#x2F;cos</h3><p>加上u_time: 实现沿x轴的移动</p><p>乘上PI类似的：实现曲线的收缩</p><p>加上值：实现曲线上下移动</p><p>外面乘上值：实现曲线拉伸</p><p>取绝对值abs()：弹跳球轨迹</p><p>取小数部分fract()</p><p>取上下整数ceil(), floor()</p><p>y &#x3D; mod(x,0.5); &#x2F;&#x2F; return x modulo of 0.5<br>y &#x3D; fract(x); &#x2F;&#x2F; return only the fraction part of a number<br>y &#x3D; ceil(x);  &#x2F;&#x2F; nearest integer that is greater than or equal to x<br>y &#x3D; floor(x); &#x2F;&#x2F; nearest integer less than or equal to x<br>y &#x3D; sign(x);  &#x2F;&#x2F; extract the sign of x<br>y &#x3D; abs(x);   &#x2F;&#x2F; return the absolute value of x<br>y &#x3D; clamp(x,0.0,1.0); &#x2F;&#x2F; constrain x to lie between 0.0 and 1.0<br>y &#x3D; min(0.0,x);   &#x2F;&#x2F; return the lesser of x and 0.0<br>y &#x3D; max(0.0,x);   &#x2F;&#x2F; return the greater of x and 0.0</p><p>搜索关键词：generative art</p><blockquote><p><a href="https://aiartists.org/generative-art-design">Generative Art: 50 Best Examples, Tools &amp; Artists (2021 GUIDE) — AIArtists.org</a></p></blockquote><h1 id="几个shader"><a href="#几个shader" class="headerlink" title="几个shader"></a>几个shader</h1><h2 id="鼠标坐标"><a href="#鼠标坐标" class="headerlink" title="鼠标坐标"></a><strong>鼠标坐标</strong></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03 code2</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution; <span class="comment">// 屏幕 宽，高</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">   <span class="type">vec2</span> mousePos;</span><br><span class="line"><span class="comment">// vec2 st = gl_FragCoord.xy/u_resolution; // 把输入纹理坐标缩放到0~1</span></span><br><span class="line"><span class="comment">// gl_FragColor = vec4(st.x,st.y,0.0,1.0);</span></span><br><span class="line"><span class="type">vec2</span> center = u_resolution/<span class="number">2.</span>; <span class="comment">// 获取中心点的屏幕坐标</span></span><br><span class="line">   mousePos = (u_mouse.xy-center)/center; <span class="comment">// 把鼠标位置缩放到-1~1</span></span><br><span class="line">   mousePos = mousePos*<span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// 把鼠标位置缩放到0~1</span></span><br><span class="line">   <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(mousePos.x,mousePos.y,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷油漆"><a href="#刷油漆" class="headerlink" title="刷油漆"></a><strong>刷油漆</strong></h2><ul><li>获取从0到1空间坐标</li><li>做出0到1渐变灰</li><li>制造函数和对应区间</li><li>把函数涂上颜色</li></ul><p><img src="https://s2.loli.net/2024/08/16/p9GByiLT3MqlPCS.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05 code1</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值区间：</span></span><br><span class="line"><span class="comment">// abs(y-x)===0, return 1</span></span><br><span class="line"><span class="comment">// abs(y-x) 0~0.02, return abs(y-x)</span></span><br><span class="line"><span class="comment">// abs(y-x) &gt;0.02, return 0</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.02</span>,<span class="number">0.0</span>,<span class="built_in">abs</span>(st.y-st.x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"> <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">float</span> y = st.x;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line">    <span class="comment">// 每个点只有x起作用，所以x一样的，显示的颜色是一样的；</span></span><br><span class="line">    <span class="comment">// color由三个x组成，所以是灰度，而且渐变大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> line = plot(st);</span><br><span class="line">    <span class="comment">// color = line*vec3(.0,1.,.0); // 绘制出了绿色的线</span></span><br><span class="line">    <span class="comment">// color = (1.-line)*color; // 把线的地方扣成黑色，方便后续加色</span></span><br><span class="line">    <span class="comment">// 分割出线，加上背景</span></span><br><span class="line">    color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"> <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><p>st: 基于屏幕的纹理坐标</p><p>y: 和st有关系的函数</p><p>color: 展示y的灰度颜色</p><p>line: 通过st和y绘制的样条函数。。</p><p>color: 给line函数进行叠加显示</p><p><img src="https://s2.loli.net/2024/08/16/Qoudz1HApWlqJUK.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较st的x^5, 0, y的关系</span></span><br><span class="line"><span class="comment">// y&lt;x^5的，都0</span></span><br><span class="line"><span class="comment">// y在0~x^5，都原值</span></span><br><span class="line"><span class="comment">// y=0的，都1</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y,<span class="number">0.0</span>,st.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line"><span class="type">float</span> y = <span class="built_in">pow</span>(st.x,<span class="number">5.</span>);</span><br><span class="line"><span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line"><span class="type">float</span> line = plot(st,y);</span><br><span class="line">color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取个反再锐化下</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.02</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/z6xAHaYDJFeQ7ct.png" alt="image.png"></p><p>求个交集</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.03</span>,y,st.y)-<span class="built_in">smoothstep</span>(y<span class="number">-0.01</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/O4LcxMDmrB2toTP.png" alt="image.png"></p><p>更自然些的交集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float plot(vec2 st,float y) &#123;</span><br><span class="line">    return smoothstep(y-0.03,y,st.y)-smoothstep(y,y+0.03,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/Ze68o1mKhicjrbW.png" alt="image.png"></p><p>step需要分片来看：</p><ul><li>step(): 左片(&lt;0.5), 右片(&gt;0.5) -&gt;y,也就是传进polt的pct</li><li>smoothstep: 左片，所有纹理点都是1</li><li>smoothstep: 右片，纹理点的分割按照(1-0.02, 1, st.y)进行，下0，中原值，上1</li></ul><p><img src="https://s2.loli.net/2024/08/17/sel5gGTcNRP2iJq.png" alt="image.png"></p><h1 id="可能的bug"><a href="#可能的bug" class="headerlink" title="可能的bug"></a>可能的bug</h1><p><strong>没定义精度</strong> <code>No precision specified for (float)</code></p><blockquote><p>presion mediump floa<strong>t;</strong></p></blockquote><p><strong>fragment shader做完了不显示颜色：</strong></p><blockquote><p>没给gl_FragColor赋值</p></blockquote><p><strong>没找到函数</strong> <code>&#39;setColor&#39; : no matching overloaded function found</code></p><blockquote><p>C里面把函数写在void main()前面，或者需提前声明</p></blockquote><h1 id="推荐待更新"><a href="#推荐待更新" class="headerlink" title="推荐待更新"></a>推荐待更新</h1><blockquote><p>准备先过一遍教程再说….</p></blockquote><p><a href="https://www.flong.com/">Flong.com • Golan Levin &amp; Collaborators 的作品</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_poly/">Polynomial Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_exp/">Exponential Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_circ/index.html">Circular &amp; Elliptical Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_bez/">Bezier and Other Parametric Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><hr><p><a href="https://iquilezles.org/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><p><a href="https://iquilezles.org/articles/functions/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><hr><p><img src="https://thebookofshaders.com/05/kynd.png" alt="img"></p><hr><p><a href="https://www.shadertoy.com/view/XsXXDn">Creation by Silexars (shadertoy.com)</a></p><hr><p><a href="https://lygia.xyz/">LYGIA Shader Library</a></p><p><a href="https://graphtoy.com/">Graphtoy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>Cesium API学习 Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/</id>
    <published>2024-06-13T03:06:05.000Z</published>
    <updated>2024-06-13T02:41:45.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h1><p><strong>Cesium官网</strong> <a href="https://cesium.com/">Cesium: The Platform for 3D Geospatial</a></p><p><strong>CesiumJS:</strong><a href="https://cesium.com/learn/cesiumjs-learn/cesiumjs-quickstart/">CesiumJS Quickstart – Cesium</a></p><p><strong>Cesium for Unity:</strong><a href="https://cesium.com/learn/unity/">Cesium for Unity – Cesium</a></p><p><a href="https://zhuanlan.zhihu.com/p/452345666">Hello React Cesium - 知乎 (zhihu.com)</a></p><p><a href="https://cuifeng.blog.csdn.net/article/details/122828984?spm=1001.2014.3001.5502">React集成Cesium+ThreeJs流程汇总_react cesium-CSDN博客</a></p><h1 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h1><p><a href="https://www.cnblogs.com/tiandi/p/16580238.html">Cesium学习资源汇总</a></p><p><a href="https://sandcastle.cesium.com/">cesium官方案例</a></p><p><a href="https://github.com/vtxf/Cesium-Tutorials-Index">Cesium相关资料汇总</a>、<a href="https://zhuanlan.zhihu.com/p/557296232">汇总2</a></p><p><a href="https://pasu.github.io/ExamplesforCesium/examples/examples.html#Primer">cesium项目</a></p><p><a href="https://github.com/hujiulin/CesiumJS-tutorial/tree/master?tab=readme-ov-file">Cesium中文教程-github</a>, <a href="http://cesium.xin/wordpress/archives/16.html">cesium中文网</a></p><hr><p><strong>Cesium源码文件夹</strong><a href="https://sandcastle.cesium.com/">cesium官方案例</a>，<a href="https://cesium.com/learn/cesiumjs/ref-doc/">官方API文档</a></p><h1 id="Cesium基础知识"><a href="#Cesium基础知识" class="headerlink" title="Cesium基础知识"></a>Cesium基础知识</h1><p><a href="https://www.zhihu.com/column/c_1317874447190585344">学习链接</a></p><p><strong>Cesium的项目定位：B&#x2F;S架构下的客户端应用层面的三维开发框架</strong></p><p><img src="https://pic1.zhimg.com/v2-d566ed3f3b0bb0f8be5d099fb2393b10_r.jpg" alt="img"></p><p><strong>Cesium的学习路线：</strong></p><p><img src="https://pic4.zhimg.com/v2-7a32e7833314deff496ff31b5f48809f_r.jpg" alt="img"></p><p><strong>Cesium进阶之路：</strong></p><ul><li><strong>Web前端方向：</strong> Cesium与webpack（裁剪以及压缩），Cesium 与vue（框架设计， 嵌入复杂业务系统），Cesium的UI（UI 设计，定制可复用的Cesium交互界面）</li><li><strong>计算机图形学方向：</strong> WebGL深入，基于Cesium 的可视化定制（视阈、水淹、水面、热力图，流场图、飞线图、扫描图）</li><li><strong>数据预处理方向：</strong> 投影变换，空间索引，LOD ，3dtile 生成，数据存储，数据分发服务，解决超大空间数据如何在 Cesium上流畅可视化的问题。</li></ul><h2 id="Viewer"><a href="#Viewer" class="headerlink" title="Viewer"></a>Viewer</h2><p><img src="https://i.loli.net/2018/08/13/5b70f7cbf3693.jpg" alt="img"></p><p><strong>Cesium ion是一个提供瓦片图和3D地理空间数据的平台，Cesium ion支持把数据添加到用户自己的CesiumJS应用中。下面我们将使用Sentinal-2二维贴图和Cesium世界地形，二者都需要ion的支持。</strong></p><p><strong>备注</strong> 在我们使用Cesium的过程中，如果没有申请ion，同时没有自己的数据源用的cesium提供的数据源，viewer的底部常常会提示一行小的英文字母。大意就是需要申请access token.</p><ol><li><strong>打开</strong><a href="https://cesium.com/ion/">https://cesium.com/ion/</a> 然后注册一个新的账户。</li><li><strong>点击”Access Token”,</strong> 选择<em>Default</em>默认的access token拷贝到contents中。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Ion.defaultAccessToken =</span><br><span class="line">        &#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2NDk3OTUzYy01N2RjLTQyNDMtYTE1Zi0yYjgwNTJlZmYwOTAiLCJpZCI6MTk3MzM4LCJpYXQiOjE3MDg2NTc1NTh9.b8_XHsKZtIQVkUyk95dNvHHB4OE5nmebm5e_JFEIIbM&#x27;</span><br><span class="line">const viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;)</span><br></pre></td></tr></table></figure><p><strong>Viewer的类组织</strong></p><p><img src="https://img2022.cnblogs.com/blog/237138/202208/237138-20220812154924431-1555328076.png" alt="img"></p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul><li><strong>infoBox, 点击后弹出的右上方信息</strong></li><li><strong>selectionIndicator: 点击后在原地出现的绿色指示框</strong></li><li><strong>trackedEntity: Gets or sets the Entity instance currently being tracked by the camera.</strong></li><li><strong>orderIndependentTranslucency:</strong></li></ul><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li><strong>屏幕坐标，即二维笛卡尔平面坐标系</strong></li><li><strong>笛卡尔空间直角坐标&#x2F;世界坐标</strong>（红X，绿Z，蓝Y；X向前，Y向右，Z向上；</li><li><strong>地理坐标（弧度制），Cesium.Cartographic(lon, lat, height)，其中经纬度都是用弧度表示的</strong></li><li><strong>经纬度坐标，默认WGS84坐标系，</strong></li></ul><p><strong>坐标变换：</strong></p><ul><li>经纬度坐标转世界坐标：Cesium.Cartesian3.fromDegrees(lng, lat, height)</li><li>世界坐标转经纬度坐标：Cesium.Cartographic.fromCartesian(cartesian3)</li><li>地理坐标（弧度制）转经纬度坐标：lng&#x3D;Cesium.Math.toDegrees(cartographic.longitude), lat&#x3D;Cesium.Math.toDegrees(cartographic.latitude), height&#x3D;cartographic.height;</li><li>弧度转经纬度：Cesium.Math.toDegrees(radians)</li><li>经纬度转弧度：Cesium.Math.toRadians(degrees)</li><li>屏幕坐标转世界坐标：scene.globe.pick(viewer.camera.getPickRay(windowPosition), scene) —— 一定要保证屏幕坐标在球上，不然得到的就是undefined</li><li>世界坐标转屏幕坐标：Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene,cartesian3)</li></ul><p><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"></p><p><strong>空间变换：</strong></p><p><code>只有转换到笛卡尔坐标系后才能运用计算机图形学中的仿射变换知识进行空间位置变换如平移旋转缩放。Cesium为我们提供了如下几种很有用的变换工具类：</code></p><ul><li>Cesium.Cartesian3（相当于Point3D）</li><li>Cesium.Matrix3（3x3矩阵，用于描述旋转变换）</li><li>Cesium.Matrix4（4x4矩阵，用于描述旋转加平移变换）</li><li>Cesium.Quaternion（四元数，用于描述围绕某个向量*旋转一定角度的变换）</li><li>Cesium.Transforms(包含将位置转换为各种参考系的功能)</li></ul><p><strong>Cesium目前支持的坐标系：</strong></p><ul><li><strong>WGS1984， Terrain的TileSceme默认是这个</strong></li><li><strong>墨卡托投影，Imagery的TileSceme默认是这个</strong></li></ul><p><code>viewer.canvas.clientHeight - movement.endPosition.y</code> :</p><p><strong>在 Cesium 和其他 WebGL 应用中，</strong><code>viewer.canvas</code> 元素的坐标系通常遵循 HTML Canvas 元素的常见布局：</p><ol><li><strong>坐标系起点</strong> ：Canvas 坐标系的原点 (0, 0) 位于 Canvas 的左上角。</li><li><strong>X轴方向</strong> ：X轴从左向右增长，即坐标值从 0 增加到 <code>canvas.width</code>。</li><li><strong>Y轴方向</strong> ：Y轴从上向下增长，即坐标值从 0 增加到 <code>canvas.clientHeight</code>。</li></ol><p>针对代码行 <code>viewer.canvas.clientHeight - movement.endPosition.y</code>，这里所表达的含义和坐标参考如下：</p><ul><li><strong><code>viewer.canvas.clientHeight</code></strong> ：这是 Canvas 元素的高度，也就是 Y 轴的最大值。</li><li><strong><code>movement.endPosition.y</code></strong> ：这通常是鼠标事件（如点击或拖动事件）结束时的 Y 坐标位置。在 Cesium 中，这个坐标也遵循 Canvas 的坐标系，即 Y 坐标从上到下增大。</li></ul><h2 id="ImageryProvider"><a href="#ImageryProvider" class="headerlink" title="ImageryProvider"></a>ImageryProvider</h2><p>加载影像底图API: <code>CesiumImagery.vue, ImageryLoading.vue</code></p><blockquote><p><strong>Cesium.: ImageryLayer, IonWorldImageryStyle, SingleTileImageryProvider, GridImageryProvider, TileCoordinateImagery</strong></p><p><strong>viewer:</strong></p><ul><li><strong>.scene.imageryLayers: scene里的，更明确</strong></li><li><strong>.imageryLayers: Gets the collection of image layers that will be rendered on the globe. 更简洁，两者功能一样</strong></li></ul></blockquote><p><strong>两者对比</strong></p><p><strong>Imagery Provider使用特定的服务请求Tiles，而Layer表示来自Imagery Provider的displayed tiles。比如说,</strong></p><p><code>const layer = layers.addImageryProvider(imageryProvider);</code></p><p><strong>是</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const layer = new Cesium.ImageryLayer(imageryProvider);</span><br><span class="line">layers.add(layer);</span><br></pre></td></tr></table></figure><p>我们通常构建一个imagery provider只是为了创建一个layer; 然后我们使用layer的属性(如show、 alpha、brightness和contrast)操作该图层以改变其视觉外观。解耦decoupling imagery provider和layer使得编写新的imagery provider变得更加容易。</p><p>与上面示例中的Layer一样，imagery layer collection决定了图层绘制的顺序。layer是根据添加的顺序从底部到顶部绘制的。像Cesium中的任何其他集合一样，使用add, remove and get等函数操作imagery layer collection。此外，layer可以使用 raise、 raiseToTop、 lower 和 lowerTobottom 来重新排序。</p><p>Mapbox影像加载：</p><p>mapbox:&#x2F;&#x2F;styles&#x2F;foxziluliu1121&#x2F;clrzymvix009g01r67bowdcez</p><p><a href="https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></p><ul><li><strong>ImageryLayer, ImageryProvider,</strong></li><li>**Vector Tiles API:  **<a href="https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></li><li>**static tiles API:  **<code>https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</code></li><li><strong>Mapbox的数据格式：</strong><ul><li><strong>mapbox.mapbox-streets-v8</strong></li><li><code>foxziluliu1121.9mqo2ps2</code></li></ul></li></ul><h2 id="terrainProvider"><a href="#terrainProvider" class="headerlink" title="terrainProvider"></a>terrainProvider</h2><p>地形图层只能有一个；</p><p>地形类型：</p><ul><li>STK World Terrain</li><li>Small Terrain</li></ul><p>terrainProvider:</p><ul><li>EllipsoidTerrainProvider</li><li>CustomHeightmapTerrainProvider</li></ul><p>Ceisum案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Terrain.fromWorldTerrain(&#123;</span><br><span class="line">    requestWaterMask: true,</span><br><span class="line">    requestVertexNormals: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="加载矢量数据"><a href="#加载矢量数据" class="headerlink" title="加载矢量数据"></a>加载矢量数据</h2><ul><li>CustomDataSource</li><li>CzmlDataSource</li><li>GeoJsonDataSource, GeoJson, TopoJson</li><li>KmlDataSource</li><li></li></ul><h2 id="空间数据可视化"><a href="#空间数据可视化" class="headerlink" title="空间数据可视化"></a>空间数据可视化</h2><h3 id="Entity-API"><a href="#Entity-API" class="headerlink" title="Entity API"></a>Entity API</h3><p>以Graphics结尾：</p><ul><li>billboard, box, corridor, cylinder, ellipse, ellipsoid, label</li><li>model, tileset, path, plane,</li><li>point, polygon, polyline, polylineVolume, rectangle, wall,</li></ul><p><strong>使用注意点：</strong></p><p>在Cesium中，<code>Cesium.BoxGraphics</code>是用来定义一个实体（Entity）的盒状几何体的可视化属性的类。这个类本身并不负责将几何体添加到场景中；相反，它被用作描述实体的视觉外观的一部分。为了在Cesium的3D场景中显示一个盒状几何体，你需要将这个几何体与一个实体（Entity）关联，并将该实体添加到Cesium的实体集合中。这就是为什么在实践中，你看到的示例代码通常会使用 <code>viewer.entities.add()</code>来创建和添加带有盒状几何体的实体。</p><p>这里是一个简化的示例，说明如何使用 **<code>Cesium.BoxGraphics</code>通过 <code>viewer.entities.add()</code>添加一个盒状几何体到场景中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;);</span><br><span class="line"></span><br><span class="line">var box = viewer.entities.add(&#123;</span><br><span class="line">    position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 200000.0),</span><br><span class="line">    box: &#123;</span><br><span class="line">        dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),</span><br><span class="line">        material: Cesium.Color.BLUE.withAlpha(0.5),</span><br><span class="line">        outline: true,</span><br><span class="line">        outlineColor: Cesium.Color.BLACK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">viewer.zoomTo(viewer.entities);</span><br></pre></td></tr></table></figure><p><strong>在这个示例中：</strong></p><ul><li><code>viewer</code>是 <code>Cesium.Viewer</code>的一个实例，它是Cesium应用的主要界面。</li><li><code>viewer.entities.add(&#123;...&#125;)</code>是添加新实体到场景的方法。这个方法的参数是一个对象，描述了实体的各种属性，包括位置（<code>position</code>）、形状（在这个例子中是一个盒子，通过 <code>box</code>属性定义）等。</li><li><code>box</code>属性使用 <code>Cesium.BoxGraphics</code>的一个实例来定义盒状几何体的外观，包括尺寸（<code>dimensions</code>）、材质（<code>material</code>）、轮廓线是否可见（<code>outline</code>）以及轮廓线的颜色（<code>outlineColor</code>）。</li></ul><p><strong>总之，</strong><code>Cesium.BoxGraphics</code>提供了定义盒状几何体视觉外观的方式，而 <code>viewer.entities.add()</code>则是将这样定义的盒状几何体实体添加到Cesium场景中的方法。这种设计允许开发者以灵活的方式创建和管理场景中的对象，同时提供了丰富的API来定义这些对象的视觉外观。</p><p>EntityCluster类+PinBuilder类：实现billboards, points, labels的聚合</p><p>Entity管理：viewer.entities的类型是EntityCollection，包括了EntityCollection类里面的所有属性和方法，如.add(), .contains(), .getById(), .remove(), .removeAll(), .removeById()</p><p>Entity拾取：viewer.scene.pick(), viewer.scene.drillPick()</p><p>Entity固定：heightReference属性值，</p><h3 id="Primitive-API"><a href="#Primitive-API" class="headerlink" title="Primitive API"></a>Primitive API</h3><p>加载数据的性能更好，可以更好的加载3D Tiles数据。</p><p>Cesium.GeometryInstance()</p><p>Cesium.EllipsoidSurfaceAppearance</p><p>Cesium.Primitive()</p><p>scene.primitives.add()</p><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p><img src="https://s2.loli.net/2024/04/04/9bVKQRSEtL6Dnw4.png"></p><p><strong>MaterialProperty:</strong></p><ul><li>Cesium.ColorMaterialProperty</li><li>Cesium.ImageMaterialProperty</li><li></li></ul><h2 id="GLTF格式"><a href="#GLTF格式" class="headerlink" title="GLTF格式"></a>GLTF格式</h2><p><img src="https://pic2.zhimg.com/80/v2-a26039ef8457742c7121e9532289da51_1440w.webp" alt="img"></p><p><strong>Cesium加载gltf:</strong></p><ul><li>viewer.entities.add()</li><li>viewer.scene.primitives.add(), Cesium.Model.fromGltf()</li></ul><h2 id="3D-Tiles格式"><a href="#3D-Tiles格式" class="headerlink" title="3D Tiles格式"></a>3D Tiles格式</h2><p>3D Tiles可以理解为带有LOD的glTF,为流式传输和渲染海量3D数据而设计，例如倾斜摄影、3D建筑、BIM&#x2F;CAD，实例化要素集和点云。3D Tiles定义了一种数据分层结构和一组切片方式。</p><p><strong>组成：</strong></p><ul><li>描述瓦片集Tileset的JSON文件 —— tileset.json</li><li>一组瓦片Tile<ul><li>瓦片对象的格式可以：b3dm, i3dm, pnts, cmpt</li></ul></li></ul><p><strong>常用类：</strong></p><ul><li>Cesium3Dtileset：用于流式传输大量的异构3D地理空间数据集；</li><li>Cesium3DTileStyle：瓦片集样式；</li><li>Cesium3DTile：数据集中的一个瓦片;</li><li>Cesium3DTileContent：瓦片内容；</li><li>Cesium3DTileFeature：瓦片集要素，用于访问Tile中批量表中的属性数据，可通过scene.pick方法来获取一个 BATCH，即三维要素。Cesium3DTileFeature.getPropertyNames() 方法获取批量表中所有属性名，Cesium3DTileFeature.getProperty(string Name) 来获取对应属性名的属性值。</li></ul><p><strong>操作：</strong></p><ol><li>加载：viewer.scene.primitives.add(new Cesium.Cesium3DTileset())</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="Cesium3DTileset"><a href="#Cesium3DTileset" class="headerlink" title="Cesium3DTileset"></a>Cesium3DTileset</h4><p><a href="https://cesium.com/learn/cesiumjs/ref-doc/Cesium3DTileset.html?classFilter=Cesium3DTileset">官网链接</a></p><p><code>featureIdLabel</code> 属性在 Cesium 的 <code>Cesium3DTileset</code> 对象中用于指定用于拾取（picking）和样式化（styling）的特征 ID 集合。以下是对这段文档的详细解释和它的作用：</p><ol><li><strong>选择特征 ID 集合</strong>：<ul><li>在 <code>Cesium3DTileset</code> 中，<code>featureIdLabel</code> 用来标识和选择特定的特征 ID 集合。这对于执行拾取操作和应用样式至关重要，尤其是当模型包含多个特征 ID 集合时。</li></ul></li><li><strong>EXT_mesh_features 和 EXT_feature_metadata</strong>：<ul><li>对于遵循 <code>EXT_mesh_features</code> 扩展的数据，<code>featureIdLabel</code> 可以是特征 ID 的 <code>label</code> 属性，如果未指定，则默认为 <code>&quot;featureId_N&quot;</code>（N 是 featureIds 数组中的索引）。</li><li>对于旧的 <code>EXT_feature_metadata</code> 扩展，没有 <code>label</code> 字段，所以特征 ID 集总是以 <code>&quot;featureId_N&quot;</code> 标识，其中 N 是所有特征 ID 列表中的索引，特征 ID 属性在特征 ID 纹理之前列出。</li></ul></li><li><strong>特征 ID 标签的自动转换</strong>：<ul><li>如果 <code>featureIdLabel</code> 被设置为一个整数 N，它将自动转换为字符串 <code>&quot;featureId_N&quot;</code>。这意味着你可以简单地指定一个索引，Cesium 会自动解析为正确的特征 ID 标签。</li></ul></li><li><strong>优先级</strong>：<ul><li>如果同时存在每个基元（per-primitive）和每个实例（per-instance）的特征 IDs，实例特征 IDs 有优先权。这对于决定在冲突时哪组特征 ID 应该被使用是重要的。</li></ul></li></ol><p><strong>作用</strong></p><ul><li><strong>拾取和样式化</strong>：<ul><li>通过指定 <code>featureIdLabel</code>，开发者可以精确控制哪一组特征 ID 被用于交互（如鼠标拾取）和视觉样式化。这在处理包含复杂数据集的大型 3D Tiles 模型时尤其有用。</li></ul></li><li><strong>灵活性和控制</strong>：<ul><li>提供了对模型特征的更精细的控制，允许开发者基于具体的特征 ID 集来应用样式和执行拾取，特别是在模型中嵌入了多种数据层（如不同的物理部分或不同类型的数据标注）时。</li></ul></li><li><strong>实验性特性</strong>：<ul><li><strong>重要的是要注意，</strong><code>featureIdLabel</code> 是一个实验性特性，属于 3D Tiles 规范的一部分，该规范尚未最终确定。因此，使用这个特性时需要谨慎，因为它可能会在没有标准弃用政策的情况下改变。</li></ul></li></ul><p><code>featureIdLabel</code> 是一个强大的工具，用于在复杂的 3D Tiles 数据集中进行精确的交互和视觉表示。它使得开发者可以根据特定的特征 ID 集来定制模型的表现和行为，增强了模型与用户交互的能力和灵活性。但是，由于它的实验性质，使用时需要关注 Cesium 更新和变更。</p><h2 id="Cesium的Property"><a href="#Cesium的Property" class="headerlink" title="Cesium的Property"></a>Cesium的Property</h2><p><strong>基本property</strong></p><ul><li>CompositeProperty</li><li>ConstantProperty</li><li>SampledProperty</li><li>TimeIntervalCollectionProperty</li></ul><p><strong>Material的property</strong></p><p><strong>PositionProperty</strong></p><p><strong>其他</strong></p><p><img src="https://pic4.zhimg.com/80/v2-9cb0b7aa0c14747709a9dc455c7dccf7_720w.webp" alt="img"></p><h2 id="组件重写"><a href="#组件重写" class="headerlink" title="组件重写"></a>组件重写</h2><p>homeButton回到主要页面；</p><p>Geocoder组件通过OSM服务实现；</p><p>自定义BaseLayerPicker:</p><ul><li>viewer.baseLayerPicker.viewModel.imageryProviderViewModels</li><li>viewer.baseLayerPicker.viewModel.terrainProviderViewModels</li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>let handler &#x3D; new Cesium.ScreenSpaceEventHandler(viewer.canvas)</p><p>let eventType &#x3D; Cesium.ScreenSpaceEventType.LEFT_CLICK</p><p>handler.setInputAction((event) &#x3D;&gt; {}, eventType)</p><p>Keyboard: camera.moveForward, .moveBackward, .moveUp, .moveDown, .moveLeft, .moveRight</p><p>场景渲染: scene.preUpdate, .postUpdate, .preRender, .postRender</p><h2 id="相机控制"><a href="#相机控制" class="headerlink" title="相机控制"></a>相机控制</h2><p>viewer.flyTo(target, options)</p><p>viewer.zoomTo(target, offset)</p><p>viewer.camera.flyTo(options)</p><p>viewer.camera.flyToBoundingSphere(boundingSphere, options)</p><p>viewer.camera.lookAt(target, offset)</p><p>viewer.camera.lookAtTransform(transform, offset)</p><p>viewer.camera.setView(options)</p><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>距离</p><p>面积</p><p>handler.setInputAction(func(), Cesium.ScreenSpacEventType.RIGHT_CLICK)</p><h2 id="调试面板"><a href="#调试面板" class="headerlink" title="调试面板"></a>调试面板</h2><p>CesiumInspector</p><blockquote><p>了解Cesium渲染效果以及性能调优</p><p>viewer.extend(Cesium.viewerCesiumInspectorMixin)</p></blockquote><p>Cesium3DTilesInspector</p><blockquote><p>用于监视3D Tiles数据的监视器</p><p>viewer.extend(Cesium.viewerCesium3DTilesInspector)</p></blockquote><h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><p>new Cesium.ParticleSystem()</p><h2 id="场景后处理"><a href="#场景后处理" class="headerlink" title="场景后处理"></a>场景后处理</h2><p>postProgress类</p><p>postProgressStage</p><p>postProgressStageLibrary</p><p>postProgressStageCollection</p><h2 id="与第三方库集成"><a href="#与第三方库集成" class="headerlink" title="与第三方库集成"></a>与第三方库集成</h2><p>ThreeJS</p><ol><li>初始化两个容器，和各自的渲染器</li><li>调整各自的渲染频率和相机一致</li><li>加入要展示的内容</li></ol><p>ECharts</p><p>Heatmap</p><p>Turf</p><h2 id="源码打包"><a href="#源码打包" class="headerlink" title="源码打包"></a>源码打包</h2><p>gulp, webpack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初步了解&quot;&gt;&lt;a href=&quot;#初步了解&quot; class=&quot;headerlink&quot; title=&quot;初步了解&quot;&gt;&lt;/a&gt;初步了解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Cesium官网&lt;/strong&gt; &lt;a href=&quot;https://cesium.com/&quot;&gt;Cesium</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="Cesium" scheme="https://youxt-njnu.github.io/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>WebAPIs 知识点梳理</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/WebAPIs/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/WebAPIs/</id>
    <published>2024-06-13T01:33:26.000Z</published>
    <updated>2024-06-13T02:42:39.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ol><li><strong>API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现</strong></li><li><strong>Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。</strong></li><li><strong>Web API 一般都有输入和输出（ 函数的传参和返回值），Web API 很多都是方法（函数）</strong></li><li><strong>学习 Web API 可以结合前面学习内置对象方法的思路学习</strong></li></ol><h2 id="1-2-DOM-介绍"><a href="#1-2-DOM-介绍" class="headerlink" title="1.2. DOM 介绍"></a>1.2. DOM 介绍</h2><h3 id="1-2-1-什么是DOM"><a href="#1-2-1-什么是DOM" class="headerlink" title="1.2.1 什么是DOM"></a>1.2.1 什么是DOM</h3><p>**文档对象模型（Document Object Model，简称DOM），是 **<a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p><p><strong>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</strong></p><blockquote><p><strong>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</strong></p></blockquote><h3 id="1-2-2-DOM树"><a href="#1-2-2-DOM树" class="headerlink" title="1.2.2. DOM树"></a>1.2.2. DOM树</h3><p><img src="https://s2.loli.net/2024/06/13/bIQ3ek6qtW9CFBm.png"></p><p><strong>DOM树又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。</strong></p><ul><li><strong>文档：一个页面就是一个文档，DOM中使用document表示</strong></li><li><strong>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</strong></li><li><strong>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</strong></li></ul><p><strong>DOM把以上内容都看成对象；</strong></p><h2 id="1-3-获取元素"><a href="#1-3-获取元素" class="headerlink" title="1.3. 获取元素"></a>1.3. 获取元素</h2><p><strong>为什么要获取页面元素？</strong></p><p><strong>例如：我们想要操作页面上的某部分(显示&#x2F;隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。</strong></p><h3 id="1-3-1-根据ID获取"><a href="#1-3-1-根据ID获取" class="headerlink" title="1.3.1. 根据ID获取"></a>1.3.1. 根据ID获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementById(id)</span><br><span class="line">作用：根据ID获取元素对象</span><br><span class="line">参数：id值，区分大小写的字符串</span><br><span class="line">返回值：元素对象 或 null</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面</span><br><span class="line">        var timer = document.getElementById(&#x27;time&#x27;);</span><br><span class="line">        console.log(timer);</span><br><span class="line">        console.log(typeof timer);</span><br><span class="line">        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法</span><br><span class="line">        console.dir(timer);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/13/srPCptxVckEZMWQ.png"></p><h3 id="1-3-2-根据标签名获取元素"><a href="#1-3-2-根据标签名获取元素" class="headerlink" title="1.3.2. 根据标签名获取元素"></a>1.3.2. 根据标签名获取元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementsByTagName(&#x27;标签名&#x27;) 或者 element.getElementsByTagName(&#x27;标签名&#x27;) </span><br><span class="line">作用：根据标签名获取元素对象</span><br><span class="line">参数：标签名</span><br><span class="line">返回值：元素对象集合（伪数组，数组元素是元素对象）</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的</span><br><span class="line">        var lis = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">        console.log(lis[0]);</span><br><span class="line">        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式</span><br><span class="line">        for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">            console.log(lis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签</span><br><span class="line">        var nav = document.getElementById(&#x27;nav&#x27;); // 这个获得nav 元素</span><br><span class="line">        var navLis = nav.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(navLis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br><strong>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历</strong><br><strong>2.得到元素对象是动态的</strong></p><p><strong>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</strong></p><h3 id="1-3-3-H5新增获取元素方式"><a href="#1-3-3-H5新增获取元素方式" class="headerlink" title="1.3.3. H5新增获取元素方式"></a>1.3.3. H5新增获取元素方式</h3><p><strong>1.document.getElementsByclassName(‘类名’);&#x2F;&#x2F;根据类名返回元素对象集合</strong><br><strong>2.document.uerySelector(‘选择器)；&#x2F;&#x2F;根据指定选择器返回第一个元素对象</strong><br><strong>3.document.querySelectorAll(‘选择器’); &#x2F;&#x2F;根据指定选择器返回</strong><br><strong>注意：</strong><br><strong>querySelector和querySelectorAll里面的选择器需要加符号，比如：document.querySelector(‘#nav’);</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. getElementsByClassName 根据类名获得某些元素集合</span><br><span class="line">        var boxs = document.getElementsByClassName(&#x27;box&#x27;);</span><br><span class="line">        console.log(boxs);</span><br><span class="line">        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav</span><br><span class="line">        var firstBox = document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">        console.log(firstBox);</span><br><span class="line">        var nav = document.querySelector(&#x27;#nav&#x27;);</span><br><span class="line">        console.log(nav);</span><br><span class="line">        var li = document.querySelector(&#x27;li&#x27;);</span><br><span class="line">        console.log(li);</span><br><span class="line">        // 3. querySelectorAll()返回指定选择器的所有元素对象集合</span><br><span class="line">        var allBox = document.querySelectorAll(&#x27;.box&#x27;);</span><br><span class="line">        console.log(allBox);</span><br><span class="line">        var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-获取特殊元素（body，html）"><a href="#1-3-4-获取特殊元素（body，html）" class="headerlink" title="1.3.4 获取特殊元素（body，html）"></a>1.3.4 获取特殊元素（body，html）</h3><p><strong>获取body元素 1.doucumnet.body&#x2F;&#x2F;返回body元素对象</strong><br><strong>获取html元素 1.document.documentElement&#x2F;&#x2F;返回html元素对象</strong></p><h2 id="1-4-事件基础"><a href="#1-4-事件基础" class="headerlink" title="1.4. 事件基础"></a>1.4. 事件基础</h2><h3 id="1-4-1-事件概述"><a href="#1-4-1-事件概述" class="headerlink" title="1.4.1. 事件概述"></a>1.4.1. 事件概述</h3><p><strong>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</strong></p><p>**简单理解： **<strong>触发 — 响应机制</strong>。</p><p><strong>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</strong></p><h3 id="1-4-2-事件三要素"><a href="#1-4-2-事件三要素" class="headerlink" title="1.4.2. 事件三要素"></a>1.4.2. 事件三要素</h3><ul><li><strong>事件源（谁）：触发事件的元素</strong></li><li><strong>事件类型（什么事件）： 例如 click 点击事件</strong></li><li><strong>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</strong></li></ul><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 点击一个按钮，弹出对话框</span><br><span class="line">        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span><br><span class="line">        //(1) 事件源 事件被触发的对象   谁  按钮</span><br><span class="line">        var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span><br><span class="line">        //(3) 事件处理程序  通过一个函数赋值的方式 完成</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            alert(&#x27;点秋香&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-执行事件的步骤"><a href="#1-4-3-执行事件的步骤" class="headerlink" title="1.4.3. 执行事件的步骤"></a>1.4.3. 执行事件的步骤</h3><p><strong>1.获取事件源</strong><br><strong>2.注册事件（绑定事件）</strong><br><strong>3.添加事件处理程序（采取函数赋值形式）</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 执行事件步骤</span><br><span class="line">        // 点击div 控制台输出 我被选中了</span><br><span class="line">        // 1. 获取事件源</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.绑定事件 注册事件</span><br><span class="line">        // div.onclick </span><br><span class="line">        // 3.添加事件处理程序 </span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            console.log(&#x27;我被选中了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-常见的鼠标事件"><a href="#1-4-4-常见的鼠标事件" class="headerlink" title="1.4.4. 常见的鼠标事件"></a>1.4.4. 常见的鼠标事件</h3><p><img src="https://s2.loli.net/2024/06/13/DPX2E1hGYSAmIjo.png"></p><h3 id="1-4-5-分析事件三要素（见实操案例）"><a href="#1-4-5-分析事件三要素（见实操案例）" class="headerlink" title="1.4.5. 分析事件三要素（见实操案例）"></a>1.4.5. 分析事件三要素（见实操案例）</h3><ul><li><strong>下拉菜单三要素</strong></li><li><strong>关闭广告三要素</strong></li></ul><h2 id="1-5-操作元素"><a href="#1-5-操作元素" class="headerlink" title="1.5. 操作元素"></a>1.5. 操作元素</h2><p>**    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）**</p><h3 id="1-5-1-改变元素内容（获取或设置）"><a href="#1-5-1-改变元素内容（获取或设置）" class="headerlink" title="1.5.1. 改变元素内容（获取或设置）"></a>1.5.1. 改变元素内容（获取或设置）</h3><p><strong>element.innerText</strong><br><strong>从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</strong><br><strong>element.innerHTML</strong><br><strong>起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</strong></p><p><strong>innerText改变元素内容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;显示当前系统时间&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;某个时间&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;1123&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 当我们点击了按钮，  div里面的文字会发生变化</span><br><span class="line">        // 1. 获取元素 </span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.注册事件</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // div.innerText = &#x27;2019-6-6&#x27;;</span><br><span class="line">            div.innerHTML = getDate();</span><br><span class="line">        &#125;</span><br><span class="line">        function getDate() &#123;</span><br><span class="line">            var date = new Date();</span><br><span class="line">            // 我们写一个 2019年 5月 1日 星期三</span><br><span class="line">            var year = date.getFullYear();</span><br><span class="line">            var month = date.getMonth() + 1;</span><br><span class="line">            var dates = date.getDate();</span><br><span class="line">            var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">            var day = date.getDay();</span><br><span class="line">            return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day];</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>innerText和innerHTML的区别</strong></p><ul><li><strong>获取内容时的区别：</strong></li></ul><p>**    innerText会去除空格和换行，而innerHTML会保留空格和换行    **</p><ul><li><strong>设置内容时的区别：</strong></li></ul><p>**    innerText不会识别html，而innerHTML会识别**</p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        我是文字</span><br><span class="line">        &lt;span&gt;123&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // innerText 和 innerHTML的区别 </span><br><span class="line">        // 1. innerText 不识别html标签 非标准  去除空格和换行</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span><br><span class="line">        div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 这两个属性是可读写的  可以获取元素里面的内容</span><br><span class="line">        var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">        console.log(p.innerText);</span><br><span class="line">        console.log(p.innerHTML);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-常用元素的属性操作"><a href="#1-5-2-常用元素的属性操作" class="headerlink" title="1.5.2. 常用元素的属性操作"></a>1.5.2. 常用元素的属性操作</h3><p><strong>1.innerText,innerHTML 改变元素内容</strong><br><strong>2.src、href</strong><br><strong>3.id、alt、title</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;</span><br><span class="line">    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 修改元素属性  src</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var ldh = document.getElementById(&#x27;ldh&#x27;);</span><br><span class="line">        var zxy = document.getElementById(&#x27;zxy&#x27;);</span><br><span class="line">        var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line">        // 2. 注册事件  处理程序</span><br><span class="line">        zxy.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/zxy.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;张学友思密达&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        ldh.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/ldh.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;刘德华&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-案例：分时问候"><a href="#1-5-3-案例：分时问候" class="headerlink" title="1.5.3. 案例：分时问候"></a>1.5.3. 案例：分时问候</h3><p><img src="https://s2.loli.net/2024/06/13/ki3jF4NTnWQKRpL.png"></p><h3 id="1-5-4-表单元素的属性操作"><a href="#1-5-4-表单元素的属性操作" class="headerlink" title="1.5.4. 表单元素的属性操作"></a>1.5.4. 表单元素的属性操作</h3><p><strong>利用DOM可以操作如下表单元素的属性：</strong><br><strong>type、value、checked、selected、disabled</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p><p><strong>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var input = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // 表单里面的值 文字内容是通过 value 来修改的</span><br><span class="line">            input.value = &#x27;被点击了&#x27;;</span><br><span class="line">            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span><br><span class="line">            // btn.disabled = true;</span><br><span class="line">            this.disabled = true;</span><br><span class="line">            // this 指向的是事件函数的调用者 btn</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-案例：仿京东显示密码"><a href="#1-5-5-案例：仿京东显示密码" class="headerlink" title="1.5.5. 案例：仿京东显示密码"></a>1.5.5. 案例：仿京东显示密码</h3><p><img src="https://s2.loli.net/2024/06/13/G9BXQyrReOTxI65.png"></p><h3 id="1-5-6-样式属性操作"><a href="#1-5-6-样式属性操作" class="headerlink" title="1.5.6. 样式属性操作"></a>1.5.6. 样式属性操作</h3><p><strong>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</strong></p><p><strong>常用方式</strong></p><p><strong>1.element.style  行内样式操作</strong><br><strong>2.element.className  类名样式操作</strong></p><h4 id="方式1：通过操作style属性"><a href="#方式1：通过操作style属性" class="headerlink" title="方式1：通过操作style属性"></a>方式1：通过操作style属性</h4><blockquote><p><strong>元素对象的style属性也是一个对象！</strong></p><p><strong>元素对象.style.样式属性 &#x3D; 值;</strong></p></blockquote><p><strong>注意：</strong><br><strong>1.JS 里面的样式采取小驼峰命名法比如fontsize、backgroundColor</strong><br><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            // div.style里面的属性 采取驼峰命名法 </span><br><span class="line">            this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            this.style.width = &#x27;250px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：淘宝点击关闭二维码"><a href="#案例：淘宝点击关闭二维码" class="headerlink" title="案例：淘宝点击关闭二维码"></a>案例：淘宝点击关闭二维码</h4><p><img src="https://s2.loli.net/2024/06/13/M17o26KwY4Tx9yR.png"></p><h4 id="案例：循环精灵图背景"><a href="#案例：循环精灵图背景" class="headerlink" title="案例：循环精灵图背景"></a>案例：循环精灵图背景</h4><p><img src="https://s2.loli.net/2024/06/13/RHjG1g8Dzhw4kuB.png"></p><h4 id="案例：显示隐藏文本框内容"><a href="#案例：显示隐藏文本框内容" class="headerlink" title="案例：显示隐藏文本框内容"></a>案例：显示隐藏文本框内容</h4><p><img src="https://s2.loli.net/2024/06/13/yQxe7VT3YXpkrU5.png"></p><h4 id="方式2：通过操作className属性"><a href="#方式2：通过操作className属性" class="headerlink" title="方式2：通过操作className属性"></a>方式2：通过操作className属性</h4><blockquote><p><strong>元素对象.className &#x3D; 值;</strong></p><p><strong>因为class是关键字，所有使用className。</strong></p></blockquote><p><strong>注意：</strong><br><strong>1,如果样式修改较多，可以采取操作类名方式更改元素样式。</strong><br><strong>2.class因为是个保留字，因此使用className来操作元素类名属性</strong><br><strong>3.className 会直接更改元素的类名，会覆盖原先的类名。</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br><span class="line">        var test = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        test.onclick = function() &#123;</span><br><span class="line">            // this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            // this.style.color = &#x27;#fff&#x27;;</span><br><span class="line">            // this.style.fontSize = &#x27;25px&#x27;;</span><br><span class="line">            // this.style.marginTop = &#x27;100px&#x27;;</span><br><span class="line"></span><br><span class="line">            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br><span class="line">            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br><span class="line">            // this.className = &#x27;change&#x27;;</span><br><span class="line">            this.className = &#x27;first change&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：密码框格式提示错误信息"><a href="#案例：密码框格式提示错误信息" class="headerlink" title="案例：密码框格式提示错误信息"></a>案例：密码框格式提示错误信息</h4><p><img src="https://s2.loli.net/2024/06/13/6OkmXxy9sSY3bv7.png"></p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2024/06/13/5KReAgoXG1VIpdZ.png"></p><h2 id="1-6-H5自定义属性"><a href="#1-6-H5自定义属性" class="headerlink" title="1.6. H5自定义属性"></a>1.6. H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</strong></p><p><strong>自定义属性获取是通过getAttribute(‘属性’) 获取。</strong></p><p><strong>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</strong></p><p><strong>H5给我们新增了自定义属性：</strong></p><p><strong>1.设置H5自定义属性</strong><br><strong>H5规定自定义属性data-开头做为属性名并目赋值。</strong><br><strong>比如</strong> <code>&lt;div data-index=&quot;1&quot;&gt;</code><strong><code>&lt;/div&gt;</code></strong><br><strong>或者使用JS设置</strong><br><strong>element.setAttribute(‘data-index’,2)</strong></p><p><strong>2.获取H5自定义属性</strong><br><strong>1.兼容性获取element.getAttribute(‘data-index’):</strong><br><strong>2.H5新增element.dataset.index或者element.dataset[‘index’]   ie11才开始支持</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // console.log(div.getTime);</span><br><span class="line">        console.log(div.getAttribute(&#x27;getTime&#x27;));</span><br><span class="line">        div.setAttribute(&#x27;data-time&#x27;, 20);</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-index&#x27;));</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-list-name&#x27;));</span><br><span class="line">        // h5新增的获取自定义属性的方法 它只能获取data-开头的</span><br><span class="line">        // dataset 是一个集合里面存放了所有以data开头的自定义属性</span><br><span class="line">        console.log(div.dataset);</span><br><span class="line">        console.log(div.dataset.index);</span><br><span class="line">        console.log(div.dataset[&#x27;index&#x27;]);</span><br><span class="line">        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span><br><span class="line">        console.log(div.dataset.listName);</span><br><span class="line">        console.log(div.dataset[&#x27;listName&#x27;]);//data-list-name</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="1-7-节点操作"><a href="#1-7-节点操作" class="headerlink" title="1.7. 节点操作"></a>1.7. 节点操作</h2><p><strong>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</strong></p><ul><li><strong>元素节点nodeType为1</strong></li><li><strong>属性节点nodeType为2</strong></li><li><strong>文本节点nodeType为3(文本节点包含文字、空格、换行等)</strong></li></ul><p><strong>我们在实际开发中，节点操作主要操作的是元素节点</strong></p><h3 id="1-7-1-节点层级"><a href="#1-7-1-节点层级" class="headerlink" title="1.7.1. 节点层级"></a>1.7.1. 节点层级</h3><p>**    利用 DOM 树可以把节点划分为不同的层级关系，常见的是**<strong>父子兄层级关系</strong>。</p><p><img src="https://s2.loli.net/2024/06/13/Ogtv9nHuEMZqyhA.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.parentNode</span><br><span class="line">parentNode.childNodes</span><br><span class="line">parentNode.children</span><br><span class="line">parentNode.firstChild</span><br><span class="line">parentNode.lastChild</span><br><span class="line">parentNode.firstElementChild</span><br><span class="line">parentNode.lastElementChild</span><br><span class="line">parentNode.children[0]</span><br><span class="line">parentNode.children[parentNode.children.length-1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.nextSibling</span><br><span class="line">node.previousSibling</span><br><span class="line">node.nextElementSibling</span><br><span class="line">node.previousElementSibling</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   function getNextElementSibling(element) &#123;</span><br><span class="line">      var el = element;</span><br><span class="line">      while (el = el.nextSibling) &#123;</span><br><span class="line">        if (el.nodeType === 1) &#123;</span><br><span class="line">            return el;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;//是元素节点，就返回</span><br><span class="line">      return null;//不是元素节点，返回null</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><h3 id="1-7-2-节点操作"><a href="#1-7-2-节点操作" class="headerlink" title="1.7.2. 节点操作"></a>1.7.2. 节点操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createElement(&#x27;tagName&#x27;)</span><br><span class="line">node.appendChild(child)</span><br><span class="line">node.insertBefore(child,指定元素)</span><br><span class="line">node.removeChild(child)</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GIS集成案例汇报</title>
    <link href="https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/"/>
    <id>https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/</id>
    <published>2024-05-31T01:33:26.000Z</published>
    <updated>2024-06-13T01:51:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>地理信息集成课程汇报（与TLQ合作，感谢！）</p><p><img src="https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png" alt="1.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ogFZUMn2bLBsxHP.png" alt="2.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/2FgX7cUQiRzIfJd.png" alt="3.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/dLPKfYwCpylSWih.png" alt="4.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8fx5bjDVnpERuOd.png" alt="5.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=341481481&bvid=BV1CR4y1A78S&cid=717991642&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/M4D6bAowy8iZ7Yv.png" alt="7.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/imL2PkUsGajWxbF.png" alt="8.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ColDRx4TSG5Amh6.png" alt="9.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8cQWF73tgzKTjCn.png" alt="10.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/5JTNYdMo6naiU3O.png" alt="11.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/rdKkcylwaPmAG8i.png" alt="幻灯片12.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/kgHosDmy3AGECqT.png" alt="幻灯片13.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/GWtdX9sfi8VUIx1.png" alt="幻灯片14.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/1KMZYlqzh2Wy5s4.png" alt="幻灯片15.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/1KJnBzQ7edx4SYV.png" alt="幻灯片16.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/jo2gOWszI619Y7v.png" alt="幻灯片17.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/hnAwgIOZo3TtSs6.png" alt="幻灯片18.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/o76d5WrFwU4b8Gf.png" alt="幻灯片19.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/O9aCgdNFh4GmoyL.png" alt="幻灯片20.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/4SUDLPcJXMGzops.png" alt="幻灯片21.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/eVAFpTj6o1LwKv3.png" alt="幻灯片22.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/cfq8XexUyz16S5k.png" alt="幻灯片23.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/oN3VCuPRYZwMB8z.png" alt="幻灯片24.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地理信息集成课程汇报（与TLQ合作，感谢！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png&quot; alt=&quot;1.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli</summary>
      
    
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/categories/AR/"/>
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/tags/AR/"/>
    
    <category term="汇报PPT" scheme="https://youxt-njnu.github.io/tags/%E6%B1%87%E6%8A%A5PPT/"/>
    
  </entry>
  
  <entry>
    <title>demo| 光影人物</title>
    <link href="https://youxt-njnu.github.io/2024/04/02/three-demo-%E5%85%89%E5%BD%B1%E4%BA%BA%E7%89%A9/"/>
    <id>https://youxt-njnu.github.io/2024/04/02/three-demo-%E5%85%89%E5%BD%B1%E4%BA%BA%E7%89%A9/</id>
    <published>2024-04-02T02:02:05.000Z</published>
    <updated>2024-10-06T02:39:21.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光影人物"><a href="#光影人物" class="headerlink" title="光影人物"></a>光影人物</h1><p>参考教程：<a href="https://juejin.cn/post/7145064095178293285">https://juejin.cn/post/7145064095178293285</a></p><ol><li>两个渲染器、相机，一个场景，添加光照；</li><li>处理窗口缩放</li><li>构建页面结构</li><li>css写在外部文件里</li><li>构建加载管理器，实现加载页面的下移、消失、移除</li><li>加载glb模型，并使用draco进行处理</li><li>使用intersection observer进行异步观察</li><li>处理鼠标移动下的span效果</li><li>调整相机</li><li>添加事件监听</li></ol><p>注意点：</p><ul><li><p>renderer1.outputColorSpace &#x3D; Three.SRGBColorSpace &#x2F;&#x2F; API已经改成了ColorSpace</p></li><li><p>why lds-roller has 8 divs? ,用于形成loading旋转的时候的八个点</p></li></ul><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><p><code>IntersectionObserver</code> 是一个强大的 Web API，用于异步观察一个元素与其祖先元素或顶级文档视窗（viewport）的交叉状态。简单来说，它允许你配置一个回调函数，当被观察的元素以某种方式进入或离开另一个元素的视域时，这个回调函数会被执行。这个功能特别适合于实现像懒加载图片、无限滚动、动画触发等功能，而无需依赖繁重的滚动事件监听，从而提高页面性能和用户体验。</p><p>在你的代码示例中，<code>IntersectionObserver</code> 被用于监测一个名为 <code>.second</code> 的元素何时成为可见的，以及它的可见程度（即交叉比率）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondContainer = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> ob = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function"><span class="params">payload</span> =&gt;</span> &#123;</span><br><span class="line">  secondContainer = payload[<span class="number">0</span>].<span class="property">intersectionRatio</span> &gt; <span class="number">0.05</span>;</span><br><span class="line">&#125;, &#123; <span class="attr">threshold</span>: <span class="number">0.05</span> &#125;);</span><br><span class="line">ob.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.second&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>回调函数</strong>：当观察的元素进入或退出交叉区域时，回调函数会被调用。<code>payload</code> 参数（通常命名为 <code>entries</code>）是一个数组，包含了被观察元素的交叉状态信息。这个示例中只观察了一个元素，因此通过 <code>payload[0]</code> 访问了这个元素的信息。</li><li>**<code>intersectionRatio</code>**：这是一个 0 到 1 之间的值，表示观察的元素当前可见部分的比例。在这个例子中，如果这个比例大于 0.05，<code>secondContainer</code> 将被设置为 <code>true</code>，表示元素至少有 5% 是可见的。</li><li><strong>选项对象</strong>：在这个例子中，选项对象 <code>&#123; threshold: 0.05 &#125;</code> 指定了触发回调的交叉比率阈值。当元素的可见部分超过 5% 时，回调函数将被执行。<code>threshold</code> 可以是一个单一的值或一个值的数组，允许你在元素可见性达到多个不同级别时触发回调。</li><li><strong><code>.observe()</code> 方法</strong>：这个方法用于开始观察一个元素。在这里，它观察一个类名为 <code>.second</code> 的元素。当这个元素的可视状态发生变化，且满足设定的阈值时，将触发上面定义的回调函数。</li></ul><p>使用 <code>IntersectionObserver</code> 相比传统的滚动事件监听，可以大大减少对性能的影响，因为浏览器可以优化对交叉状态的检测，无需在每次滚动事件发生时执行复杂的计算。</p><h2 id="window-scroll"><a href="#window-scroll" class="headerlink" title="window.scroll"></a><code>window.scroll</code></h2><p><code>window.scroll(0, 0)</code> 是 JavaScript 中的一个方法调用，用于将浏览器窗口或标签页的滚动位置设置到页面的最顶部。这里的两个参数 <code>(0, 0)</code> 分别表示水平和垂直方向的滚动位置。</p><ul><li>第一个参数 <code>0</code> 表示在水平方向上的滚动距离。在这个例子中，<code>0</code> 意味着页面将滚动到最左边。</li><li>第二个参数 <code>0</code> 表示在垂直方向上的滚动距离。在这个例子中，<code>0</code> 意味着页面将滚动到最顶部。</li></ul><p>因此，调用 <code>window.scroll(0, 0)</code> 会使得页面滚动到左上角，即页面的起始位置。这个方法经常在需要将用户的视图重置到页面顶部的情况下使用，比如在用户点击“返回顶部”按钮时。</p><h2 id="动画位移"><a href="#动画位移" class="headerlink" title="动画位移"></a>动画位移</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 更新点光源的位置</span><br><span class="line">      fillLight.position.y -=</span><br><span class="line">        (parallaxY * 9 + fillLight.position.y - 2) * deltaTime</span><br><span class="line">      fillLight.position.x +=</span><br><span class="line">        (parallaxX * 8 - fillLight.position.x) * 2 * deltaTime</span><br><span class="line">      // 更新第一个相机所在相机组的位置</span><br><span class="line">      cameraGroup.position.z -=</span><br><span class="line">        (parallaxY / 3 + cameraGroup.position.z) * 2 * deltaTime</span><br><span class="line">      cameraGroup.position.x +=</span><br><span class="line">        (parallaxX / 3 - cameraGroup.position.x) * 2 * deltaTime</span><br></pre></td></tr></table></figure><p>这段代码通过结合用户输入（例如鼠标移动产生的视差效果，即 <code>parallaxX</code> 和 <code>parallaxY</code>）和时间变化量（<code>deltaTime</code>）来动态更新点光源和相机组的位置。这种方法可以创建平滑和响应式的动画效果，使得场景元素（如光源和相机）能够根据用户的交互或时间的推移进行移动。</p><p>这里使用的是一种常见的动画和模拟技术，即在每一帧根据时间差（<code>deltaTime</code>）调整位置，以实现平滑的运动效果。<code>deltaTime</code> 通常表示自上一帧以来经过的时间，用于确保动画的速度不受帧率变化的影响。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fillLight.<span class="property">position</span>.<span class="property">y</span> -= (parallaxY * <span class="number">9</span> + fillLight.<span class="property">position</span>.<span class="property">y</span> - <span class="number">2</span>) * deltaTime;</span><br><span class="line">fillLight.<span class="property">position</span>.<span class="property">x</span> += (parallaxX * <span class="number">8</span> - fillLight.<span class="property">position</span>.<span class="property">x</span>) * <span class="number">2</span> * deltaTime;</span><br></pre></td></tr></table></figure><ul><li>对于 <code>y</code> 轴位置，代码计算了一个目标值，这个目标值由 <code>parallaxY</code> 的9倍与光源当前 <code>y</code> 值与2的差值共同决定，然后通过 <code>deltaTime</code> 调整速度和平滑度。这样做的效果是让光源在垂直方向上根据视差值平滑移动，并且试图维持在一个<strong>相对于原点偏移2</strong>的位置。</li><li>对于 <code>x</code> 轴位置，类似地，目标位置由 <code>parallaxX</code> 的8倍减去当前 <code>x</code> 值决定，然后乘以2和 <code>deltaTime</code> 来调整。这让光源在水平方向上也根据视差值平滑地移动。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cameraGroup.<span class="property">position</span>.<span class="property">z</span> -= (parallaxY / <span class="number">3</span> + cameraGroup.<span class="property">position</span>.<span class="property">z</span>) * <span class="number">2</span> * deltaTime;</span><br><span class="line">cameraGroup.<span class="property">position</span>.<span class="property">x</span> += (parallaxX / <span class="number">3</span> - cameraGroup.<span class="property">position</span>.<span class="property">x</span>) * <span class="number">2</span> * deltaTime;</span><br></pre></td></tr></table></figure><ul><li>这里对相机组的 <code>z</code> 和 <code>x</code> 轴位置进行更新，逻辑类似于光源位置的更新，<strong>但视差值被除以3，意味着相对移动幅度更小</strong>，创建了一种不同的视差效果。这种效果通常用来给用户一种深度感，即背景元素相对于前景元素移动得更慢。</li></ul><p>？如何恰当的设置，在鼠标移动下，页面元素的流畅偏移效果</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.lds-roller div &#123;</span><br><span class="line">  animation: lds-roller 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;</span><br><span class="line">  transform-origin: 40px 40px;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段 CSS 代码定义了一个动画效果，通常用于创建加载指示器（如旋转的圆环或球）。让我们逐步解析这段代码的含义：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.lds-roller</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的选择器 <code>.lds-roller div</code> 指的是所有类名为 <code>lds-roller</code> 的元素内部的 <code>div</code> 元素。对这些 <code>div</code> 元素应用以下样式和动画。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: lds-roller <span class="number">1.2s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>) infinite;</span><br></pre></td></tr></table></figure><ul><li>**动画名称 (<code>lds-roller</code>)**：这是动画的关键帧名称，它引用了在某处定义的 <code>@keyframes lds-roller</code>，该关键帧定义了动画的开始、结束状态以及可能的中间状态。</li><li>**持续时间 (<code>1.2s</code>)**：动画从开始到结束的时长为 1.2 秒。</li><li>**缓动函数 (<code>cubic-bezier(0.5, 0, 0.5, 1)</code>)**：这是一个贝塞尔曲线，定义了动画的加速度曲线。这个特定的曲线意味着动画开始时加速度较快，结束时减速。这样可以让动画看起来更自然、流畅。</li><li>**重复次数 (<code>infinite</code>)**：动画会无限次重复。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: <span class="number">40px</span> <span class="number">40px</span>;</span><br></pre></td></tr></table></figure><ul><li>**变换原点 (<code>transform-origin</code>)**：这个属性定义了元素变形的原点。在这个例子中，原点被设置在了元素的 <code>40px 40px</code> 的位置，通常意味着元素的变换（如旋转）将围绕这个点进行。这个设置有助于创建环绕中心点旋转的效果，特别是当动画效果是旋转时。</li></ul><p>综上所述，这段 CSS 为 <code>.lds-roller</code> 内部的每个 <code>div</code> 应用了一个持续 1.2 秒、无限重复的平滑动画，该动画的具体行为由 <code>@keyframes lds-roller</code> 定义。动画的变换原点设置在每个 <code>div</code> 的 <code>40px 40px</code> 处，使得旋转动画能围绕该点进行，创建出一个加载动画的视觉效果。</p><p>为了完整地实现这个动画效果，你还需要定义相应的 <code>@keyframes lds-roller</code> 关键帧动画，指明动画开始、结束时，以及可能的中间步骤的具体样式变化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loadingCover.style.setProperty(</span><br><span class="line">              &#x27;transform&#x27;,</span><br><span class="line">              `translate(0,$&#123;yPosition.y&#125;%)`</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>loadingCover.style.setProperty</code> 方法被用于动态修改 <code>loadingCover</code> 元素的 CSS <code>transform</code> 属性。这个方法允许你直接通过 JavaScript 更改元素的样式，其中 <code>setProperty</code> 接受两个参数：第一个参数是要修改的 CSS 属性名称，第二个参数是该属性的新值。</p><ul><li><strong>第一个参数 (<code>transform</code>)</strong>: 指定了要修改的 CSS 属性，这里是 <code>transform</code>。<code>transform</code> 属性允许你对元素进行变形，比如旋转、缩放、移动（平移）或倾斜。</li><li><strong>第二个参数 (<code>translate(0,$&#123;yPosition.y&#125;%)</code>)</strong>: 是 <code>transform</code> 属性的新值，这里使用了 <code>translate</code> 函数来移动元素。<code>translate</code> 函数接受两个参数，分别对应 X 轴和 Y 轴的移动距离。在这个例子中，<code>translate(0,$&#123;yPosition.y&#125;%)</code> 表示在 X 轴方向上不移动（<code>0</code>），在 Y 轴方向上移动 <code>$&#123;yPosition.y&#125;%</code> 的距离，其中 <code>$&#123;yPosition.y&#125;</code> 是一个动态计算的值，表示移动距离的百分比。使用百分比单位可以根据元素大小的不同而相对地移动不同的距离。</li></ul><p>这段代码的目的是根据 <code>yPosition.y</code> 的值（可能是通过某些计算得到的），在 Y 轴方向上动态移动 <code>loadingCover</code> 元素。这种技术常用于创建动态的交互效果，比如根据用户的滚动或鼠标移动来移动页面上的元素，从而增加页面的动态性和互动性。</p><p>假设 <code>yPosition.y</code> 的值为 <code>50</code>，则 <code>translate(0,$&#123;yPosition.y&#125;%)</code> 将解析为 <code>translate(0,50%)</code>，意味着 <code>loadingCover</code> 元素将沿 Y 轴方向下移其高度的 50%。这样的移动效果可以用于各种动画和过渡效果，使得页面元素的移动看起来更平滑和自然。</p><h2 id="innerHeight-clientHeight"><a href="#innerHeight-clientHeight" class="headerlink" title="innerHeight, clientHeight"></a>innerHeight, clientHeight</h2><p>当想获取一个DOM元素的宽度和高度时，通常会使用 <code>clientHeight</code>和 <code>clientWidth</code>。这两个属性提供了元素的内部高度和宽度（包括填充，但不包括边框、滚动条或外边距）。</p><p>对于你的具体例子，如果你需要在组件挂载后获取这个 <code>div</code>元素的宽度和高度，</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> container = <span class="title function_">ref</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (container.<span class="property">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Width:&#x27;</span>, container.<span class="property">value</span>.<span class="property">clientWidth</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Height:&#x27;</span>, container.<span class="property">value</span>.<span class="property">clientHeight</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fullSize&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>clientHeight</strong>：元素的内部高度（包括padding，但不包括水平滚动条、border和margin）。</li><li><strong>clientWidth</strong>：元素的内部宽度（同样，包括padding但不包括垂直滚动条、border和margin）。</li><li><strong>offsetHeight</strong>：元素的外部高度（包括padding、border和水平滚动条，但不包括margin）。</li><li><strong>offsetWidth</strong>：元素的外部宽度（包括padding、border和垂直滚动条，但不包括margin）。</li><li><strong>scrollHeight</strong>和<strong>scrollWidth</strong>：包括了因为滚动而不可见内容的整体尺寸。</li></ul><p>通常来说，<code>clientHeight</code>和 <code>clientWidth</code>是获取元素可见部分尺寸的最常用属性。如果你的 <code>div</code>具有滚动条，或者你关心内容溢出的情况，<code>scrollHeight</code>和 <code>scrollWidth</code>也可能是有用的。如果需要考虑元素的边框，在某些情况下可能会选择使用 <code>offsetHeight</code>和 <code>offsetWidth</code>。</p><p>在Web开发中，<code>innerHeight</code> 并不是一个用来获取DOM元素尺寸的属性；而是一个属于 <code>window</code>对象的属性，它表示浏览器窗口的视图区域（视口）的高度，包括水平滚动条（如果存在的话）。</p><p><code>window.innerHeight</code> 通常用于处理与视口大小相关的逻辑，如下几种典型用途：</p><ol><li><strong>响应式设计</strong>：JavaScript中可以使用 <code>window.innerHeight</code>来帮助确定浏览器窗口的当前高度，进而调整网页布局或功能以适应不同的显示设备。</li><li><strong>触发特定的行为</strong>：当用户缩放浏览器窗口至某个特定的尺寸时，你可能希望根据窗口的大小改变来触发某些行为或动画。</li><li><strong>无限滚动</strong>：在实现无限滚动的网页中，<code>window.innerHeight</code> 可以用来计算用户何时接近底部，从而在用户滚动到页面底部之前加载更多内容。</li><li><strong>全屏元素显示</strong>：如果你想要某个元素（如视频、图片展示等）全屏显示，<code>window.innerHeight</code> 可以帮助你设置元素的高度，使之完全填充用户的视口。</li></ol><p>下面是一个示例代码，展示如何使用 <code>window.innerHeight</code>来调整一个元素的高度使其总是占满整个视口：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.full-height</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: lightblue; <span class="comment">/* 易于视觉识别的颜色 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;full-height&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fullHeightDiv&quot;</span>&gt;</span></span><br><span class="line">  这个div高度将填满视口</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">adjustHeight</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fullHeightDiv&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">style</span>.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = adjustHeight;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onresize</span> = adjustHeight; <span class="comment">// 确保在窗口尺寸变化时更新高度</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tween的销毁"><a href="#tween的销毁" class="headerlink" title="tween的销毁"></a>tween的销毁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new TWEEN.Tween(yPosition)</span><br><span class="line">          .to(&#123; y: 100 &#125;, 900)</span><br><span class="line">          .easing(TWEEN.Easing.Quadratic.InOut)</span><br><span class="line">          .start()</span><br><span class="line">          .onUpdate(() =&gt; &#123;</span><br><span class="line">            loadingCover.style.setProperty(</span><br><span class="line">              &#x27;transform&#x27;,</span><br><span class="line">              `translate(0,$&#123;yPosition.y&#125;%)`</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">          .onComplete(() =&gt; &#123;</span><br><span class="line">            loadingCover.parentNode.removeChild(</span><br><span class="line">              document.getElementById(&#x27;loading-text-intro&#x27;)</span><br><span class="line">            ) // 写loadingCover会报空</span><br><span class="line">            TWEEN.remove(this)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><h3 id="tween-getId-is-not-a-function-错误"><a href="#tween-getId-is-not-a-function-错误" class="headerlink" title="tween.getId is not a function 错误"></a><code>tween.getId is not a function</code> 错误</h3><p>这个错误提示表明，尝试调用的 <code>getId</code> 方法不存在于 <code>tween</code> 对象上。在你的代码中，错误来源于 <code>TWEEN.remove(this)</code> 这行代码。这里的问题是 <code>this</code> 在 <code>onComplete</code> 回调函数中不指向你期望的 tween 对象。在 ES6 的箭头函数中，<code>this</code> 关键字并不会绑定到外围的上下文，而是继承自它所在的上一层作用域。这意味着这里的 <code>this</code> 不是指向 Tween 实例，而可能是指向了全局对象或者 <code>undefined</code>（严格模式下）。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了正确地移除 tween，你可以直接引用 tween 实例本身而不是使用 <code>this</code>。不过，从你的代码来看，并没有直接的引用。通常，如果你需要在回调中引用 tween，可以事先将其存储在一个变量中。但 <code>TWEEN.js</code> 库通常自我管理所有 tween 的生命周期，包括它们的添加和移除，所以手动调用 <code>remove</code> 方法可能并不是必须的。如果你确实需要移除 tween，考虑调整你的代码逻辑，避免在这种上下文中使用 <code>this</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const tween1 = new TWEEN.Tween(yPosition)</span><br><span class="line">          .to(&#123; y: 100 &#125;, 900)</span><br><span class="line">          .easing(TWEEN.Easing.Quadratic.InOut)</span><br><span class="line">          .start()</span><br><span class="line">          .onUpdate(() =&gt; &#123;</span><br><span class="line">            loadingCover.style.setProperty(</span><br><span class="line">              &#x27;transform&#x27;,</span><br><span class="line">              `translate(0,$&#123;yPosition.y&#125;%)`</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">          .onComplete(() =&gt; &#123;</span><br><span class="line">            loadingCover.parentNode.removeChild(</span><br><span class="line">              document.getElementById(&#x27;loading-text-intro&#x27;)</span><br><span class="line">            ) // 写loadingCover会报空</span><br><span class="line">            TWEEN.remove(tween1)</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        const tween2 = new TWEEN.Tween(camera1.position.set(0, 4, 2))</span><br><span class="line">          .to(&#123; x: 0, y: 2.4, z: 5.8 &#125;, 3500)</span><br><span class="line">          .easing(TWEEN.Easing.Quadratic.InOut)</span><br><span class="line">          .start()</span><br><span class="line">          .onComplete(() =&gt; &#123;</span><br><span class="line">            TWEEN.remove(tween2)</span><br><span class="line">            document.querySelector(&#x27;.header&#x27;).classList.add(&#x27;ended&#x27;)</span><br><span class="line">            document.querySelector(&#x27;.description&#x27;).classList.add(&#x27;ended&#x27;)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><h2 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const loadingCover = document.getElementById(&#x27;loading-text-intro&#x27;)</span><br><span class="line"></span><br><span class="line">        const tween1 = new TWEEN.Tween(yPosition)</span><br><span class="line">          .to(&#123; y: 100 &#125;, 900)</span><br><span class="line">          .easing(TWEEN.Easing.Quadratic.InOut)</span><br><span class="line">          .start()</span><br><span class="line">          .onUpdate(() =&gt; &#123;</span><br><span class="line">            loadingCover.style.setProperty(</span><br><span class="line">              &#x27;transform&#x27;,</span><br><span class="line">              `translate(0,$&#123;yPosition.y&#125;%)`</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">          .onComplete(() =&gt; &#123;</span><br><span class="line">            loadingCover.parentNode.removeChild(</span><br><span class="line">              document.getElementById(&#x27;loading-text-intro&#x27;)</span><br><span class="line">            ) // 写loadingCover会报空</span><br><span class="line">            TWEEN.remove(tween1)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><p><code>Cannot read properties of null (reading &#39;removeChild&#39;)</code> 错误</p><blockquote><p>这个错误表明你尝试从一个 <code>null</code> 对象中调用 <code>removeChild</code> 方法。这通常发生在尝试访问或修改已经被移除或未被正确初始化的 DOM 元素时。在你的代码中，这个问题出现在尝试移除 <code>loadingCover</code> 元素的代码块中。</p></blockquote><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>在尝试移除 <code>loadingCover</code> 之前，确保它存在。这个问题可能出现是因为 <code>loadingCover</code> 为 <code>null</code>，意味着 <code>document.querySelector(&#39;#loading-text-intro&#39;)</code> 没有找到匹配的元素。这可能是因为元素的 ID 错误，或者这段代码执行的时候，对应的 DOM 元素还没有加载到页面上。</p><p>你可以通过在尝试访问或修改元素之前检查它是否存在来解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (loadingCover &amp;&amp; loadingCover.parentNode) &#123;</span><br><span class="line">    loadingCover.parentNode.removeChild(loadingCover);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合以上，你的问题可能是由于对 <code>this</code> 的误用和对 DOM 元素存在性的假设未经验证造成的。正确地引用变量和确保 DOM 元素存在，可以解决这些问题。</p><p><code>document.querySelector</code> 和 <code>document.getElementById</code> 都是用来从 DOM 中获取元素的方法，但它们之间有一些关键的区别：</p><p><code>document.querySelector</code></p><ul><li><code>querySelector</code> 方法可以接受任何 CSS 选择器作为参数，这意味着它非常灵活。你可以用它来获取类、ID、属性选择器等指定的元素。</li><li>如果有多个元素匹配给定的选择器，<code>querySelector</code> 只会返回第一个匹配的元素。</li><li>由于它接受任何 CSS 选择器，所以相对来说，执行速度会比 <code>getElementById</code> 慢一些。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#a&#x27;</span>); <span class="comment">// 使用 # 来指定它是一个 ID</span></span><br></pre></td></tr></table></figure><p><code>document.getElementById</code></p><ul><li><code>getElementById</code> 方法仅接受一个 ID 作为参数，并返回具有该 ID 的元素。</li><li>它是直接根据 ID 来获取元素，不需要指定任何前缀，因为 ID 在 HTML 文档中应该是唯一的。</li><li><code>getElementById</code> 通常比 <code>querySelector</code> 更快，因为它专门用于通过 ID 查找元素，而 ID 在 DOM 中是唯一的。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果你需要通过 ID 获取元素，并且对性能有一定要求，<code>getElementById</code> 是一个更好的选择。如果你需要更多的选择器灵活性（例如，通过类名、属性等获取元素），则应使用 <code>querySelector</code>。</p><ul><li><strong>性能</strong>：对于通过 ID 获取单个元素的情况，<code>getElementById</code> 的性能通常更优。</li><li><strong>灵活性</strong>：<code>querySelector</code> 提供了更高的灵活性，可以使用任何有效的 CSS 选择器语法。</li></ul><p>在大多数现代浏览器中，对于简单的 DOM 操作，这两种方法的性能差异几乎可以忽略不计。因此，你可以根据具体需求和个人偏好来选择使用哪种方法。</p><h2 id="加载压缩过的glb"><a href="#加载压缩过的glb" class="headerlink" title="加载压缩过的glb"></a>加载压缩过的glb</h2><p>THREE .DRACOLoader: Unexpected geometrytype 错误解决</p><blockquote><p><a href="https://blog.csdn.net/iefreer/article/details/131113390">https://blog.csdn.net/iefreer/article/details/131113390</a></p><p>npm i draco3d</p><p>npm i draco3dgltf</p><p><a href="https://segmentfault.com/q/1010000043706931">https://segmentfault.com/q/1010000043706931</a></p><p>原因：<code>是draco版本与项目安装的three版本不对</code><br>解决方法：以vite脚手架为例 <code>node_modules\three\examples\jsm\libs\</code> 下的darco文件夹拷贝到 <code>public\&lt;span&gt; &lt;/span&gt;</code>下，之后报错就解决了。</p></blockquote><h3 id="DRACO验证"><a href="#DRACO验证" class="headerlink" title="DRACO验证"></a>DRACO验证</h3><p>检查一个模型是否包含了 Draco 压缩的几何数据，</p><ul><li><strong>使用 glTF Validator</strong>：你可以使用 <a href="https://github.khronos.org/glTF-Validator/">glTF Validator</a> 来检查你的 <code>.glb</code> 文件。这是一个由 Khronos Group 提供的工具，专门用于验证 glTF 文件的正确性。如果你的文件使用了 Draco 压缩，验证结果会显示相关信息。</li><li><strong>查看文件内容</strong>：高级用户可以直接查看 GLB 文件的内容（例如，使用十六进制编辑器），寻找 Draco 压缩的标记或结构。这种方法需要对 GLB 文件格式和 Draco 压缩有较深的了解。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;statue.glb&quot;,</span><br><span class="line">    &quot;mimeType&quot;: &quot;model/gltf-binary&quot;,</span><br><span class="line">    &quot;validatorVersion&quot;: &quot;2.0.0-dev.3.8&quot;,</span><br><span class="line">    &quot;validatedAt&quot;: &quot;2024-04-05T13:03:15.754Z&quot;,</span><br><span class="line">    &quot;issues&quot;: &#123;</span><br><span class="line">        &quot;numErrors&quot;: 0,</span><br><span class="line">        &quot;numWarnings&quot;: 0,</span><br><span class="line">        &quot;numInfos&quot;: 3,</span><br><span class="line">        &quot;numHints&quot;: 0,</span><br><span class="line">        &quot;messages&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;code&quot;: &quot;UNSUPPORTED_EXTENSION&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;Cannot validate an extension as it is not supported by the validator: &#x27;KHR_draco_mesh_compression&#x27;.&quot;,</span><br><span class="line">                &quot;severity&quot;: 2,</span><br><span class="line">                &quot;pointer&quot;: &quot;/extensionsUsed/0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;code&quot;: &quot;UNUSED_OBJECT&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;This object may be unused.&quot;,</span><br><span class="line">                &quot;severity&quot;: 2,</span><br><span class="line">                &quot;pointer&quot;: &quot;/meshes/0/primitives/0/attributes/TEXCOORD_0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;code&quot;: &quot;UNUSED_OBJECT&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;This object may be unused.&quot;,</span><br><span class="line">                &quot;severity&quot;: 2,</span><br><span class="line">                &quot;pointer&quot;: &quot;/bufferViews/0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;truncated&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;info&quot;: &#123;</span><br><span class="line">        &quot;version&quot;: &quot;2.0&quot;,</span><br><span class="line">        &quot;generator&quot;: &quot;Khronos glTF Blender I/O v1.8.19&quot;,</span><br><span class="line">        &quot;extensionsUsed&quot;: [</span><br><span class="line">            &quot;KHR_draco_mesh_compression&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;extensionsRequired&quot;: [</span><br><span class="line">            &quot;KHR_draco_mesh_compression&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;resources&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pointer&quot;: &quot;/buffers/0&quot;,</span><br><span class="line">                &quot;mimeType&quot;: &quot;application/gltf-buffer&quot;,</span><br><span class="line">                &quot;storage&quot;: &quot;glb&quot;,</span><br><span class="line">                &quot;byteLength&quot;: 697820</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;animationCount&quot;: 0,</span><br><span class="line">        &quot;materialCount&quot;: 1,</span><br><span class="line">        &quot;hasMorphTargets&quot;: false,</span><br><span class="line">        &quot;hasSkins&quot;: false,</span><br><span class="line">        &quot;hasTextures&quot;: false,</span><br><span class="line">        &quot;hasDefaultScene&quot;: true,</span><br><span class="line">        &quot;drawCallCount&quot;: 1,</span><br><span class="line">        &quot;totalVertexCount&quot;: 141741,</span><br><span class="line">        &quot;totalTriangleCount&quot;: 264708,</span><br><span class="line">        &quot;maxUVs&quot;: 1,</span><br><span class="line">        &quot;maxInfluences&quot;: 0,</span><br><span class="line">        &quot;maxAttributes&quot;: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从你通过 glTF Validator 获取的信息中，我们可以了解到以下几点关于你的模型 <code>statue.glb</code>：</p><ol><li>基本信息</li></ol><ul><li><strong>文件类型</strong>：模型是一个二进制的 glTF 文件（GLB）。</li><li><strong>验证器版本</strong>：使用的 glTF Validator 版本为 2.0.0-dev.3.8。</li><li><strong>验证时间</strong>：文件在 2024-04-05T13:03:15.754Z 被验证。</li></ul><ol start="2"><li>问题报告</li></ol><ul><li><strong>错误数量</strong>：0，表示文件没有违反 glTF 2.0 规范的错误。</li><li><strong>警告数量</strong>：0，没有发现可能影响性能或兼容性的问题。</li><li><strong>信息数量</strong>：3，提供了一些关于模型的额外信息但不影响模型的使用。</li><li><strong>提示数量</strong>：0，没有给出优化建议。</li></ul><ol start="3"><li>具体消息</li></ol><ul><li><strong>UNSUPPORTED_EXTENSION</strong>：模型使用了 <code>KHR_draco_mesh_compression</code> 扩展进行 Draco 压缩，但 glTF Validator 不支持验证这个扩展的具体内容。这说明你的模型确实使用了 Draco 压缩。</li><li><strong>UNUSED_OBJECT</strong>：有两个未使用的对象，一个是纹理坐标 <code>TEXCOORD_0</code>，另一个是 <code>bufferViews[0]</code>。这可能意味着模型中包含了一些未被引用的数据，这通常不影响模型的使用，但可能稍微增加了文件的大小。</li></ul><ol start="4"><li>模型信息</li></ol><ul><li><strong>glTF 版本</strong>：2.0。</li><li><strong>创建工具</strong>：使用了 Khronos glTF Blender I&#x2F;O v1.8.19 创建。</li><li><strong>扩展使用和要求</strong>：模型使用并要求 <code>KHR_draco_mesh_compression</code> 扩展，证实了模型经过了 Draco 压缩。</li><li><strong>资源信息</strong>：包含一个 buffer，大小为 697820 字节。</li><li><strong>动画、材质、顶点和三角形数量</strong>：模型没有动画，有 1 个材质，共有 141741 个顶点和 264708 个三角形。</li></ul><p>你的模型 <code>statue.glb</code> 成功使用了 Draco 压缩（通过 <code>KHR_draco_mesh_compression</code> 扩展），且没有发现任何违反 glTF 规范的错误。未使用的对象（如某些纹理坐标和 bufferViews）可能是导出过程中产生的，通常不会影响模型的渲染或使用。如果你关心文件大小，可以考虑优化这些未使用的数据。</p><p>这个报告也确认了你遇到的问题不是由文件损坏或不符合 glTF 规范造成的，可能需要在加载或渲染过程中进一步调查问题的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;光影人物&quot;&gt;&lt;a href=&quot;#光影人物&quot; class=&quot;headerlink&quot; title=&quot;光影人物&quot;&gt;&lt;/a&gt;光影人物&lt;/h1&gt;&lt;p&gt;参考教程：&lt;a href=&quot;https://juejin.cn/post/7145064095178293285&quot;&gt;http</summary>
      
    
    
    
    <category term="3d" scheme="https://youxt-njnu.github.io/categories/3d/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
    <category term="vue" scheme="https://youxt-njnu.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>demo| 数字地球星空</title>
    <link href="https://youxt-njnu.github.io/2024/03/23/three-demo-%E6%95%B0%E5%AD%97%E5%9C%B0%E7%90%83/"/>
    <id>https://youxt-njnu.github.io/2024/03/23/three-demo-%E6%95%B0%E5%AD%97%E5%9C%B0%E7%90%83/</id>
    <published>2024-03-23T04:02:05.000Z</published>
    <updated>2024-10-06T02:37:37.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字地球星空"><a href="#数字地球星空" class="headerlink" title="数字地球星空"></a>数字地球星空</h1><p>参考教程：<a href="https://juejin.cn/post/7145064095178293285">https://juejin.cn/post/7145064095178293285</a></p><ol><li>构建（线框风的地球earth、）环ring、卫星satellite</li><li>构建500个随机分布的星星stars</li><li>初始化场景，设置光照，关联dom</li><li>加载地球的模型和贴图</li><li>添加动画</li></ol><h2 id="页面中不显示canvas的内容"><a href="#页面中不显示canvas的内容" class="headerlink" title="页面中不显示canvas的内容"></a><strong>页面中不显示canvas的内容</strong></h2><ol><li>检查对应的template里的div元素的大小，如果设置不当，就看不到物体；</li><li>如果没有把下面的代码放到init里，这个时候container的div还没有创建，获取不到对应的宽高</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sizes = &#123;</span><br><span class="line">  <span class="attr">width</span>: container.<span class="property">clientWidth</span>,</span><br><span class="line">  <span class="attr">height</span>: container.<span class="property">clientHeight</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面中看不到物体"><a href="#页面中看不到物体" class="headerlink" title="页面中看不到物体"></a><strong>页面中看不到物体</strong></h2><ol><li>确认设置了div的大小: 如果 <code>container</code>的大小为0或非常小，那么 <code>Three.js</code>渲染的内容可能就无法被看到。确保 <code>.fullSize</code>样式被正确应用，并且容器元素确实覆盖了可见区域</li><li>确定场景的材质颜色不和背景一样</li><li>确认材质是否需要加光照</li><li>调整相机.lookAt() : 如果场景中没有添加任何可见物体或者物体和摄像机的位置设置不当，可能导致看不到任何内容。试着添加一个简单的几何体，确保它在摄像机视野内</li><li>调整物体.position.set()</li><li>调整相机的位置.position.set()</li><li>调整物体的大小 size</li><li><strong>渲染调用时机</strong> ：你在 <code>initThree</code>函数中只调用了一次 <code>renderer.render(scene, camera)</code>，这意味着场景只渲染了一次，且在没有添加环境纹理之前。通常，我们会在添加完所有初次所需的场景内容后再进行渲染，或者使用动画循环（如 <code>requestAnimationFrame</code>）不断渲染场景。</li></ol><p>此外，从vue迁移到react里的时候，原先是通过下面来实现的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renderer = new Three.WebGLRenderer(&#123; alpha: true, antialias: true &#125;)</span><br><span class="line">renderer.setSize(sizes.width, sizes.height)</span><br><span class="line">container.current.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>但搬过来就实现不了了，需要使用这样子实现；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renderer = new Three.WebGLRenderer(&#123; canvas: container.current, alpha: true, antialias: true &#125;)</span><br><span class="line">renderer.setSize(sizes.width, sizes.height)</span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><p>但又会报这种错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-A6I3RWFE.js?v=776dc4a7:16638 Uncaught TypeError: Cannot read properties of null (reading &#x27;matrixWorldAutoUpdate&#x27;)</span><br><span class="line">    at WebGLRenderer.render (chunk-KKQC3OGW.js?v=776dc4a7:17854:17)</span><br><span class="line">    at initThree (EarthStar.jsx:47:14)</span><br><span class="line">    at EarthStar.jsx:120:5</span><br><span class="line">    at commitHookEffectListMount (chunk-A6I3RWFE.js?v=776dc4a7:16883:34)</span><br><span class="line">    at commitPassiveMountOnFiber (chunk-A6I3RWFE.js?v=776dc4a7:18124:19)</span><br><span class="line">    at commitPassiveMountEffects_complete (chunk-A6I3RWFE.js?v=776dc4a7:18097:17)</span><br><span class="line">    at commitPassiveMountEffects_begin (chunk-A6I3RWFE.js?v=776dc4a7:18087:15)</span><br><span class="line">    at commitPassiveMountEffects (chunk-A6I3RWFE.js?v=776dc4a7:18077:11)</span><br><span class="line">    at flushPassiveEffectsImpl (chunk-A6I3RWFE.js?v=776dc4a7:19458:11)</span><br><span class="line">    at flushPassiveEffects (chunk-A6I3RWFE.js?v=776dc4a7:19415:22)</span><br></pre></td></tr></table></figure><p>需要把<code>renderer.render(scene, camera);</code>放到scene初始化的后面；</p><p>此外，需要放在scene添加模型之后，这样子模型才会被渲染到场景里；</p><h2 id="Uncaught-TypeError-Cannot-read-properties-of-null-reading-‘width’"><a href="#Uncaught-TypeError-Cannot-read-properties-of-null-reading-‘width’" class="headerlink" title="Uncaught TypeError: Cannot read properties of null (reading ‘width’)"></a><strong>Uncaught TypeError: Cannot read properties of null (reading ‘width’)</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sizes = &#123;</span><br><span class="line">  <span class="attr">width</span>: container.<span class="property">width</span>,</span><br><span class="line">  <span class="attr">height</span>: container.<span class="property">height</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你看到错误消息 “Uncaught TypeError: Cannot read properties of null (reading ‘width’)”，这表明你试图访问的对象（在这个例子中是 <code>container</code>）为 <code>null</code>。这通常发生在尝试访问一个DOM元素的属性，但该元素在代码执行时还未被成功选中或者根本不存在于DOM中。</p><p>改用 <code>.clientWidth</code>和 <code>.clientHeight</code>是正确的修正方式，但前提是你首先需要确保 <code>container</code>不是 <code>null</code>。这两个属性是DOM元素的标准属性，分别表示元素的内部宽度（不包括边框）和高度，适用于获取元素的可视尺寸。</p><p>你可以通过以下步骤确保 <code>container</code>已正确选中并非 <code>null</code>：</p><ol><li>确保你的代码在DOM元素实际被加载到页面上之后执行。如果你的代码在元素被加载之前执行，那么即使选择器正确，也会返回 <code>null</code>。通常，将JavaScript代码放在文档的底部，或者使用 <code>document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123; /* 代码 */ &#125;)</code>来确保在DOM完全加载后再运行代码。</li><li>检查选择器是否正确。确保你用来选中 <code>container</code>的选择器（比如ID或类名）是正确的，并且与HTML中的元素匹配。</li></ol><p>使用 <code>container.width</code> 不适用于 <code>div</code> 元素，因为 <code>div</code> 没有 <code>width</code> 属性。<code>width</code> 属性通常用于 <code>canvas</code>、<code>img</code> 等元素，这些元素具有直接可读写的宽度和高度属性。对于 <code>div</code> 和其他没有宽高属性的块级元素，你需要使用 <code>clientWidth</code> 和 <code>clientHeight</code> 来获取它们的视觉呈现尺寸，这些尺寸包括了元素的内边距（padding）但不包括边框（border）和滚动条。</p><p>这就是为什么在Three.js中，当你设置相机参数的时候需要使用 <code>container.clientWidth</code> 和 <code>container.clientHeight</code> 而不是 <code>container.width</code> 和 <code>container.height</code>：</p><ul><li><code>clientWidth</code> 和 <code>clientHeight</code> 给你提供了元素的实际内容区域的尺寸，这对于Three.js中确保相机的长宽比与渲染容器匹配是非常重要的。</li><li>这些属性反映了 <code>&lt;div&gt;</code>容器当前的大小，包括任何由于页面布局或样式动态变化导致的尺寸更改。</li><li>如果使用 <code>width</code> 和 <code>height</code>，你可能会得到 <code>undefined</code>，因为这不是标准的 <code>div</code> 属性，这会导致你的相机设置不正确。</li></ul><h2 id="动画中位置的设置"><a href="#动画中位置的设置" class="headerlink" title="动画中位置的设置"></a>动画中位置的设置</h2><p>在threejs中设置动画里面，satellite模型的位置如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">satellite.<span class="property">position</span>.<span class="title function_">set</span>(</span><br><span class="line">        <span class="number">140</span> * <span class="title class_">Math</span>.<span class="title function_">cos</span>(radian),</span><br><span class="line">        <span class="number">50</span> * <span class="title class_">Math</span>.<span class="title function_">sin</span>(radian),</span><br><span class="line">        <span class="number">20</span> * <span class="title class_">Math</span>.<span class="title function_">sin</span>(radian)</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rot += <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">0.8</span></span><br><span class="line"><span class="keyword">let</span> radian = (<span class="title class_">Math</span>.<span class="property">PI</span> * rot) / <span class="number">180</span></span><br></pre></td></tr></table></figure><p>为什么satellite动画的位置要这么设置</p><p>在这段代码中，<code>satellite.position.set(x, y, z)</code> 正在设置卫星模型在三维空间中的位置，其中 <code>x</code>，<code>y</code>，和 <code>z</code> 是根据一定规则计算出来的坐标值。这些值是通过正弦（<code>sin</code>）和余弦（<code>cos</code>）函数的变化来动态计算的，这些函数是从圆和波的几何关系中派生出来的，因此它们非常适合用于创建循环和振荡的动画效果，如卫星绕地球运行的轨迹。</p><ul><li><code>140 * Math.cos(radian)</code> 是在计算卫星在x轴上的位置。使用余弦函数意味着卫星在x轴上的运动会形成一个正弦波，其值在-140到+140之间变化，创建了水平方向上的循环运动。</li><li><code>50 * Math.sin(radian)</code> 是在计算卫星在y轴上的位置。正弦函数决定了卫星在垂直方向上的运动，创建了一个范围在-50到+50之间的波动。</li><li><code>20 * Math.sin(radian)</code> 是在计算卫星在z轴上的位置。这同样使用了正弦函数，但是影响卫星在“深度”方向上的运动。这个值的变化范围在-20到+20之间，这个变化范围小于y轴，意味着在这个方向上的振动幅度较小。</li><li><code>rot += Math.random() * 0.8</code> 这部分代码是为了在每次动画循环时增加 <code>rot</code>的值，而且每次增加的值是随机的，最大不超过0.8度。这将为卫星运动添加一个随机性，使其轨迹更加自然，而不是完美的圆形或者规则循环。</li><li><code>let radian = (Math.PI * rot) / 180</code> 这行将角度 <code>rot</code>转换为弧度。</li></ul><p>为什么x轴使用 <code>Math.cos</code> 而y轴和z轴使用 <code>Math.sin</code> 呢？这是因为在2D参数化曲线中，常常使用 <code>cos(t)</code> 表示x坐标，<code>sin(t)</code> 表示y坐标，这样可以创建一个圆。在三维空间中，我们可以使用相同的正弦函数来控制另外两个维度（在这种情况下是y和z），这样我们可以将2D圆形运动扩展到3D空间。</p><p>通过这样设置，你可以让卫星在x和y轴上做圆周运动，而z轴的运动则创建了高度的变化，这可以模拟例如倾斜的轨道或者其它不同于标准圆形轨道的路径。通过改变各轴上正弦和余弦函数前的系数，可以创建出不同的椭圆轨道，这就是为什么在不同轴上的运动使用不同的正弦余弦值，以及它们前面的系数不同。</p><p><img src="https://s2.loli.net/2024/03/25/Ioq7PRSjt3cJ8mG.png"></p><h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>通过设置相机，可以改变物体呈现的角度，也就是在调整物体位置的方案之外，也可以调整相机的位置。</p><h2 id="外部资源加载"><a href="#外部资源加载" class="headerlink" title="外部资源加载"></a>外部资源加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EarthStar.jsx:69 THREE.OBJLoader: Unexpected line: &quot;&lt;!DOCTYPE html&gt;&quot;</span><br><span class="line">Promise.then</span><br><span class="line">(anonymous)@EarthStar.jsx:69</span><br><span class="line">Promise.then</span><br><span class="line">EarthStar@EarthStar.jsx:64</span><br><span class="line">Show 20 more frames</span><br></pre></td></tr></table></figure><p>需要将模型放到public目录里面，同时vite.config.js的配置里加入：<code>assetsInclude: [&#39;**/*.glb&#39;, &#39;**/*.mtl&#39;, &#39;**/*.gltf&#39;],</code></p><hr><p>如果你在使用 Vite 和 Vue，并且看到网络请求的状态码为 <code>304 Not Modified</code>，这意味着浏览器已经缓存了 <code>earth.obj</code> 文件，并且服务器告诉浏览器自从上次请求以来文件没有被修改，所以浏览器可以使用本地缓存的版本。</p><p>但是，如果你遇到 <code>THREE.OBJLoader: Unexpected line: &quot;&lt;!doctype html&gt;&quot;</code> 的警告，那说明 OBJLoader 实际上解析到的是一个 HTML 文件，而不是 OBJ 文件。这通常说明在请求OBJ文件时发生了错误，服务器返回了一个HTML错误页面而不是文件内容。</p><p>由于你看到的是304状态码，而不是200或404，这表明可能存在以下情况：</p><ol><li><strong>Vite的静态文件处理</strong> ：Vite在开发模式下可能对静态资源的处理有所不同，确保 <code>earth.obj</code>文件放在了 <code>public</code>目录下，而不是 <code>src</code>目录下。在Vite中，<code>public</code>目录下的文件不会被处理，可以直接访问。</li><li><strong>缓存问题</strong> ：可能浏览器缓存了错误的内容。尝试清除浏览器缓存，或者在开发者工具中禁用缓存（在Network标签页，勾选Disable cache），然后再次加载页面。</li><li><strong>错误页面</strong> ：尽管状态码为304，但是如果服务器在之前的请求中返回了错误，浏览器可能缓存了错误页面。检查Vite服务器的配置或控制台输出以确定是否有错误。</li><li><strong>正确的MIME类型</strong> ：Vite应该自动为 <code>.obj</code>文件提供正确的MIME类型，但是如果有什么配置不当，可能需要手动检查。</li></ol><p>在你的 Vite 项目中，assetsInclude 的配置项用于指定哪些额外的文件类型应被视为静态资源进行处理。默认情况下，Vite 已经内置了对常见的静态资源文件类型的处理，如图片和媒体文件。对于 3D 模型文件如 .glb、.gltf、.obj 和 .mtl，需要特别指定，以便 Vite 能够正确地处理它们。</p><p>你提到 .glb 类型的模型可以正常加载，而其他类型的模型需要放到 public 目录下才可以正常加载，这可能与几个因素有关：</p><ul><li><p>Vite 配置：确保 assetsInclude 的路径匹配是正确的。你的配置已经包括了对这些文件类型的全局匹配。检查是否有任何拼写错误或路径错误。通配符 **&#x2F;* 表示匹配任意深度的文件夹中的指定文件类型。</p></li><li><p>模块解析：Vite 在开发环境下使用 JavaScript 模块解析来处理资源。如果你的 .obj 或 .mtl 文件没有被正确地识别为模块，它们可能不会通过 Vite 的处理流程。确保这些文件在导入时的路径是正确的，并且相对于项目的根目录。</p></li><li><p>资源引用：检查在项目中引用这些资源的方式。如果你是使用 ES 模块语法（如 import model from ‘.&#x2F;path&#x2F;to&#x2F;model.obj’），Vite 将尝试将其视为模块来处理。如果资源没有按预期处理，可能需要调整引用方式或确认文件路径是否正确。</p></li><li><p>缓存问题：有时候，开发服务器的缓存可能导致资源加载行为不一致。尝试清除缓存或重启 Vite 服务器看是否有改进。</p></li><li><p>Vite 插件：对于一些特殊类型的文件，可能需要使用特定的 Vite 插件来支持。例如，对于 3D 模型文件，你可能需要使用适合处理这些文件的插件。</p></li></ul><p>最后通过import方式引入，就可以了，不需要放到public目录里了；</p><p>但打包的时候，也可能会被忽略（参考你不得以放进去的gltfModels文件夹???</p><h2 id="球体贴图没贴上"><a href="#球体贴图没贴上" class="headerlink" title="球体贴图没贴上"></a>球体贴图没贴上</h2><p>mtl文件里关联了贴图，所以贴图也要一起拷贝过来；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字地球星空&quot;&gt;&lt;a href=&quot;#数字地球星空&quot; class=&quot;headerlink&quot; title=&quot;数字地球星空&quot;&gt;&lt;/a&gt;数字地球星空&lt;/h1&gt;&lt;p&gt;参考教程：&lt;a href=&quot;https://juejin.cn/post/71450640951782932</summary>
      
    
    
    
    <category term="3d" scheme="https://youxt-njnu.github.io/categories/3d/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
    <category term="vue" scheme="https://youxt-njnu.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/</id>
    <published>2024-03-17T01:33:26.000Z</published>
    <updated>2024-03-17T01:42:27.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="11-对象"><a href="#11-对象" class="headerlink" title="11. 对象"></a>11. 对象</h2><ul><li><p><strong>利用字面量创建对象</strong></p><h5 id="使用对象字面量创建对象："><a href="#使用对象字面量创建对象：" class="headerlink" title="使用对象字面量创建对象："></a><strong>使用对象字面量创建对象</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就是花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法；&#123; &#125; 里面采取键值对的形式表示 </span><br></pre></td></tr></table></figure><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var star = &#123;</span><br><span class="line">    name : &#x27;pink&#x27;,</span><br><span class="line">    age : 18,</span><br><span class="line">    sex : &#x27;男&#x27;,</span><br><span class="line">    sayHi : function()&#123;</span><br><span class="line">        alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中 star即是创建的对象。</p></li></ul></li><li><p>对象的使用</p><ul><li><p>对象的属性</p><ul><li>对象中存储具体数据的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储函数的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”</li><li>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号<br><strong>示例代码如下：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(star.name)     // 调用名字属性</span><br><span class="line">console.log(star[&#x27;name&#x27;])  // 调用名字属性</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>调用对象的方法</strong></p><ul><li>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号<br>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>变量、属性、函数、方法总结</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</span><br></pre></td></tr></table></figure><ul><li>变量：单独声明赋值，单独存在</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征<br>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</li><li>函数：单独存在的，通过“函数名()”的方式就可以调用</li><li>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能</li></ul></li></ul></li><li><p><strong>利用 new Object 创建对象</strong></p><ul><li><p>创建空对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var andy = new Obect();</span><br></pre></td></tr></table></figure><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li>通过对象操作属性和方法的方式，来为对象增加属性和方法<br>示例代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">andy.name = &#x27;pink&#x27;;</span><br><span class="line">andy.age = 18;</span><br><span class="line">andy.sex = &#x27;男&#x27;;</span><br><span class="line">andy.sayHi = function()&#123;</span><br><span class="line">    alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Object() ：第一个字母大写</li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 &#x3D;  值;</li></ul></li></ul></li><li><p><strong>利用构造函数创建对象</strong></p><ul><li>构造函数<ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 构造函数名(形参1,形参2,形参3) &#123;</span><br><span class="line">     this.属性名1 = 参数1;</span><br><span class="line">     this.属性名2 = 参数2;</span><br><span class="line">     this.属性名3 = 参数3;</span><br><span class="line">     this.方法名 = 函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数的调用格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new 构造函数名(实参1，实参2，实参3)</span><br></pre></td></tr></table></figure><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>构造函数约定首字母大写。</li><li>函数内的属性和方法前面需要添加<strong>this</strong> ，表示当前对象的属性和方法。</li><li><strong>构造函数中不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ol></li><li><p><strong>其他</strong><br>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul></li></ul></li><li><p><strong>new关键字的作用</strong></p><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h3 id="5-3-遍历对象"><a href="#5-3-遍历对象" class="headerlink" title="5.3 遍历对象"></a>5.3 遍历对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for...in 语句用于对数组或者对象的属性进行循环操作。</span><br><span class="line"></span><br><span class="line">其语法如下：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (变量 in 对象名字) &#123;</span><br><span class="line">    // 在此执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var k in obj) &#123;</span><br><span class="line">    console.log(k);      // 这里的 k 是属性名</span><br><span class="line">    console.log(obj[k]); // 这里的 obj[k] 是属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-内置对象"><a href="#1-1-内置对象" class="headerlink" title="1.1 内置对象"></a>1.1 内置对象</h3><p>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象<br><strong>前面两种对象是JS 基础内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是</strong>最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发</p><p>**JavaScript 提供了多个内置对象：Math、 Date 、Array、String等    **</p><h3 id="1-2-查文档"><a href="#1-2-查文档" class="headerlink" title="1.2 查文档"></a>1.2 查文档</h3><p>查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN&#x2F;W3C来查询。<br>Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。<br>MDN:<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h3 id="1-3-Math对象"><a href="#1-3-Math对象" class="headerlink" title="1.3 Math对象"></a>1.3 Math对象</h3><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()&#x2F;Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p><strong>注意：上面的方法使用时必须带括号</strong></p><p>获取指定范围内的随机整数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用对象封装自己的数学对象  里面有 PI 最大值和最小值</span><br><span class="line">        var myMath = &#123;</span><br><span class="line">            PI: 3.141592653,</span><br><span class="line">            max: function() &#123;</span><br><span class="line">                var max = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &gt; max) &#123;</span><br><span class="line">                        max = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return max;</span><br><span class="line">            &#125;,</span><br><span class="line">            min: function() &#123;</span><br><span class="line">                var min = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &lt; min) &#123;</span><br><span class="line">                        min = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(myMath.PI);</span><br><span class="line">        console.log(myMath.max(1, 5, 9));</span><br><span class="line">        console.log(myMath.min(1, 5, 9));</span><br></pre></td></tr></table></figure><h3 id="1-4-日期对象"><a href="#1-4-日期对象" class="headerlink" title="1.4 日期对象"></a>1.4 日期对象</h3><p>Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var now = new Date();</span><br></pre></td></tr></table></figure><ul><li>获取指定时间的日期对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var future = new Date(&#x27;2019/5/1&#x27;);</span><br></pre></td></tr></table></figure><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p><strong>使用Date实例的方法和属性</strong><br><img src="https://s2.loli.net/2024/03/17/Bt7q6c4fYMbLpgr.png" alt="图片1"></p></li><li><p>通过Date实例获取总毫米数</p><ul><li>总毫秒数的含义<br>基于1970年1月1日（世界标准时间）起的毫秒数</li><li>获取总毫秒数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实例化Date对象</span><br><span class="line">var now = new Date();</span><br><span class="line">// 1. 用于获取对象的原始值</span><br><span class="line">console.log(date.valueOf())    </span><br><span class="line">console.log(date.getTime())    </span><br><span class="line">// 2. 简单写可以这么做</span><br><span class="line">var now = + new Date();            </span><br><span class="line">// 3. HTML5中提供的方法，有兼容性问题</span><br><span class="line">var now = Date.now();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-数组对象"><a href="#1-5-数组对象" class="headerlink" title="1.5 数组对象"></a>1.5 数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li>字面量方式<ul><li>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,&quot;test&quot;,true];</span><br></pre></td></tr></table></figure></li></ul></li><li>new Array()<ul><li><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li>如果只传入一个参数，则参数规定了数组的长度</li><li>如果传入了多个参数，则参数称为数组的元素</li></ul></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li>instanceof 运算符<ul><li>instanceof 可以判断一个对象是否是某个构造函数的实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line">console.log(obj instanceof Array); // false</span><br></pre></td></tr></table></figure></li></ul></li><li>Array.isArray()<ul><li>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(Array.isArray(arr));   // true</span><br><span class="line">console.log(Array.isArray(obj));   // false</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><ul><li>数组中有进行增加、删除元素的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/uebmUwin5S3j91r.png" alt="pushpop"><br>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</li></ul><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li><strong>数组中有对数组本身排序的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/DOPv2ZCqMBnpmsN.png"><br>注意：sort方法需要传入参数来设置升序、降序排序<ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul></li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><ul><li>数组中有获取数组指定元素索引值的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/IFPG26TQdrbw1NK.png"></li></ul><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><ul><li><strong>数组中有把数组转化为字符串的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/fGBnsd1I65ZK7tz.png"><br><strong>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</strong></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>数组中还有其他操作方法，同学们可以在课下自行查阅学习<br><img src="https://s2.loli.net/2024/03/17/3iDC7uAtBHdKRGr.png"></li></ul><h3 id="1-6-字符串对象"><a href="#1-6-字符串对象" class="headerlink" title="1.6 字符串对象"></a>1.6 字符串对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 下面代码有什么问题？</span><br><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure><p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="line">var temp = new String(&#x27;andy&#x27;);</span><br><span class="line">// 2. 赋值给我们声明的字符变量</span><br><span class="line">str = temp;</span><br><span class="line">// 3. 销毁临时变量</span><br><span class="line">temp = null;</span><br></pre></td></tr></table></figure><h4 id="字符串的不可变"><a href="#字符串的不可变" class="headerlink" title="字符串的不可变"></a>字符串的不可变</h4><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><p>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>由于字符串的不可变，在****大量拼接字符串的时候会有效率问题</p><h4 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p><p><img src="https://s2.loli.net/2024/03/17/7QdYZoglVsuOrxw.png"></p><p><strong>案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;oabcoefoxyozzopp&quot;;</span><br><span class="line">var index = str.indexOf(&#x27;o&#x27;);</span><br><span class="line">var num = 0;</span><br><span class="line">// console.log(index);</span><br><span class="line">while (index !== -1) &#123;</span><br><span class="line">      console.log(index);</span><br><span class="line">      num++;</span><br><span class="line">      index = str.indexOf(&#x27;o&#x27;, index + 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;o出现的次数是: &#x27; + num);</span><br></pre></td></tr></table></figure><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p><p><img src="https://s2.loli.net/2024/03/17/6S5Z3Ezf4BYJH9T.png"></p><p>案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      var o = &#123;&#125;;</span><br><span class="line">      var str = &quot;abcoefoxyozzopp&quot;;</span><br><span class="line">      //   for (var k in str) &#123;</span><br><span class="line">      //     if (o[str[k]]) &#123;</span><br><span class="line">      //       o[str[k]]++;</span><br><span class="line">      //     &#125; else &#123;</span><br><span class="line">      //       o[str[k]] = 1;</span><br><span class="line">      //     &#125;</span><br><span class="line">      //   &#125;</span><br><span class="line">      for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        var chars = str.charAt(i);</span><br><span class="line">        if (o[chars]) &#123;</span><br><span class="line">          o[chars]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          o[chars] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(o);</span><br><span class="line">      var max = 0;</span><br><span class="line">      var ch = &quot;&quot;;</span><br><span class="line">      for (var k in o) &#123;</span><br><span class="line">        if (o[k] &gt; max) &#123;</span><br><span class="line">          max = o[k];</span><br><span class="line">          ch = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(max);</span><br><span class="line">      console.log(ch);</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p><strong>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</strong></p><p><img src="https://s2.loli.net/2024/03/17/zO5PavVILoNGh9l.png"></p><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p><strong>replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.replace(被替换的字符串， 要替换为的字符串)；</span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p><strong>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.split(&quot;分割字符&quot;)</span><br></pre></td></tr></table></figure><h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><p><strong>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;//构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function f1(x) &#123; // x = p</span><br><span class="line">    console.log(x.name); // 2.刘德华   </span><br><span class="line">    x.name = &quot;张学友&quot;;</span><br><span class="line">    console.log(x.name); // 3. 张学友  </span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;刘德华&quot;); //实例</span><br><span class="line">console.log(p.name);    // 1.刘德华</span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name);    // 4. 张学友</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/</id>
    <published>2024-03-17T01:27:26.000Z</published>
    <updated>2024-03-17T01:32:58.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="7-运算符（操作符）"><a href="#7-运算符（操作符）" class="headerlink" title="7. 运算符（操作符）"></a>7. 运算符（操作符）</h2><p><strong>浮点数的精度问题</strong></p><p><strong>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;    <span class="comment">// 结果不是 0.3，而是：0.30000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.07</span> * <span class="number">100</span>);   <span class="comment">// 结果不是 7，  而是：7.000000000000001</span></span><br></pre></td></tr></table></figure><p><strong>所以：不要直接判断两个浮点数是否相等 !</strong></p><h2 id="8-断点调试"><a href="#8-断点调试" class="headerlink" title="8. 断点调试"></a>8. 断点调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试的流程：</span><br><span class="line">1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点</span><br><span class="line">2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。</span><br><span class="line">3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</span><br></pre></td></tr></table></figure><p><strong>标识符命名规范</strong></p><ul><li><strong>变量、函数的命名必须要有意义</strong></li><li><strong>变量的名称一般用名词</strong></li><li><strong>函数的名称一般用动词</strong></li></ul><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><p><strong>JS 中创建数组有两种方式：</strong></p><ul><li><p><strong>利用  new 创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>() ；</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// 创建一个新的空数组</span></span><br></pre></td></tr></table></figure><p><strong>注意 Array () ，A 要大写</strong></p></li><li><p><strong>利用数组字面量创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []；</span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>**数组的字面量是方括号 [ ] **</li><li><strong>声明数组并赋值称为数组的初始化</strong></li><li><strong>这种字面量方式也是我们以后最多使用的方式</strong></li></ul></li><li><p><strong>数组元素的类型</strong><br><strong>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrStus = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">12</span>,<span class="literal">true</span>,<span class="number">28.9</span>];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 获取数组中的第2个元素</span></span><br><span class="line"><span class="title function_">alert</span>(arrStus[<span class="number">1</span>]);    </span><br></pre></td></tr></table></figure><p><strong>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</strong></p><ul><li><p><strong>数组的长度</strong><br><strong>数组的长度：默认情况下表示数组中元素的个数</strong><br><strong>使用“数组名.length”可以访问数组元素的数量（数组长度）。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrStus = [1,2,3];</span><br><span class="line">alert(arrStus.length);  // 3</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p></li><li><p><strong>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</strong></p></li><li><p><strong>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</strong></p></li><li><p><strong>数组的length属性可以被修改：</strong></p></li><li><p><strong>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</strong></p></li><li><p><strong>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</strong></p></li></ul><h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明函数</span><br><span class="line">function 函数名() &#123;</span><br><span class="line">    //函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>function 是声明函数的关键字,必须小写</strong></p></li><li><p><strong>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</strong></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用函数</span><br><span class="line">函数名();  // 通过调用函数名来执行函数体代码</span><br></pre></td></tr></table></figure><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p><strong>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</strong></p></li><li><p><strong>具有 length 属性</strong></p></li><li><p><strong>按索引方式储存数据</strong></p></li><li><p><strong>不具有数组的 push , pop 等方法</strong><br><strong>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</strong></p></li></ul><h3 id="函数案例"><a href="#函数案例" class="headerlink" title="函数案例"></a>函数案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</span><br></pre></td></tr></table></figure><h3 id="函数的两种声明方式"><a href="#函数的两种声明方式" class="headerlink" title="函数的两种声明方式"></a>函数的两种声明方式</h3><ul><li><p><strong>自定义函数方式(命名函数)</strong><br><strong>利用函数关键字 function 自定义函数方式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明定义方式</span><br><span class="line">function fn() &#123;...&#125;</span><br><span class="line">// 调用  </span><br><span class="line">fn();  </span><br></pre></td></tr></table></figure><ul><li><strong>因为有名字，所以也被称为命名函数</strong></li><li><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></li></ul></li><li><p><strong>函数表达式方式(匿名函数）</strong><br>**利用函数表达式方式的写法如下： **</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是函数表达式写法，匿名函数后面跟分号结束</span><br><span class="line">var fn = function()&#123;...&#125;；</span><br><span class="line">// 调用的方式，函数调用必须写到函数体下面</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ul><li><strong>因为函数没有名字，所以也被称为匿名函数</strong></li><li>**这个fn 里面存储的是一个函数  **</li><li><strong>函数表达式方式原理跟声明变量方式是一致的</strong></li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ul></li></ul><h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10 - 作用域"></a>10 - 作用域</h2><h3 id="1-1-作用域概述"><a href="#1-1-作用域概述" class="headerlink" title="1.1 作用域概述"></a>1.1 作用域概述</h3><p><strong>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</strong></p><p><strong>JavaScript（es6前）中的作用域有两种：</strong></p><ul><li><strong>全局作用域</strong></li><li><strong>局部作用域（函数作用域）</strong></li></ul><h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于所有代码执行的环境(整个script标签内部)或独立的js文件。</span><br></pre></td></tr></table></figure><h3 id="1-3-局部作用域"><a href="#1-3-局部作用域" class="headerlink" title="1.3 局部作用域"></a>1.3 局部作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于函数内的代码环境，就是局部作用域。 </span><br><span class="line">因为跟函数有关系，所以也称为函数作用域。</span><br></pre></td></tr></table></figure><h3 id="1-4-jS没有块级作用域"><a href="#1-4-jS没有块级作用域" class="headerlink" title="1.4 jS没有块级作用域"></a>1.4 jS没有块级作用域</h3><ul><li><strong>块作用域由 { } 包括。</strong></li><li><strong>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用；</strong><br><strong>js中没有块级作用域（在ES6之前）</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">  var num = 123;</span><br><span class="line">  //console.log(num); //123</span><br><span class="line">&#125;</span><br><span class="line">console.log(num);   //123</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-变量的作用域"><a href="#1-5-变量的作用域" class="headerlink" title="1.5 变量的作用域"></a>1.5 变量的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在JavaScript中，根据作用域的不同，变量可以分为两种：</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li><li><strong>局部变量</strong></li></ul><p><strong>2.1 全局变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量在代码的任何位置都可以使用</strong></li><li><strong>在全局作用域下 var 声明的变量 是全局变量</strong></li><li><strong>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</strong></li></ul><p><strong>2.2 局部变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</span><br></pre></td></tr></table></figure><ul><li><strong>局部变量只能在该函数内部使用</strong></li><li><strong>在函数内部 var 声明的变量是局部变量</strong></li><li><strong>函数的形参实际上就是局部变量</strong></li></ul><p><strong>2.3 全局变量和局部变量的区别</strong></p><ul><li><strong>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</strong></li><li><strong>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</strong></li></ul><h3 id="1-6-作用域链"><a href="#1-6-作用域链" class="headerlink" title="1.6 - 作用域链"></a>1.6 - 作用域链</h3><p><strong>只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在</strong>**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例分析1：</span><br><span class="line">function f1() &#123;</span><br><span class="line">    var num = 123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">        console.log( num );//123</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line">var num = 456;</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域链：采取就近原则的方式来查找变量最终的值</span><br><span class="line">var a = 1;</span><br><span class="line">function fn1() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    var b = &#x27;22&#x27;;</span><br><span class="line">    fn2();</span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        var a = 3;</span><br><span class="line">        fn3();</span><br><span class="line">        function fn3() &#123;</span><br><span class="line">            var a = 4;</span><br><span class="line">            console.log(a); //a的值 4</span><br><span class="line">            console.log(b); //b的值 22</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><p><img src="file://F:/20-%E6%B1%82%E8%81%8C/02-%E5%89%8D%E7%AB%AF/images/js/%E5%9B%BE%E7%89%872-16779152458061.png?lastModify=1710638944"></p><h3 id="1-7-预解析"><a href="#1-7-预解析" class="headerlink" title="1.7 - 预解析"></a>1.7 - 预解析</h3><p><strong>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。</strong></p><p><strong>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：</strong></p><p><strong>预解析和代码执行。</strong></p><ul><li><strong>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</strong>，预解析也叫做变量、函数提升。</li><li><strong>代码执行： 从上到下执行JS语句。</strong><br><strong>注意：****预解析会把变量和函数的声明在代码执行之前执行完成。</strong></li></ul><p><strong>变量预解析：</strong></p><p><strong>变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(num);  // undefined</span><br><span class="line">var num = 10;</span><br><span class="line">//注意：变量提升只提升声明，不提升赋值</span><br></pre></td></tr></table></figure><p><strong>函数预解析：</strong></p><p><strong>函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;打印&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：控制台打印字符串 — ”打印“</strong></p><p><strong>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！</strong></p><p><strong>函数表达式声明函数问题：</strong></p><p><strong>函数表达式创建函数，会执行变量提升</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">var  fn = function() &#123;</span><br><span class="line">    console.log(&#x27;想不到吧&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：报错提示 ”fn is not a function”</strong></p><blockquote><p><strong>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>react+vite+hexo|项目呈现</title>
    <link href="https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"/>
    <id>https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</id>
    <published>2024-03-10T03:51:26.000Z</published>
    <updated>2024-03-09T03:55:48.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yayuya/p/17046666.html">Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/7208946311885586492">通过Hexo + Github Pages部署你的react项目 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yayuya/p/17046666.html&quot;&gt;Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post</summary>
      
    
    
    
    <category term="周边扩展" scheme="https://youxt-njnu.github.io/categories/%E5%91%A8%E8%BE%B9%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
    <category term="Hexo" scheme="https://youxt-njnu.github.io/tags/Hexo/"/>
    
    <category term="个人博客" scheme="https://youxt-njnu.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
