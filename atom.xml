<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pale Bule Dot</title>
  
  
  <link href="https://youxt-njnu.github.io/atom.xml" rel="self"/>
  
  <link href="https://youxt-njnu.github.io/"/>
  <updated>2024-08-21T06:18:49.678Z</updated>
  <id>https://youxt-njnu.github.io/</id>
  
  <author>
    <name>Shealin You</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shader-学习记录Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
    <id>https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</id>
    <published>2024-08-19T03:55:26.000Z</published>
    <updated>2024-08-21T06:18:49.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-color部分"><a href="#记录-color部分" class="headerlink" title="记录-color部分"></a>记录-color部分</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec4 vector;</span><br><span class="line">vector[0] = vector.r = vector.x = vector.s;</span><br><span class="line">vector[1] = vector.g = vector.y = vector.t;</span><br><span class="line">vector[2] = vector.b = vector.z = vector.p;</span><br><span class="line">vector[3] = vector.a = vector.w = vector.q;</span><br></pre></td></tr></table></figure><p>支持swizzle(搅动)：vec3 yellow&#x3D;vec3(1.,1.,0.); yellow.rgb, yellow.rgr, yellow.bgr ……</p><p>利用mix()进行color混合：mix(color1,color2,value) ，value从0到1，value越小color1值越多</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>); <span class="comment">// blue</span></span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>); <span class="comment">// yellow</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct = <span class="built_in">abs</span>(<span class="built_in">sin</span>(u_time)); <span class="comment">// 从0到1，sin(x)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mix uses pct (a value from 0-1) to</span></span><br><span class="line">    <span class="comment">// mix the two colors</span></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="easing-function"><a href="#easing-function" class="headerlink" title="easing function"></a>easing function</h2><p>用于计算动画的缓动函数<a href="https://easings.net/">easing function</a></p><ul><li>下面的式子有些作者进行了sin&#x2F;cos之间的变换，以及命名的风格是sineIn就是上面链接里的easeInSine</li><li>上面网页里，每个函数都有对应的css用法，postcss用法，在元素变换动画里的效果，在颜色渐变混合里的效果，使用该函数进行变换的样例（缩放、移动、透明度变化）,也可以调整参数点击go进行对比</li><li>最后一排：css的实现是通过@keyframes，设置不同的条件；函数里面是通过一系列的判断来赋值；</li><li>前四排的都是<a href="https://cubic-bezier.com/#.25,.1,.25,1">cube-bezier</a>函数设置不同的参数得到的效果</li></ul><blockquote><p>在 CSS 中，<code>cubic-bezier</code> 函数用于定义一个三次贝塞尔曲线，广泛应用于动画和过渡效果的时间函数（timing function）。这个函数的四个参数控制曲线的形状，从而影响动画的速度变化。</p><p>具体来说，<code>cubic-bezier(.12, 0, .33, 0)</code> 中的四个参数表示的是两个控制点的坐标：</p><ul><li>第一个控制点的坐标为 (0.12, 0)</li><li>第二个控制点的坐标为 (0.33, 0)</li></ul><p>这四个参数可以这样解释：</p><ol><li>**第一个参数 (0.12)**：这是第一个控制点的横坐标，它影响动画开始阶段的加速度。值为 0.12 表示在动画开始阶段，速度从零开始缓慢增加。</li><li>**第二个参数 (0)**：这是第一个控制点的纵坐标，它在这里设为 0，意味着控制点位于起始线上，因此动画起始时会比较平缓，没有立即加速。</li><li>**第三个参数 (0.33)**：这是第二个控制点的横坐标，影响动画结束前的减速过程。值较小（0.33）表明动画在结束前不久开始减速。</li><li>**第四个参数 (0)**：这是第二个控制点的纵坐标，同样为 0，意味着结束时速度减到 0，动画结束的过程也是比较平缓的。</li></ol><p>通过调整这些参数，开发者可以精确控制动画的速度曲线，从而创造出各种动画效果。在这个具体例子中，由于两个控制点的纵坐标都是 0，这种曲线通常用于创建某些具有明显起始和结束阶段的动画效果。</p></blockquote><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.141592653589793</span></span><br><span class="line"><span class="meta">#define HALF_PI 1.5707963267948966</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Robert Penner&#x27;s easing functions in GLSL</span></span><br><span class="line"><span class="comment">// https://github.com/stackgl/glsl-easings</span></span><br><span class="line"><span class="type">float</span> linear(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> ? t : <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">1.0</span> ? t : <span class="number">1.0</span> - <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> || t == <span class="number">1.0</span></span><br><span class="line">    ? t</span><br><span class="line">    : t &lt; <span class="number">0.5</span></span><br><span class="line">      ? +<span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, (<span class="number">20.0</span> * t) - <span class="number">10.0</span>)</span><br><span class="line">      : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> - (t * <span class="number">20.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>((t - <span class="number">1.0</span>) * HALF_PI) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(t * HALF_PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-0.5</span> * (<span class="built_in">cos</span>(PI * t) - <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">5.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">16.0</span> * <span class="built_in">pow</span>(t, <span class="number">5.0</span>)</span><br><span class="line">    : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">5.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">3.0</span>) * (<span class="number">1.0</span> - t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">8.0</span> * <span class="built_in">pow</span>(t, <span class="number">4.0</span>)</span><br><span class="line">    : <span class="number">-8.0</span> * <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">4.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> p = <span class="number">2.0</span> * t * t;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span> ? p : -p + (<span class="number">4.0</span> * t) - <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> -t * (t - <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t - <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">return</span> f * f * f + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">4.0</span> * t * t * t</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">3.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">13.0</span> * t * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">-13.0</span> * (t + <span class="number">1.0</span>) * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * <span class="built_in">sin</span>(+<span class="number">13.0</span> * HALF_PI * <span class="number">2.0</span> * t) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">sin</span>(<span class="number">-13.0</span> * HALF_PI * ((<span class="number">2.0</span> * t - <span class="number">1.0</span>) + <span class="number">1.0</span>)) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - t * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="number">2.0</span> - t) * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - <span class="number">4.0</span> * t * t))</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="built_in">sqrt</span>((<span class="number">3.0</span> - <span class="number">2.0</span> * t) * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> a = <span class="number">4.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> b = <span class="number">8.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> c = <span class="number">9.0</span> / <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> ca = <span class="number">4356.0</span> / <span class="number">361.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cb = <span class="number">35442.0</span> / <span class="number">1805.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cc = <span class="number">16061.0</span> / <span class="number">1805.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> t2 = t * t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; a</span><br><span class="line">    ? <span class="number">7.5625</span> * t2</span><br><span class="line">    : t &lt; b</span><br><span class="line">      ? <span class="number">9.075</span> * t2 - <span class="number">9.9</span> * t + <span class="number">3.4</span></span><br><span class="line">      : t &lt; c</span><br><span class="line">        ? ca * t2 - cb * t + cc</span><br><span class="line">        : <span class="number">10.8</span> * t * t - <span class="number">20.52</span> * t + <span class="number">10.72</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t * <span class="number">2.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * bounceOut(t * <span class="number">2.0</span> - <span class="number">1.0</span>) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">3.0</span>) - t * <span class="built_in">sin</span>(t * PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">1.0</span> - t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">2.0</span> * t</span><br><span class="line">    : <span class="number">1.0</span> - (<span class="number">2.0</span> * t - <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> g = <span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * g</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="number">1.0</span> - g) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充说明：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> t = u_time * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间缩放 (<code>t = u_time * 0.5</code>)**：这里 <code>u_time</code> 被乘以 0.5，意味着 <code>t</code> 的变化速度是 <code>u_time</code> 的一半。如果 <code>u_time</code> 是一个随时间增加的变量，那么 <code>t</code> 的增长速度更慢。</li><li>**计算 <code>pct</code>**：<code>fract(t)</code> 获取 <code>t</code> 的小数部分，这样即使 <code>t</code> 增长到 1 以上，<code>fract(t)</code> 也会重新从 0 开始，实现周期性重置。乘以 2.0 然后减 1.0 是为了将周期变化从 <code>[0,1]</code> 调整到 <code>[-1,1]</code>，这样 <code>abs(...)</code> 后的值将在 <code>[0,1]</code> 之间振荡，实现了先增加到 1 然后减少到 0 的周期性变化。</li><li><strong><code>cubicInOut</code> 动画曲线</strong>：这个函数通常定义了一个缓入缓出的三次曲线，意味着动画开始和结束时速度较慢，中间速度较快。</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">t = u_time;</span><br><span class="line">pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间设置 (<code>t = u_time</code>)**：这里没有对 <code>u_time</code> 进行缩放，因此 <code>t</code> 以原始速度增加。</li><li>**计算 <code>pct</code>**：这里仅使用了 <code>fract(t)</code> 减去 1.0，与上面的代码相比，这样处理会产生从 <code>-1</code> 到 0 的周期性变化（因为 <code>fract(t)</code> 产生 <code>[0,1)</code>，减 1 后变为 <code>[-1,0)</code>）。应用 <code>abs(...)</code> 后，变化将在 <code>[0,1)</code> 间发生，实现了周期性的从 0 增加到 1。</li></ol><p>效果差异：</p><ul><li><strong>变化速率</strong>：上面的代码中 <code>t</code> 的变化速度为原始时间的一半，这导致整体动画速度更慢。</li><li><strong>振荡方式</strong>：上面的代码使得振荡从 0 增加到 1 然后减少到 0，形成一个完整的循环，而下面的代码只从 0 增加到 1。</li></ul><p>结合这些分析，上面的代码提供了一个更平滑和对称的振荡模式，适用于需要循环动画效果的场景，如呼吸灯效果。下面的代码则更适合于单向的渐进或渐出效果，如日出效果。</p><h2 id="颜色的渐变"><a href="#颜色的渐变" class="headerlink" title="颜色的渐变"></a>颜色的渐变</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">void main() &#123;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"> vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    float pct = cubicInOut(st.y); </span><br><span class="line">    pct = circularInOut(st.y); // 因为InOut那边的曲线是在很小范围内的自变量下发生了较大的因变量变化，所以分界线会明显，相对上面的来说</span><br><span class="line">    // Mix uses pct (a value from 0-1) to</span><br><span class="line">    // mix the two colors</span><br><span class="line">    color = mix(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/OmhPTZGRKIo1rfN.png"></p><h2 id="mix对RGB三个通道的控制"><a href="#mix对RGB三个通道的控制" class="headerlink" title="mix对RGB三个通道的控制"></a>mix对RGB三个通道的控制</h2><p>可以分别设置RGB三通道的混合方式</p><p><img src="https://thebookofshaders.com/06/mix-vec.jpg" alt="img"></p><p>示例</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> plot (<span class="type">vec2</span> st, <span class="type">float</span> pct)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">smoothstep</span>( pct<span class="number">-0.01</span>, pct, st.y) -</span><br><span class="line">          <span class="built_in">smoothstep</span>( pct, pct+<span class="number">0.01</span>, st.y); <span class="comment">// smoothstep(a-极小值,a,纹理坐标)-smoothstep(a,a+极小值,纹理坐标)，可以画出a的曲线（也就是代码里的pct）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> pct = <span class="type">vec3</span>(st.x);</span><br><span class="line"></span><br><span class="line">    pct.r = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,<span class="number">1.0</span>, st.x);</span><br><span class="line">    pct.g = <span class="built_in">sin</span>(st.x*PI);</span><br><span class="line">    pct.b = <span class="built_in">pow</span>(st.x,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Plot transition lines for each channel</span></span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.r));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.g));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.b));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/NtLrd5aD4mFjuSX.png"></p><p>混合加变换的组合</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="built_in">mix</span>(color1,color2,st.y);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="built_in">mix</span>(color1,color2,<span class="number">1.</span>-st.y*st.x);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*2WK3NdpR_Oxt0QKN8r6Rgg.gif" alt="img"></p><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><blockquote><p>shadertoy代码：</p><p><a href="https://www.shadertoy.com/view/MsS3Wc">Smooth HSV (shadertoy.com)</a></p><p><a href="https://blog.csdn.net/ColdWindHA/article/details/82080176">OpenCV学习笔记——HSV颜色空间超极详解&amp;inRange函数用法及实战_hsv值是什么-CSDN博客</a></p><p><a href="https://www.cnblogs.com/dablyo/p/6854947.html">HSV色彩空间和颜色分量范围 - 友善的狗W - 博客园 (cnblogs.com)</a></p></blockquote><p><img src="https://s2.loli.net/2024/08/21/AleHoLjbR9I67Su.png" alt="image.png"></p><p>RGB和HSV的互转</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> rgb2hsb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> p = <span class="built_in">mix</span>(<span class="type">vec4</span>(c.bg, K.wz),</span><br><span class="line">                 <span class="type">vec4</span>(c.gb, K.xy),</span><br><span class="line">                 <span class="built_in">step</span>(c.b, c.g));</span><br><span class="line">    <span class="type">vec4</span> q = <span class="built_in">mix</span>(<span class="type">vec4</span>(p.xyw, c.r),</span><br><span class="line">                 <span class="type">vec4</span>(c.r, p.yzx),</span><br><span class="line">                 <span class="built_in">step</span>(p.x, c.r));</span><br><span class="line">    <span class="type">float</span> d = q.x - <span class="built_in">min</span>(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)),</span><br><span class="line">                d / (q.x + e),</span><br><span class="line">                q.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Function from Iñigo Quiles</span></span><br><span class="line"><span class="comment">//  https://www.shadertoy.com/view/MsS3Wc</span></span><br><span class="line"><span class="type">vec3</span> hsb2rgb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec3</span> rgb = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(c.x*<span class="number">6.0</span>+<span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">4.0</span>,<span class="number">2.0</span>),</span><br><span class="line">                             <span class="number">6.0</span>)<span class="number">-3.0</span>)<span class="number">-1.0</span>,</span><br><span class="line">                     <span class="number">0.0</span>,</span><br><span class="line">                     <span class="number">1.0</span> );</span><br><span class="line">    rgb = rgb*rgb*(<span class="number">3.0</span><span class="number">-2.0</span>*rgb);</span><br><span class="line">    <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">1.0</span>), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We map x (0.0 - 1.0) to the hue (0.0 - 1.0)</span></span><br><span class="line">    <span class="comment">// And the y (0.0 - 1.0) to the brightness</span></span><br><span class="line">    color = hsb2rgb(<span class="type">vec3</span>(st.x,<span class="number">1.0</span>,st.y)); <span class="comment">// 传入的体现了h,s,b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/8ZdlghIPOemGJwt.png" alt="image.png"></p><p>HSB从笛卡尔坐标映射到极坐标：</p><ul><li>获取角度和到屏幕中心点的距离</li><li>使用length()和atan(y,x)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define TWO_PI 6.28318530718</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">//  Function from Iñigo Quiles</span><br><span class="line">//  https://www.shadertoy.com/view/MsS3Wc</span><br><span class="line">vec3 hsb2rgb( in vec3 c )&#123;</span><br><span class="line">    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),</span><br><span class="line">                             6.0)-3.0)-1.0,</span><br><span class="line">                     0.0,</span><br><span class="line">                     1.0 );</span><br><span class="line">    rgb = rgb*rgb*(3.0-2.0*rgb);</span><br><span class="line">    return c.z * mix( vec3(1.0), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // Use polar coordinates instead of cartesian</span><br><span class="line">    vec2 toCenter = vec2(0.5)-st; // 把纹理坐标空间移到-.5到.5</span><br><span class="line">    float angle = atan(toCenter.y,toCenter.x); // 求每个点相对于中心点的角度</span><br><span class="line">    float radius = length(toCenter)*2.0; // 长度的范围是0~1</span><br><span class="line"></span><br><span class="line">    // Map the angle (-PI to PI) to the Hue (from 0 to 1)</span><br><span class="line">    // and the Saturation to the radius</span><br><span class="line">    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0)); // 第一个表示h，根据相对于中心点的角度来赋予颜色，同时缩放到了0-1，然后传入；radius: 离中心点越远，radius越大，s值越大;</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/fTMw6RpQmVY3JWH.png" alt="image.png"></p><p><code>var toCenter = st - vec2(0.5);</code></p><p>这样子，把上述的图旋转180度的效果；</p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p>结合shaping function，呈现不同的颜色过渡；</p><p><img src="https://thebookofshaders.com/06/spectrums.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</id>
    <published>2024-08-16T07:52:26.000Z</published>
    <updated>2024-08-19T05:51:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><p><a href="https://thebookofshaders.com/edit.php">GLSL Editor (thebookofshaders.com)</a> 在线的shader编辑调试</p><p><a href="https://github.com/patriciogonzalezvivo/glslGallery">patriciogonzalezvivo&#x2F;glslGallery (github.com)</a> 看着不错，但是提交自己的上去后，提交不到对应的服务器（直白些就是俺试完了用不了。。。。。</p><p><a href="https://patriciogonzalezvivo.github.io/glslGallery/">GLSL Gallery (patriciogonzalezvivo.github.io)</a> 作者的一些shader，可以借鉴学习</p><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><h2 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h2><p>GPU特点：blind（不知道其他的pipe&#x2F;thread在干啥），memoryless（不知道以前干了啥）</p><p>片元着色器：</p><ul><li>void main() {} 主函数</li><li>内置全局变量，如gl_FragColor</li><li>默认输出：gl_fragColor</li><li>默认输入：gl_fragCoord  (是varing)     &#x2F;&#x2F;    x,y都从0到1</li><li>数据类型，vec4，精度如float</li><li>标准化normalized, 映射map</li><li>宏，#defines, #ifdef, #endif, #ifndef</li><li>注意，对于浮点的数字最好养成加上.的习惯</li></ul><p>uniform:</p><ul><li>cpu给gpu的</li><li>一些所有thread都一样的，不会变的值</li></ul><p>支持内置数学函数，如sin()</p><h2 id="shaping-functions"><a href="#shaping-functions" class="headerlink" title="shaping functions"></a>shaping functions</h2><h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p>The <a href="https://thebookofshaders.com/glossary/?search=step"><code>step()</code></a> interpolation receives two parameters.</p><p>The first one is the limit or threshold, while the second one is the value we want to check or pass.</p><p>Any value under the limit will return <code>0.0</code> while everything above the limit will return <code>1.0</code>.</p><h3 id="smoothstep"><a href="#smoothstep" class="headerlink" title="smoothstep"></a>smoothstep</h3><p><a href="https://blog.csdn.net/weixin_61427881/article/details/127839417">【Shader Graph】SmoothStep节点详解及其应用-CSDN博客</a></p><h3 id="sin-x2F-cos"><a href="#sin-x2F-cos" class="headerlink" title="sin&#x2F;cos"></a>sin&#x2F;cos</h3><p>加上u_time: 实现沿x轴的移动</p><p>乘上PI类似的：实现曲线的收缩</p><p>加上值：实现曲线上下移动</p><p>外面乘上值：实现曲线拉伸</p><p>取绝对值abs()：弹跳球轨迹</p><p>取小数部分fract()</p><p>取上下整数ceil(), floor()</p><p>y &#x3D; mod(x,0.5); &#x2F;&#x2F; return x modulo of 0.5<br>y &#x3D; fract(x); &#x2F;&#x2F; return only the fraction part of a number<br>y &#x3D; ceil(x);  &#x2F;&#x2F; nearest integer that is greater than or equal to x<br>y &#x3D; floor(x); &#x2F;&#x2F; nearest integer less than or equal to x<br>y &#x3D; sign(x);  &#x2F;&#x2F; extract the sign of x<br>y &#x3D; abs(x);   &#x2F;&#x2F; return the absolute value of x<br>y &#x3D; clamp(x,0.0,1.0); &#x2F;&#x2F; constrain x to lie between 0.0 and 1.0<br>y &#x3D; min(0.0,x);   &#x2F;&#x2F; return the lesser of x and 0.0<br>y &#x3D; max(0.0,x);   &#x2F;&#x2F; return the greater of x and 0.0</p><p>搜索关键词：generative art</p><blockquote><p><a href="https://aiartists.org/generative-art-design">Generative Art: 50 Best Examples, Tools &amp; Artists (2021 GUIDE) — AIArtists.org</a></p></blockquote><h1 id="几个shader"><a href="#几个shader" class="headerlink" title="几个shader"></a>几个shader</h1><h2 id="鼠标坐标"><a href="#鼠标坐标" class="headerlink" title="鼠标坐标"></a><strong>鼠标坐标</strong></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03 code2</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution; <span class="comment">// 屏幕 宽，高</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">   <span class="type">vec2</span> mousePos;</span><br><span class="line"><span class="comment">// vec2 st = gl_FragCoord.xy/u_resolution; // 把输入纹理坐标缩放到0~1</span></span><br><span class="line"><span class="comment">// gl_FragColor = vec4(st.x,st.y,0.0,1.0);</span></span><br><span class="line"><span class="type">vec2</span> center = u_resolution/<span class="number">2.</span>; <span class="comment">// 获取中心点的屏幕坐标</span></span><br><span class="line">   mousePos = (u_mouse.xy-center)/center; <span class="comment">// 把鼠标位置缩放到-1~1</span></span><br><span class="line">   mousePos = mousePos*<span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// 把鼠标位置缩放到0~1</span></span><br><span class="line">   <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(mousePos.x,mousePos.y,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷油漆"><a href="#刷油漆" class="headerlink" title="刷油漆"></a><strong>刷油漆</strong></h2><ul><li>获取从0到1空间坐标</li><li>做出0到1渐变灰</li><li>制造函数和对应区间</li><li>把函数涂上颜色</li></ul><p><img src="https://s2.loli.net/2024/08/16/p9GByiLT3MqlPCS.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05 code1</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值区间：</span></span><br><span class="line"><span class="comment">// abs(y-x)===0, return 1</span></span><br><span class="line"><span class="comment">// abs(y-x) 0~0.02, return abs(y-x)</span></span><br><span class="line"><span class="comment">// abs(y-x) &gt;0.02, return 0</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.02</span>,<span class="number">0.0</span>,<span class="built_in">abs</span>(st.y-st.x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"> <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">float</span> y = st.x;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line">    <span class="comment">// 每个点只有x起作用，所以x一样的，显示的颜色是一样的；</span></span><br><span class="line">    <span class="comment">// color由三个x组成，所以是灰度，而且渐变大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> line = plot(st);</span><br><span class="line">    <span class="comment">// color = line*vec3(.0,1.,.0); // 绘制出了绿色的线</span></span><br><span class="line">    <span class="comment">// color = (1.-line)*color; // 把线的地方扣成黑色，方便后续加色</span></span><br><span class="line">    <span class="comment">// 分割出线，加上背景</span></span><br><span class="line">    color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"> <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><p>st: 基于屏幕的纹理坐标</p><p>y: 和st有关系的函数</p><p>color: 展示y的灰度颜色</p><p>line: 通过st和y绘制的样条函数。。</p><p>color: 给line函数进行叠加显示</p><p><img src="https://s2.loli.net/2024/08/16/Qoudz1HApWlqJUK.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较st的x^5, 0, y的关系</span></span><br><span class="line"><span class="comment">// y&lt;x^5的，都0</span></span><br><span class="line"><span class="comment">// y在0~x^5，都原值</span></span><br><span class="line"><span class="comment">// y=0的，都1</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y,<span class="number">0.0</span>,st.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line"><span class="type">float</span> y = <span class="built_in">pow</span>(st.x,<span class="number">5.</span>);</span><br><span class="line"><span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line"><span class="type">float</span> line = plot(st,y);</span><br><span class="line">color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取个反再锐化下</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.02</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/z6xAHaYDJFeQ7ct.png" alt="image.png"></p><p>求个交集</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.03</span>,y,st.y)-<span class="built_in">smoothstep</span>(y<span class="number">-0.01</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/O4LcxMDmrB2toTP.png" alt="image.png"></p><p>更自然些的交集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float plot(vec2 st,float y) &#123;</span><br><span class="line">    return smoothstep(y-0.03,y,st.y)-smoothstep(y,y+0.03,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/Ze68o1mKhicjrbW.png" alt="image.png"></p><p>step需要分片来看：</p><ul><li>step(): 左片(&lt;0.5), 右片(&gt;0.5) -&gt;y,也就是传进polt的pct</li><li>smoothstep: 左片，所有纹理点都是1</li><li>smoothstep: 右片，纹理点的分割按照(1-0.02, 1, st.y)进行，下0，中原值，上1</li></ul><p><img src="https://s2.loli.net/2024/08/17/sel5gGTcNRP2iJq.png" alt="image.png"></p><h1 id="可能的bug"><a href="#可能的bug" class="headerlink" title="可能的bug"></a>可能的bug</h1><p><strong>没定义精度</strong> <code>No precision specified for (float)</code></p><blockquote><p>presion mediump floa<strong>t;</strong></p></blockquote><p><strong>fragment shader做完了不显示颜色：</strong></p><blockquote><p>没给gl_FragColor赋值</p></blockquote><p><strong>没找到函数</strong> <code>&#39;setColor&#39; : no matching overloaded function found</code></p><blockquote><p>C里面把函数写在void main()前面，或者需提前声明</p></blockquote><h1 id="推荐待更新"><a href="#推荐待更新" class="headerlink" title="推荐待更新"></a>推荐待更新</h1><blockquote><p>准备先过一遍教程再说….</p></blockquote><p><a href="https://www.flong.com/">Flong.com • Golan Levin &amp; Collaborators 的作品</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_poly/">Polynomial Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_exp/">Exponential Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_circ/index.html">Circular &amp; Elliptical Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_bez/">Bezier and Other Parametric Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><hr><p><a href="https://iquilezles.org/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><p><a href="https://iquilezles.org/articles/functions/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><hr><p><img src="https://thebookofshaders.com/05/kynd.png" alt="img"></p><hr><p><a href="https://www.shadertoy.com/view/XsXXDn">Creation by Silexars (shadertoy.com)</a></p><hr><p><a href="https://lygia.xyz/">LYGIA Shader Library</a></p><p><a href="https://graphtoy.com/">Graphtoy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>Cesium API学习 Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/</id>
    <published>2024-06-13T03:06:05.000Z</published>
    <updated>2024-06-13T02:41:45.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h1><p><strong>Cesium官网</strong> <a href="https://cesium.com/">Cesium: The Platform for 3D Geospatial</a></p><p><strong>CesiumJS:</strong><a href="https://cesium.com/learn/cesiumjs-learn/cesiumjs-quickstart/">CesiumJS Quickstart – Cesium</a></p><p><strong>Cesium for Unity:</strong><a href="https://cesium.com/learn/unity/">Cesium for Unity – Cesium</a></p><p><a href="https://zhuanlan.zhihu.com/p/452345666">Hello React Cesium - 知乎 (zhihu.com)</a></p><p><a href="https://cuifeng.blog.csdn.net/article/details/122828984?spm=1001.2014.3001.5502">React集成Cesium+ThreeJs流程汇总_react cesium-CSDN博客</a></p><h1 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h1><p><a href="https://www.cnblogs.com/tiandi/p/16580238.html">Cesium学习资源汇总</a></p><p><a href="https://sandcastle.cesium.com/">cesium官方案例</a></p><p><a href="https://github.com/vtxf/Cesium-Tutorials-Index">Cesium相关资料汇总</a>、<a href="https://zhuanlan.zhihu.com/p/557296232">汇总2</a></p><p><a href="https://pasu.github.io/ExamplesforCesium/examples/examples.html#Primer">cesium项目</a></p><p><a href="https://github.com/hujiulin/CesiumJS-tutorial/tree/master?tab=readme-ov-file">Cesium中文教程-github</a>, <a href="http://cesium.xin/wordpress/archives/16.html">cesium中文网</a></p><hr><p><strong>Cesium源码文件夹</strong><a href="https://sandcastle.cesium.com/">cesium官方案例</a>，<a href="https://cesium.com/learn/cesiumjs/ref-doc/">官方API文档</a></p><h1 id="Cesium基础知识"><a href="#Cesium基础知识" class="headerlink" title="Cesium基础知识"></a>Cesium基础知识</h1><p><a href="https://www.zhihu.com/column/c_1317874447190585344">学习链接</a></p><p><strong>Cesium的项目定位：B&#x2F;S架构下的客户端应用层面的三维开发框架</strong></p><p><img src="https://pic1.zhimg.com/v2-d566ed3f3b0bb0f8be5d099fb2393b10_r.jpg" alt="img"></p><p><strong>Cesium的学习路线：</strong></p><p><img src="https://pic4.zhimg.com/v2-7a32e7833314deff496ff31b5f48809f_r.jpg" alt="img"></p><p><strong>Cesium进阶之路：</strong></p><ul><li><strong>Web前端方向：</strong> Cesium与webpack（裁剪以及压缩），Cesium 与vue（框架设计， 嵌入复杂业务系统），Cesium的UI（UI 设计，定制可复用的Cesium交互界面）</li><li><strong>计算机图形学方向：</strong> WebGL深入，基于Cesium 的可视化定制（视阈、水淹、水面、热力图，流场图、飞线图、扫描图）</li><li><strong>数据预处理方向：</strong> 投影变换，空间索引，LOD ，3dtile 生成，数据存储，数据分发服务，解决超大空间数据如何在 Cesium上流畅可视化的问题。</li></ul><h2 id="Viewer"><a href="#Viewer" class="headerlink" title="Viewer"></a>Viewer</h2><p><img src="https://i.loli.net/2018/08/13/5b70f7cbf3693.jpg" alt="img"></p><p><strong>Cesium ion是一个提供瓦片图和3D地理空间数据的平台，Cesium ion支持把数据添加到用户自己的CesiumJS应用中。下面我们将使用Sentinal-2二维贴图和Cesium世界地形，二者都需要ion的支持。</strong></p><p><strong>备注</strong> 在我们使用Cesium的过程中，如果没有申请ion，同时没有自己的数据源用的cesium提供的数据源，viewer的底部常常会提示一行小的英文字母。大意就是需要申请access token.</p><ol><li><strong>打开</strong><a href="https://cesium.com/ion/">https://cesium.com/ion/</a> 然后注册一个新的账户。</li><li><strong>点击”Access Token”,</strong> 选择<em>Default</em>默认的access token拷贝到contents中。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Ion.defaultAccessToken =</span><br><span class="line">        &#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2NDk3OTUzYy01N2RjLTQyNDMtYTE1Zi0yYjgwNTJlZmYwOTAiLCJpZCI6MTk3MzM4LCJpYXQiOjE3MDg2NTc1NTh9.b8_XHsKZtIQVkUyk95dNvHHB4OE5nmebm5e_JFEIIbM&#x27;</span><br><span class="line">const viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;)</span><br></pre></td></tr></table></figure><p><strong>Viewer的类组织</strong></p><p><img src="https://img2022.cnblogs.com/blog/237138/202208/237138-20220812154924431-1555328076.png" alt="img"></p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul><li><strong>infoBox, 点击后弹出的右上方信息</strong></li><li><strong>selectionIndicator: 点击后在原地出现的绿色指示框</strong></li><li><strong>trackedEntity: Gets or sets the Entity instance currently being tracked by the camera.</strong></li><li><strong>orderIndependentTranslucency:</strong></li></ul><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li><strong>屏幕坐标，即二维笛卡尔平面坐标系</strong></li><li><strong>笛卡尔空间直角坐标&#x2F;世界坐标</strong>（红X，绿Z，蓝Y；X向前，Y向右，Z向上；</li><li><strong>地理坐标（弧度制），Cesium.Cartographic(lon, lat, height)，其中经纬度都是用弧度表示的</strong></li><li><strong>经纬度坐标，默认WGS84坐标系，</strong></li></ul><p><strong>坐标变换：</strong></p><ul><li>经纬度坐标转世界坐标：Cesium.Cartesian3.fromDegrees(lng, lat, height)</li><li>世界坐标转经纬度坐标：Cesium.Cartographic.fromCartesian(cartesian3)</li><li>地理坐标（弧度制）转经纬度坐标：lng&#x3D;Cesium.Math.toDegrees(cartographic.longitude), lat&#x3D;Cesium.Math.toDegrees(cartographic.latitude), height&#x3D;cartographic.height;</li><li>弧度转经纬度：Cesium.Math.toDegrees(radians)</li><li>经纬度转弧度：Cesium.Math.toRadians(degrees)</li><li>屏幕坐标转世界坐标：scene.globe.pick(viewer.camera.getPickRay(windowPosition), scene) —— 一定要保证屏幕坐标在球上，不然得到的就是undefined</li><li>世界坐标转屏幕坐标：Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene,cartesian3)</li></ul><p><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"></p><p><strong>空间变换：</strong></p><p><code>只有转换到笛卡尔坐标系后才能运用计算机图形学中的仿射变换知识进行空间位置变换如平移旋转缩放。Cesium为我们提供了如下几种很有用的变换工具类：</code></p><ul><li>Cesium.Cartesian3（相当于Point3D）</li><li>Cesium.Matrix3（3x3矩阵，用于描述旋转变换）</li><li>Cesium.Matrix4（4x4矩阵，用于描述旋转加平移变换）</li><li>Cesium.Quaternion（四元数，用于描述围绕某个向量*旋转一定角度的变换）</li><li>Cesium.Transforms(包含将位置转换为各种参考系的功能)</li></ul><p><strong>Cesium目前支持的坐标系：</strong></p><ul><li><strong>WGS1984， Terrain的TileSceme默认是这个</strong></li><li><strong>墨卡托投影，Imagery的TileSceme默认是这个</strong></li></ul><p><code>viewer.canvas.clientHeight - movement.endPosition.y</code> :</p><p><strong>在 Cesium 和其他 WebGL 应用中，</strong><code>viewer.canvas</code> 元素的坐标系通常遵循 HTML Canvas 元素的常见布局：</p><ol><li><strong>坐标系起点</strong> ：Canvas 坐标系的原点 (0, 0) 位于 Canvas 的左上角。</li><li><strong>X轴方向</strong> ：X轴从左向右增长，即坐标值从 0 增加到 <code>canvas.width</code>。</li><li><strong>Y轴方向</strong> ：Y轴从上向下增长，即坐标值从 0 增加到 <code>canvas.clientHeight</code>。</li></ol><p>针对代码行 <code>viewer.canvas.clientHeight - movement.endPosition.y</code>，这里所表达的含义和坐标参考如下：</p><ul><li><strong><code>viewer.canvas.clientHeight</code></strong> ：这是 Canvas 元素的高度，也就是 Y 轴的最大值。</li><li><strong><code>movement.endPosition.y</code></strong> ：这通常是鼠标事件（如点击或拖动事件）结束时的 Y 坐标位置。在 Cesium 中，这个坐标也遵循 Canvas 的坐标系，即 Y 坐标从上到下增大。</li></ul><h2 id="ImageryProvider"><a href="#ImageryProvider" class="headerlink" title="ImageryProvider"></a>ImageryProvider</h2><p>加载影像底图API: <code>CesiumImagery.vue, ImageryLoading.vue</code></p><blockquote><p><strong>Cesium.: ImageryLayer, IonWorldImageryStyle, SingleTileImageryProvider, GridImageryProvider, TileCoordinateImagery</strong></p><p><strong>viewer:</strong></p><ul><li><strong>.scene.imageryLayers: scene里的，更明确</strong></li><li><strong>.imageryLayers: Gets the collection of image layers that will be rendered on the globe. 更简洁，两者功能一样</strong></li></ul></blockquote><p><strong>两者对比</strong></p><p><strong>Imagery Provider使用特定的服务请求Tiles，而Layer表示来自Imagery Provider的displayed tiles。比如说,</strong></p><p><code>const layer = layers.addImageryProvider(imageryProvider);</code></p><p><strong>是</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const layer = new Cesium.ImageryLayer(imageryProvider);</span><br><span class="line">layers.add(layer);</span><br></pre></td></tr></table></figure><p>我们通常构建一个imagery provider只是为了创建一个layer; 然后我们使用layer的属性(如show、 alpha、brightness和contrast)操作该图层以改变其视觉外观。解耦decoupling imagery provider和layer使得编写新的imagery provider变得更加容易。</p><p>与上面示例中的Layer一样，imagery layer collection决定了图层绘制的顺序。layer是根据添加的顺序从底部到顶部绘制的。像Cesium中的任何其他集合一样，使用add, remove and get等函数操作imagery layer collection。此外，layer可以使用 raise、 raiseToTop、 lower 和 lowerTobottom 来重新排序。</p><p>Mapbox影像加载：</p><p>mapbox:&#x2F;&#x2F;styles&#x2F;foxziluliu1121&#x2F;clrzymvix009g01r67bowdcez</p><p><a href="https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></p><ul><li><strong>ImageryLayer, ImageryProvider,</strong></li><li>**Vector Tiles API:  **<a href="https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></li><li>**static tiles API:  **<code>https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</code></li><li><strong>Mapbox的数据格式：</strong><ul><li><strong>mapbox.mapbox-streets-v8</strong></li><li><code>foxziluliu1121.9mqo2ps2</code></li></ul></li></ul><h2 id="terrainProvider"><a href="#terrainProvider" class="headerlink" title="terrainProvider"></a>terrainProvider</h2><p>地形图层只能有一个；</p><p>地形类型：</p><ul><li>STK World Terrain</li><li>Small Terrain</li></ul><p>terrainProvider:</p><ul><li>EllipsoidTerrainProvider</li><li>CustomHeightmapTerrainProvider</li></ul><p>Ceisum案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Terrain.fromWorldTerrain(&#123;</span><br><span class="line">    requestWaterMask: true,</span><br><span class="line">    requestVertexNormals: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="加载矢量数据"><a href="#加载矢量数据" class="headerlink" title="加载矢量数据"></a>加载矢量数据</h2><ul><li>CustomDataSource</li><li>CzmlDataSource</li><li>GeoJsonDataSource, GeoJson, TopoJson</li><li>KmlDataSource</li><li></li></ul><h2 id="空间数据可视化"><a href="#空间数据可视化" class="headerlink" title="空间数据可视化"></a>空间数据可视化</h2><h3 id="Entity-API"><a href="#Entity-API" class="headerlink" title="Entity API"></a>Entity API</h3><p>以Graphics结尾：</p><ul><li>billboard, box, corridor, cylinder, ellipse, ellipsoid, label</li><li>model, tileset, path, plane,</li><li>point, polygon, polyline, polylineVolume, rectangle, wall,</li></ul><p><strong>使用注意点：</strong></p><p>在Cesium中，<code>Cesium.BoxGraphics</code>是用来定义一个实体（Entity）的盒状几何体的可视化属性的类。这个类本身并不负责将几何体添加到场景中；相反，它被用作描述实体的视觉外观的一部分。为了在Cesium的3D场景中显示一个盒状几何体，你需要将这个几何体与一个实体（Entity）关联，并将该实体添加到Cesium的实体集合中。这就是为什么在实践中，你看到的示例代码通常会使用 <code>viewer.entities.add()</code>来创建和添加带有盒状几何体的实体。</p><p>这里是一个简化的示例，说明如何使用 **<code>Cesium.BoxGraphics</code>通过 <code>viewer.entities.add()</code>添加一个盒状几何体到场景中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;);</span><br><span class="line"></span><br><span class="line">var box = viewer.entities.add(&#123;</span><br><span class="line">    position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 200000.0),</span><br><span class="line">    box: &#123;</span><br><span class="line">        dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),</span><br><span class="line">        material: Cesium.Color.BLUE.withAlpha(0.5),</span><br><span class="line">        outline: true,</span><br><span class="line">        outlineColor: Cesium.Color.BLACK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">viewer.zoomTo(viewer.entities);</span><br></pre></td></tr></table></figure><p><strong>在这个示例中：</strong></p><ul><li><code>viewer</code>是 <code>Cesium.Viewer</code>的一个实例，它是Cesium应用的主要界面。</li><li><code>viewer.entities.add(&#123;...&#125;)</code>是添加新实体到场景的方法。这个方法的参数是一个对象，描述了实体的各种属性，包括位置（<code>position</code>）、形状（在这个例子中是一个盒子，通过 <code>box</code>属性定义）等。</li><li><code>box</code>属性使用 <code>Cesium.BoxGraphics</code>的一个实例来定义盒状几何体的外观，包括尺寸（<code>dimensions</code>）、材质（<code>material</code>）、轮廓线是否可见（<code>outline</code>）以及轮廓线的颜色（<code>outlineColor</code>）。</li></ul><p><strong>总之，</strong><code>Cesium.BoxGraphics</code>提供了定义盒状几何体视觉外观的方式，而 <code>viewer.entities.add()</code>则是将这样定义的盒状几何体实体添加到Cesium场景中的方法。这种设计允许开发者以灵活的方式创建和管理场景中的对象，同时提供了丰富的API来定义这些对象的视觉外观。</p><p>EntityCluster类+PinBuilder类：实现billboards, points, labels的聚合</p><p>Entity管理：viewer.entities的类型是EntityCollection，包括了EntityCollection类里面的所有属性和方法，如.add(), .contains(), .getById(), .remove(), .removeAll(), .removeById()</p><p>Entity拾取：viewer.scene.pick(), viewer.scene.drillPick()</p><p>Entity固定：heightReference属性值，</p><h3 id="Primitive-API"><a href="#Primitive-API" class="headerlink" title="Primitive API"></a>Primitive API</h3><p>加载数据的性能更好，可以更好的加载3D Tiles数据。</p><p>Cesium.GeometryInstance()</p><p>Cesium.EllipsoidSurfaceAppearance</p><p>Cesium.Primitive()</p><p>scene.primitives.add()</p><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p><img src="https://s2.loli.net/2024/04/04/9bVKQRSEtL6Dnw4.png"></p><p><strong>MaterialProperty:</strong></p><ul><li>Cesium.ColorMaterialProperty</li><li>Cesium.ImageMaterialProperty</li><li></li></ul><h2 id="GLTF格式"><a href="#GLTF格式" class="headerlink" title="GLTF格式"></a>GLTF格式</h2><p><img src="https://pic2.zhimg.com/80/v2-a26039ef8457742c7121e9532289da51_1440w.webp" alt="img"></p><p><strong>Cesium加载gltf:</strong></p><ul><li>viewer.entities.add()</li><li>viewer.scene.primitives.add(), Cesium.Model.fromGltf()</li></ul><h2 id="3D-Tiles格式"><a href="#3D-Tiles格式" class="headerlink" title="3D Tiles格式"></a>3D Tiles格式</h2><p>3D Tiles可以理解为带有LOD的glTF,为流式传输和渲染海量3D数据而设计，例如倾斜摄影、3D建筑、BIM&#x2F;CAD，实例化要素集和点云。3D Tiles定义了一种数据分层结构和一组切片方式。</p><p><strong>组成：</strong></p><ul><li>描述瓦片集Tileset的JSON文件 —— tileset.json</li><li>一组瓦片Tile<ul><li>瓦片对象的格式可以：b3dm, i3dm, pnts, cmpt</li></ul></li></ul><p><strong>常用类：</strong></p><ul><li>Cesium3Dtileset：用于流式传输大量的异构3D地理空间数据集；</li><li>Cesium3DTileStyle：瓦片集样式；</li><li>Cesium3DTile：数据集中的一个瓦片;</li><li>Cesium3DTileContent：瓦片内容；</li><li>Cesium3DTileFeature：瓦片集要素，用于访问Tile中批量表中的属性数据，可通过scene.pick方法来获取一个 BATCH，即三维要素。Cesium3DTileFeature.getPropertyNames() 方法获取批量表中所有属性名，Cesium3DTileFeature.getProperty(string Name) 来获取对应属性名的属性值。</li></ul><p><strong>操作：</strong></p><ol><li>加载：viewer.scene.primitives.add(new Cesium.Cesium3DTileset())</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="Cesium3DTileset"><a href="#Cesium3DTileset" class="headerlink" title="Cesium3DTileset"></a>Cesium3DTileset</h4><p><a href="https://cesium.com/learn/cesiumjs/ref-doc/Cesium3DTileset.html?classFilter=Cesium3DTileset">官网链接</a></p><p><code>featureIdLabel</code> 属性在 Cesium 的 <code>Cesium3DTileset</code> 对象中用于指定用于拾取（picking）和样式化（styling）的特征 ID 集合。以下是对这段文档的详细解释和它的作用：</p><ol><li><strong>选择特征 ID 集合</strong>：<ul><li>在 <code>Cesium3DTileset</code> 中，<code>featureIdLabel</code> 用来标识和选择特定的特征 ID 集合。这对于执行拾取操作和应用样式至关重要，尤其是当模型包含多个特征 ID 集合时。</li></ul></li><li><strong>EXT_mesh_features 和 EXT_feature_metadata</strong>：<ul><li>对于遵循 <code>EXT_mesh_features</code> 扩展的数据，<code>featureIdLabel</code> 可以是特征 ID 的 <code>label</code> 属性，如果未指定，则默认为 <code>&quot;featureId_N&quot;</code>（N 是 featureIds 数组中的索引）。</li><li>对于旧的 <code>EXT_feature_metadata</code> 扩展，没有 <code>label</code> 字段，所以特征 ID 集总是以 <code>&quot;featureId_N&quot;</code> 标识，其中 N 是所有特征 ID 列表中的索引，特征 ID 属性在特征 ID 纹理之前列出。</li></ul></li><li><strong>特征 ID 标签的自动转换</strong>：<ul><li>如果 <code>featureIdLabel</code> 被设置为一个整数 N，它将自动转换为字符串 <code>&quot;featureId_N&quot;</code>。这意味着你可以简单地指定一个索引，Cesium 会自动解析为正确的特征 ID 标签。</li></ul></li><li><strong>优先级</strong>：<ul><li>如果同时存在每个基元（per-primitive）和每个实例（per-instance）的特征 IDs，实例特征 IDs 有优先权。这对于决定在冲突时哪组特征 ID 应该被使用是重要的。</li></ul></li></ol><p><strong>作用</strong></p><ul><li><strong>拾取和样式化</strong>：<ul><li>通过指定 <code>featureIdLabel</code>，开发者可以精确控制哪一组特征 ID 被用于交互（如鼠标拾取）和视觉样式化。这在处理包含复杂数据集的大型 3D Tiles 模型时尤其有用。</li></ul></li><li><strong>灵活性和控制</strong>：<ul><li>提供了对模型特征的更精细的控制，允许开发者基于具体的特征 ID 集来应用样式和执行拾取，特别是在模型中嵌入了多种数据层（如不同的物理部分或不同类型的数据标注）时。</li></ul></li><li><strong>实验性特性</strong>：<ul><li><strong>重要的是要注意，</strong><code>featureIdLabel</code> 是一个实验性特性，属于 3D Tiles 规范的一部分，该规范尚未最终确定。因此，使用这个特性时需要谨慎，因为它可能会在没有标准弃用政策的情况下改变。</li></ul></li></ul><p><code>featureIdLabel</code> 是一个强大的工具，用于在复杂的 3D Tiles 数据集中进行精确的交互和视觉表示。它使得开发者可以根据特定的特征 ID 集来定制模型的表现和行为，增强了模型与用户交互的能力和灵活性。但是，由于它的实验性质，使用时需要关注 Cesium 更新和变更。</p><h2 id="Cesium的Property"><a href="#Cesium的Property" class="headerlink" title="Cesium的Property"></a>Cesium的Property</h2><p><strong>基本property</strong></p><ul><li>CompositeProperty</li><li>ConstantProperty</li><li>SampledProperty</li><li>TimeIntervalCollectionProperty</li></ul><p><strong>Material的property</strong></p><p><strong>PositionProperty</strong></p><p><strong>其他</strong></p><p><img src="https://pic4.zhimg.com/80/v2-9cb0b7aa0c14747709a9dc455c7dccf7_720w.webp" alt="img"></p><h2 id="组件重写"><a href="#组件重写" class="headerlink" title="组件重写"></a>组件重写</h2><p>homeButton回到主要页面；</p><p>Geocoder组件通过OSM服务实现；</p><p>自定义BaseLayerPicker:</p><ul><li>viewer.baseLayerPicker.viewModel.imageryProviderViewModels</li><li>viewer.baseLayerPicker.viewModel.terrainProviderViewModels</li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>let handler &#x3D; new Cesium.ScreenSpaceEventHandler(viewer.canvas)</p><p>let eventType &#x3D; Cesium.ScreenSpaceEventType.LEFT_CLICK</p><p>handler.setInputAction((event) &#x3D;&gt; {}, eventType)</p><p>Keyboard: camera.moveForward, .moveBackward, .moveUp, .moveDown, .moveLeft, .moveRight</p><p>场景渲染: scene.preUpdate, .postUpdate, .preRender, .postRender</p><h2 id="相机控制"><a href="#相机控制" class="headerlink" title="相机控制"></a>相机控制</h2><p>viewer.flyTo(target, options)</p><p>viewer.zoomTo(target, offset)</p><p>viewer.camera.flyTo(options)</p><p>viewer.camera.flyToBoundingSphere(boundingSphere, options)</p><p>viewer.camera.lookAt(target, offset)</p><p>viewer.camera.lookAtTransform(transform, offset)</p><p>viewer.camera.setView(options)</p><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>距离</p><p>面积</p><p>handler.setInputAction(func(), Cesium.ScreenSpacEventType.RIGHT_CLICK)</p><h2 id="调试面板"><a href="#调试面板" class="headerlink" title="调试面板"></a>调试面板</h2><p>CesiumInspector</p><blockquote><p>了解Cesium渲染效果以及性能调优</p><p>viewer.extend(Cesium.viewerCesiumInspectorMixin)</p></blockquote><p>Cesium3DTilesInspector</p><blockquote><p>用于监视3D Tiles数据的监视器</p><p>viewer.extend(Cesium.viewerCesium3DTilesInspector)</p></blockquote><h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><p>new Cesium.ParticleSystem()</p><h2 id="场景后处理"><a href="#场景后处理" class="headerlink" title="场景后处理"></a>场景后处理</h2><p>postProgress类</p><p>postProgressStage</p><p>postProgressStageLibrary</p><p>postProgressStageCollection</p><h2 id="与第三方库集成"><a href="#与第三方库集成" class="headerlink" title="与第三方库集成"></a>与第三方库集成</h2><p>ThreeJS</p><ol><li>初始化两个容器，和各自的渲染器</li><li>调整各自的渲染频率和相机一致</li><li>加入要展示的内容</li></ol><p>ECharts</p><p>Heatmap</p><p>Turf</p><h2 id="源码打包"><a href="#源码打包" class="headerlink" title="源码打包"></a>源码打包</h2><p>gulp, webpack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初步了解&quot;&gt;&lt;a href=&quot;#初步了解&quot; class=&quot;headerlink&quot; title=&quot;初步了解&quot;&gt;&lt;/a&gt;初步了解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Cesium官网&lt;/strong&gt; &lt;a href=&quot;https://cesium.com/&quot;&gt;Cesium</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="Cesium" scheme="https://youxt-njnu.github.io/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>WebAPIs 知识点梳理</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/WebAPIs/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/WebAPIs/</id>
    <published>2024-06-13T01:33:26.000Z</published>
    <updated>2024-06-13T02:42:39.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ol><li><strong>API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现</strong></li><li><strong>Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。</strong></li><li><strong>Web API 一般都有输入和输出（ 函数的传参和返回值），Web API 很多都是方法（函数）</strong></li><li><strong>学习 Web API 可以结合前面学习内置对象方法的思路学习</strong></li></ol><h2 id="1-2-DOM-介绍"><a href="#1-2-DOM-介绍" class="headerlink" title="1.2. DOM 介绍"></a>1.2. DOM 介绍</h2><h3 id="1-2-1-什么是DOM"><a href="#1-2-1-什么是DOM" class="headerlink" title="1.2.1 什么是DOM"></a>1.2.1 什么是DOM</h3><p>**文档对象模型（Document Object Model，简称DOM），是 **<a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p><p><strong>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</strong></p><blockquote><p><strong>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</strong></p></blockquote><h3 id="1-2-2-DOM树"><a href="#1-2-2-DOM树" class="headerlink" title="1.2.2. DOM树"></a>1.2.2. DOM树</h3><p><img src="https://s2.loli.net/2024/06/13/bIQ3ek6qtW9CFBm.png"></p><p><strong>DOM树又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。</strong></p><ul><li><strong>文档：一个页面就是一个文档，DOM中使用document表示</strong></li><li><strong>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</strong></li><li><strong>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</strong></li></ul><p><strong>DOM把以上内容都看成对象；</strong></p><h2 id="1-3-获取元素"><a href="#1-3-获取元素" class="headerlink" title="1.3. 获取元素"></a>1.3. 获取元素</h2><p><strong>为什么要获取页面元素？</strong></p><p><strong>例如：我们想要操作页面上的某部分(显示&#x2F;隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。</strong></p><h3 id="1-3-1-根据ID获取"><a href="#1-3-1-根据ID获取" class="headerlink" title="1.3.1. 根据ID获取"></a>1.3.1. 根据ID获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementById(id)</span><br><span class="line">作用：根据ID获取元素对象</span><br><span class="line">参数：id值，区分大小写的字符串</span><br><span class="line">返回值：元素对象 或 null</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面</span><br><span class="line">        var timer = document.getElementById(&#x27;time&#x27;);</span><br><span class="line">        console.log(timer);</span><br><span class="line">        console.log(typeof timer);</span><br><span class="line">        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法</span><br><span class="line">        console.dir(timer);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/13/srPCptxVckEZMWQ.png"></p><h3 id="1-3-2-根据标签名获取元素"><a href="#1-3-2-根据标签名获取元素" class="headerlink" title="1.3.2. 根据标签名获取元素"></a>1.3.2. 根据标签名获取元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementsByTagName(&#x27;标签名&#x27;) 或者 element.getElementsByTagName(&#x27;标签名&#x27;) </span><br><span class="line">作用：根据标签名获取元素对象</span><br><span class="line">参数：标签名</span><br><span class="line">返回值：元素对象集合（伪数组，数组元素是元素对象）</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的</span><br><span class="line">        var lis = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">        console.log(lis[0]);</span><br><span class="line">        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式</span><br><span class="line">        for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">            console.log(lis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签</span><br><span class="line">        var nav = document.getElementById(&#x27;nav&#x27;); // 这个获得nav 元素</span><br><span class="line">        var navLis = nav.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(navLis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br><strong>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历</strong><br><strong>2.得到元素对象是动态的</strong></p><p><strong>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</strong></p><h3 id="1-3-3-H5新增获取元素方式"><a href="#1-3-3-H5新增获取元素方式" class="headerlink" title="1.3.3. H5新增获取元素方式"></a>1.3.3. H5新增获取元素方式</h3><p><strong>1.document.getElementsByclassName(‘类名’);&#x2F;&#x2F;根据类名返回元素对象集合</strong><br><strong>2.document.uerySelector(‘选择器)；&#x2F;&#x2F;根据指定选择器返回第一个元素对象</strong><br><strong>3.document.querySelectorAll(‘选择器’); &#x2F;&#x2F;根据指定选择器返回</strong><br><strong>注意：</strong><br><strong>querySelector和querySelectorAll里面的选择器需要加符号，比如：document.querySelector(‘#nav’);</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. getElementsByClassName 根据类名获得某些元素集合</span><br><span class="line">        var boxs = document.getElementsByClassName(&#x27;box&#x27;);</span><br><span class="line">        console.log(boxs);</span><br><span class="line">        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav</span><br><span class="line">        var firstBox = document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">        console.log(firstBox);</span><br><span class="line">        var nav = document.querySelector(&#x27;#nav&#x27;);</span><br><span class="line">        console.log(nav);</span><br><span class="line">        var li = document.querySelector(&#x27;li&#x27;);</span><br><span class="line">        console.log(li);</span><br><span class="line">        // 3. querySelectorAll()返回指定选择器的所有元素对象集合</span><br><span class="line">        var allBox = document.querySelectorAll(&#x27;.box&#x27;);</span><br><span class="line">        console.log(allBox);</span><br><span class="line">        var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-获取特殊元素（body，html）"><a href="#1-3-4-获取特殊元素（body，html）" class="headerlink" title="1.3.4 获取特殊元素（body，html）"></a>1.3.4 获取特殊元素（body，html）</h3><p><strong>获取body元素 1.doucumnet.body&#x2F;&#x2F;返回body元素对象</strong><br><strong>获取html元素 1.document.documentElement&#x2F;&#x2F;返回html元素对象</strong></p><h2 id="1-4-事件基础"><a href="#1-4-事件基础" class="headerlink" title="1.4. 事件基础"></a>1.4. 事件基础</h2><h3 id="1-4-1-事件概述"><a href="#1-4-1-事件概述" class="headerlink" title="1.4.1. 事件概述"></a>1.4.1. 事件概述</h3><p><strong>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</strong></p><p>**简单理解： **<strong>触发 — 响应机制</strong>。</p><p><strong>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</strong></p><h3 id="1-4-2-事件三要素"><a href="#1-4-2-事件三要素" class="headerlink" title="1.4.2. 事件三要素"></a>1.4.2. 事件三要素</h3><ul><li><strong>事件源（谁）：触发事件的元素</strong></li><li><strong>事件类型（什么事件）： 例如 click 点击事件</strong></li><li><strong>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</strong></li></ul><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 点击一个按钮，弹出对话框</span><br><span class="line">        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span><br><span class="line">        //(1) 事件源 事件被触发的对象   谁  按钮</span><br><span class="line">        var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span><br><span class="line">        //(3) 事件处理程序  通过一个函数赋值的方式 完成</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            alert(&#x27;点秋香&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-执行事件的步骤"><a href="#1-4-3-执行事件的步骤" class="headerlink" title="1.4.3. 执行事件的步骤"></a>1.4.3. 执行事件的步骤</h3><p><strong>1.获取事件源</strong><br><strong>2.注册事件（绑定事件）</strong><br><strong>3.添加事件处理程序（采取函数赋值形式）</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 执行事件步骤</span><br><span class="line">        // 点击div 控制台输出 我被选中了</span><br><span class="line">        // 1. 获取事件源</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.绑定事件 注册事件</span><br><span class="line">        // div.onclick </span><br><span class="line">        // 3.添加事件处理程序 </span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            console.log(&#x27;我被选中了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-常见的鼠标事件"><a href="#1-4-4-常见的鼠标事件" class="headerlink" title="1.4.4. 常见的鼠标事件"></a>1.4.4. 常见的鼠标事件</h3><p><img src="https://s2.loli.net/2024/06/13/DPX2E1hGYSAmIjo.png"></p><h3 id="1-4-5-分析事件三要素（见实操案例）"><a href="#1-4-5-分析事件三要素（见实操案例）" class="headerlink" title="1.4.5. 分析事件三要素（见实操案例）"></a>1.4.5. 分析事件三要素（见实操案例）</h3><ul><li><strong>下拉菜单三要素</strong></li><li><strong>关闭广告三要素</strong></li></ul><h2 id="1-5-操作元素"><a href="#1-5-操作元素" class="headerlink" title="1.5. 操作元素"></a>1.5. 操作元素</h2><p>**    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）**</p><h3 id="1-5-1-改变元素内容（获取或设置）"><a href="#1-5-1-改变元素内容（获取或设置）" class="headerlink" title="1.5.1. 改变元素内容（获取或设置）"></a>1.5.1. 改变元素内容（获取或设置）</h3><p><strong>element.innerText</strong><br><strong>从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</strong><br><strong>element.innerHTML</strong><br><strong>起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</strong></p><p><strong>innerText改变元素内容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;显示当前系统时间&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;某个时间&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;1123&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 当我们点击了按钮，  div里面的文字会发生变化</span><br><span class="line">        // 1. 获取元素 </span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.注册事件</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // div.innerText = &#x27;2019-6-6&#x27;;</span><br><span class="line">            div.innerHTML = getDate();</span><br><span class="line">        &#125;</span><br><span class="line">        function getDate() &#123;</span><br><span class="line">            var date = new Date();</span><br><span class="line">            // 我们写一个 2019年 5月 1日 星期三</span><br><span class="line">            var year = date.getFullYear();</span><br><span class="line">            var month = date.getMonth() + 1;</span><br><span class="line">            var dates = date.getDate();</span><br><span class="line">            var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">            var day = date.getDay();</span><br><span class="line">            return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day];</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>innerText和innerHTML的区别</strong></p><ul><li><strong>获取内容时的区别：</strong></li></ul><p>**    innerText会去除空格和换行，而innerHTML会保留空格和换行    **</p><ul><li><strong>设置内容时的区别：</strong></li></ul><p>**    innerText不会识别html，而innerHTML会识别**</p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        我是文字</span><br><span class="line">        &lt;span&gt;123&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // innerText 和 innerHTML的区别 </span><br><span class="line">        // 1. innerText 不识别html标签 非标准  去除空格和换行</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span><br><span class="line">        div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 这两个属性是可读写的  可以获取元素里面的内容</span><br><span class="line">        var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">        console.log(p.innerText);</span><br><span class="line">        console.log(p.innerHTML);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-常用元素的属性操作"><a href="#1-5-2-常用元素的属性操作" class="headerlink" title="1.5.2. 常用元素的属性操作"></a>1.5.2. 常用元素的属性操作</h3><p><strong>1.innerText,innerHTML 改变元素内容</strong><br><strong>2.src、href</strong><br><strong>3.id、alt、title</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;</span><br><span class="line">    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 修改元素属性  src</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var ldh = document.getElementById(&#x27;ldh&#x27;);</span><br><span class="line">        var zxy = document.getElementById(&#x27;zxy&#x27;);</span><br><span class="line">        var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line">        // 2. 注册事件  处理程序</span><br><span class="line">        zxy.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/zxy.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;张学友思密达&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        ldh.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/ldh.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;刘德华&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-案例：分时问候"><a href="#1-5-3-案例：分时问候" class="headerlink" title="1.5.3. 案例：分时问候"></a>1.5.3. 案例：分时问候</h3><p><img src="https://s2.loli.net/2024/06/13/ki3jF4NTnWQKRpL.png"></p><h3 id="1-5-4-表单元素的属性操作"><a href="#1-5-4-表单元素的属性操作" class="headerlink" title="1.5.4. 表单元素的属性操作"></a>1.5.4. 表单元素的属性操作</h3><p><strong>利用DOM可以操作如下表单元素的属性：</strong><br><strong>type、value、checked、selected、disabled</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p><p><strong>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var input = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // 表单里面的值 文字内容是通过 value 来修改的</span><br><span class="line">            input.value = &#x27;被点击了&#x27;;</span><br><span class="line">            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span><br><span class="line">            // btn.disabled = true;</span><br><span class="line">            this.disabled = true;</span><br><span class="line">            // this 指向的是事件函数的调用者 btn</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-案例：仿京东显示密码"><a href="#1-5-5-案例：仿京东显示密码" class="headerlink" title="1.5.5. 案例：仿京东显示密码"></a>1.5.5. 案例：仿京东显示密码</h3><p><img src="https://s2.loli.net/2024/06/13/G9BXQyrReOTxI65.png"></p><h3 id="1-5-6-样式属性操作"><a href="#1-5-6-样式属性操作" class="headerlink" title="1.5.6. 样式属性操作"></a>1.5.6. 样式属性操作</h3><p><strong>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</strong></p><p><strong>常用方式</strong></p><p><strong>1.element.style  行内样式操作</strong><br><strong>2.element.className  类名样式操作</strong></p><h4 id="方式1：通过操作style属性"><a href="#方式1：通过操作style属性" class="headerlink" title="方式1：通过操作style属性"></a>方式1：通过操作style属性</h4><blockquote><p><strong>元素对象的style属性也是一个对象！</strong></p><p><strong>元素对象.style.样式属性 &#x3D; 值;</strong></p></blockquote><p><strong>注意：</strong><br><strong>1.JS 里面的样式采取小驼峰命名法比如fontsize、backgroundColor</strong><br><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            // div.style里面的属性 采取驼峰命名法 </span><br><span class="line">            this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            this.style.width = &#x27;250px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：淘宝点击关闭二维码"><a href="#案例：淘宝点击关闭二维码" class="headerlink" title="案例：淘宝点击关闭二维码"></a>案例：淘宝点击关闭二维码</h4><p><img src="https://s2.loli.net/2024/06/13/M17o26KwY4Tx9yR.png"></p><h4 id="案例：循环精灵图背景"><a href="#案例：循环精灵图背景" class="headerlink" title="案例：循环精灵图背景"></a>案例：循环精灵图背景</h4><p><img src="https://s2.loli.net/2024/06/13/RHjG1g8Dzhw4kuB.png"></p><h4 id="案例：显示隐藏文本框内容"><a href="#案例：显示隐藏文本框内容" class="headerlink" title="案例：显示隐藏文本框内容"></a>案例：显示隐藏文本框内容</h4><p><img src="https://s2.loli.net/2024/06/13/yQxe7VT3YXpkrU5.png"></p><h4 id="方式2：通过操作className属性"><a href="#方式2：通过操作className属性" class="headerlink" title="方式2：通过操作className属性"></a>方式2：通过操作className属性</h4><blockquote><p><strong>元素对象.className &#x3D; 值;</strong></p><p><strong>因为class是关键字，所有使用className。</strong></p></blockquote><p><strong>注意：</strong><br><strong>1,如果样式修改较多，可以采取操作类名方式更改元素样式。</strong><br><strong>2.class因为是个保留字，因此使用className来操作元素类名属性</strong><br><strong>3.className 会直接更改元素的类名，会覆盖原先的类名。</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br><span class="line">        var test = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        test.onclick = function() &#123;</span><br><span class="line">            // this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            // this.style.color = &#x27;#fff&#x27;;</span><br><span class="line">            // this.style.fontSize = &#x27;25px&#x27;;</span><br><span class="line">            // this.style.marginTop = &#x27;100px&#x27;;</span><br><span class="line"></span><br><span class="line">            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br><span class="line">            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br><span class="line">            // this.className = &#x27;change&#x27;;</span><br><span class="line">            this.className = &#x27;first change&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：密码框格式提示错误信息"><a href="#案例：密码框格式提示错误信息" class="headerlink" title="案例：密码框格式提示错误信息"></a>案例：密码框格式提示错误信息</h4><p><img src="https://s2.loli.net/2024/06/13/6OkmXxy9sSY3bv7.png"></p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2024/06/13/5KReAgoXG1VIpdZ.png"></p><h2 id="1-6-H5自定义属性"><a href="#1-6-H5自定义属性" class="headerlink" title="1.6. H5自定义属性"></a>1.6. H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</strong></p><p><strong>自定义属性获取是通过getAttribute(‘属性’) 获取。</strong></p><p><strong>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</strong></p><p><strong>H5给我们新增了自定义属性：</strong></p><p><strong>1.设置H5自定义属性</strong><br><strong>H5规定自定义属性data-开头做为属性名并目赋值。</strong><br><strong>比如</strong> <code>&lt;div data-index=&quot;1&quot;&gt;</code><strong><code>&lt;/div&gt;</code></strong><br><strong>或者使用JS设置</strong><br><strong>element.setAttribute(‘data-index’,2)</strong></p><p><strong>2.获取H5自定义属性</strong><br><strong>1.兼容性获取element.getAttribute(‘data-index’):</strong><br><strong>2.H5新增element.dataset.index或者element.dataset[‘index’]   ie11才开始支持</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // console.log(div.getTime);</span><br><span class="line">        console.log(div.getAttribute(&#x27;getTime&#x27;));</span><br><span class="line">        div.setAttribute(&#x27;data-time&#x27;, 20);</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-index&#x27;));</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-list-name&#x27;));</span><br><span class="line">        // h5新增的获取自定义属性的方法 它只能获取data-开头的</span><br><span class="line">        // dataset 是一个集合里面存放了所有以data开头的自定义属性</span><br><span class="line">        console.log(div.dataset);</span><br><span class="line">        console.log(div.dataset.index);</span><br><span class="line">        console.log(div.dataset[&#x27;index&#x27;]);</span><br><span class="line">        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span><br><span class="line">        console.log(div.dataset.listName);</span><br><span class="line">        console.log(div.dataset[&#x27;listName&#x27;]);//data-list-name</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="1-7-节点操作"><a href="#1-7-节点操作" class="headerlink" title="1.7. 节点操作"></a>1.7. 节点操作</h2><p><strong>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</strong></p><ul><li><strong>元素节点nodeType为1</strong></li><li><strong>属性节点nodeType为2</strong></li><li><strong>文本节点nodeType为3(文本节点包含文字、空格、换行等)</strong></li></ul><p><strong>我们在实际开发中，节点操作主要操作的是元素节点</strong></p><h3 id="1-7-1-节点层级"><a href="#1-7-1-节点层级" class="headerlink" title="1.7.1. 节点层级"></a>1.7.1. 节点层级</h3><p>**    利用 DOM 树可以把节点划分为不同的层级关系，常见的是**<strong>父子兄层级关系</strong>。</p><p><img src="https://s2.loli.net/2024/06/13/Ogtv9nHuEMZqyhA.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.parentNode</span><br><span class="line">parentNode.childNodes</span><br><span class="line">parentNode.children</span><br><span class="line">parentNode.firstChild</span><br><span class="line">parentNode.lastChild</span><br><span class="line">parentNode.firstElementChild</span><br><span class="line">parentNode.lastElementChild</span><br><span class="line">parentNode.children[0]</span><br><span class="line">parentNode.children[parentNode.children.length-1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.nextSibling</span><br><span class="line">node.previousSibling</span><br><span class="line">node.nextElementSibling</span><br><span class="line">node.previousElementSibling</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   function getNextElementSibling(element) &#123;</span><br><span class="line">      var el = element;</span><br><span class="line">      while (el = el.nextSibling) &#123;</span><br><span class="line">        if (el.nodeType === 1) &#123;</span><br><span class="line">            return el;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;//是元素节点，就返回</span><br><span class="line">      return null;//不是元素节点，返回null</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><h3 id="1-7-2-节点操作"><a href="#1-7-2-节点操作" class="headerlink" title="1.7.2. 节点操作"></a>1.7.2. 节点操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createElement(&#x27;tagName&#x27;)</span><br><span class="line">node.appendChild(child)</span><br><span class="line">node.insertBefore(child,指定元素)</span><br><span class="line">node.removeChild(child)</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GIS集成案例汇报</title>
    <link href="https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/"/>
    <id>https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/</id>
    <published>2024-05-31T01:33:26.000Z</published>
    <updated>2024-06-13T01:51:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>地理信息集成课程汇报（与TLQ合作，感谢！）</p><p><img src="https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png" alt="1.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ogFZUMn2bLBsxHP.png" alt="2.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/2FgX7cUQiRzIfJd.png" alt="3.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/dLPKfYwCpylSWih.png" alt="4.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8fx5bjDVnpERuOd.png" alt="5.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=341481481&bvid=BV1CR4y1A78S&cid=717991642&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/M4D6bAowy8iZ7Yv.png" alt="7.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/imL2PkUsGajWxbF.png" alt="8.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ColDRx4TSG5Amh6.png" alt="9.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8cQWF73tgzKTjCn.png" alt="10.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/5JTNYdMo6naiU3O.png" alt="11.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/rdKkcylwaPmAG8i.png" alt="幻灯片12.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/kgHosDmy3AGECqT.png" alt="幻灯片13.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/GWtdX9sfi8VUIx1.png" alt="幻灯片14.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/1KMZYlqzh2Wy5s4.png" alt="幻灯片15.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/1KJnBzQ7edx4SYV.png" alt="幻灯片16.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/jo2gOWszI619Y7v.png" alt="幻灯片17.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/hnAwgIOZo3TtSs6.png" alt="幻灯片18.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/o76d5WrFwU4b8Gf.png" alt="幻灯片19.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/O9aCgdNFh4GmoyL.png" alt="幻灯片20.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/4SUDLPcJXMGzops.png" alt="幻灯片21.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/eVAFpTj6o1LwKv3.png" alt="幻灯片22.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/cfq8XexUyz16S5k.png" alt="幻灯片23.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/oN3VCuPRYZwMB8z.png" alt="幻灯片24.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地理信息集成课程汇报（与TLQ合作，感谢！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png&quot; alt=&quot;1.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli</summary>
      
    
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/categories/AR/"/>
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/tags/AR/"/>
    
    <category term="汇报PPT" scheme="https://youxt-njnu.github.io/tags/%E6%B1%87%E6%8A%A5PPT/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/</id>
    <published>2024-03-17T01:33:26.000Z</published>
    <updated>2024-03-17T01:42:27.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="11-对象"><a href="#11-对象" class="headerlink" title="11. 对象"></a>11. 对象</h2><ul><li><p><strong>利用字面量创建对象</strong></p><h5 id="使用对象字面量创建对象："><a href="#使用对象字面量创建对象：" class="headerlink" title="使用对象字面量创建对象："></a><strong>使用对象字面量创建对象</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就是花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法；&#123; &#125; 里面采取键值对的形式表示 </span><br></pre></td></tr></table></figure><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var star = &#123;</span><br><span class="line">    name : &#x27;pink&#x27;,</span><br><span class="line">    age : 18,</span><br><span class="line">    sex : &#x27;男&#x27;,</span><br><span class="line">    sayHi : function()&#123;</span><br><span class="line">        alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中 star即是创建的对象。</p></li></ul></li><li><p>对象的使用</p><ul><li><p>对象的属性</p><ul><li>对象中存储具体数据的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储函数的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”</li><li>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号<br><strong>示例代码如下：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(star.name)     // 调用名字属性</span><br><span class="line">console.log(star[&#x27;name&#x27;])  // 调用名字属性</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>调用对象的方法</strong></p><ul><li>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号<br>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>变量、属性、函数、方法总结</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</span><br></pre></td></tr></table></figure><ul><li>变量：单独声明赋值，单独存在</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征<br>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</li><li>函数：单独存在的，通过“函数名()”的方式就可以调用</li><li>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能</li></ul></li></ul></li><li><p><strong>利用 new Object 创建对象</strong></p><ul><li><p>创建空对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var andy = new Obect();</span><br></pre></td></tr></table></figure><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li>通过对象操作属性和方法的方式，来为对象增加属性和方法<br>示例代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">andy.name = &#x27;pink&#x27;;</span><br><span class="line">andy.age = 18;</span><br><span class="line">andy.sex = &#x27;男&#x27;;</span><br><span class="line">andy.sayHi = function()&#123;</span><br><span class="line">    alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Object() ：第一个字母大写</li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 &#x3D;  值;</li></ul></li></ul></li><li><p><strong>利用构造函数创建对象</strong></p><ul><li>构造函数<ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 构造函数名(形参1,形参2,形参3) &#123;</span><br><span class="line">     this.属性名1 = 参数1;</span><br><span class="line">     this.属性名2 = 参数2;</span><br><span class="line">     this.属性名3 = 参数3;</span><br><span class="line">     this.方法名 = 函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数的调用格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new 构造函数名(实参1，实参2，实参3)</span><br></pre></td></tr></table></figure><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>构造函数约定首字母大写。</li><li>函数内的属性和方法前面需要添加<strong>this</strong> ，表示当前对象的属性和方法。</li><li><strong>构造函数中不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ol></li><li><p><strong>其他</strong><br>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul></li></ul></li><li><p><strong>new关键字的作用</strong></p><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h3 id="5-3-遍历对象"><a href="#5-3-遍历对象" class="headerlink" title="5.3 遍历对象"></a>5.3 遍历对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for...in 语句用于对数组或者对象的属性进行循环操作。</span><br><span class="line"></span><br><span class="line">其语法如下：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (变量 in 对象名字) &#123;</span><br><span class="line">    // 在此执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var k in obj) &#123;</span><br><span class="line">    console.log(k);      // 这里的 k 是属性名</span><br><span class="line">    console.log(obj[k]); // 这里的 obj[k] 是属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-内置对象"><a href="#1-1-内置对象" class="headerlink" title="1.1 内置对象"></a>1.1 内置对象</h3><p>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象<br><strong>前面两种对象是JS 基础内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是</strong>最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发</p><p>**JavaScript 提供了多个内置对象：Math、 Date 、Array、String等    **</p><h3 id="1-2-查文档"><a href="#1-2-查文档" class="headerlink" title="1.2 查文档"></a>1.2 查文档</h3><p>查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN&#x2F;W3C来查询。<br>Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。<br>MDN:<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h3 id="1-3-Math对象"><a href="#1-3-Math对象" class="headerlink" title="1.3 Math对象"></a>1.3 Math对象</h3><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()&#x2F;Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p><strong>注意：上面的方法使用时必须带括号</strong></p><p>获取指定范围内的随机整数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用对象封装自己的数学对象  里面有 PI 最大值和最小值</span><br><span class="line">        var myMath = &#123;</span><br><span class="line">            PI: 3.141592653,</span><br><span class="line">            max: function() &#123;</span><br><span class="line">                var max = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &gt; max) &#123;</span><br><span class="line">                        max = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return max;</span><br><span class="line">            &#125;,</span><br><span class="line">            min: function() &#123;</span><br><span class="line">                var min = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &lt; min) &#123;</span><br><span class="line">                        min = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(myMath.PI);</span><br><span class="line">        console.log(myMath.max(1, 5, 9));</span><br><span class="line">        console.log(myMath.min(1, 5, 9));</span><br></pre></td></tr></table></figure><h3 id="1-4-日期对象"><a href="#1-4-日期对象" class="headerlink" title="1.4 日期对象"></a>1.4 日期对象</h3><p>Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var now = new Date();</span><br></pre></td></tr></table></figure><ul><li>获取指定时间的日期对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var future = new Date(&#x27;2019/5/1&#x27;);</span><br></pre></td></tr></table></figure><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p><strong>使用Date实例的方法和属性</strong><br><img src="https://s2.loli.net/2024/03/17/Bt7q6c4fYMbLpgr.png" alt="图片1"></p></li><li><p>通过Date实例获取总毫米数</p><ul><li>总毫秒数的含义<br>基于1970年1月1日（世界标准时间）起的毫秒数</li><li>获取总毫秒数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实例化Date对象</span><br><span class="line">var now = new Date();</span><br><span class="line">// 1. 用于获取对象的原始值</span><br><span class="line">console.log(date.valueOf())    </span><br><span class="line">console.log(date.getTime())    </span><br><span class="line">// 2. 简单写可以这么做</span><br><span class="line">var now = + new Date();            </span><br><span class="line">// 3. HTML5中提供的方法，有兼容性问题</span><br><span class="line">var now = Date.now();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-数组对象"><a href="#1-5-数组对象" class="headerlink" title="1.5 数组对象"></a>1.5 数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li>字面量方式<ul><li>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,&quot;test&quot;,true];</span><br></pre></td></tr></table></figure></li></ul></li><li>new Array()<ul><li><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li>如果只传入一个参数，则参数规定了数组的长度</li><li>如果传入了多个参数，则参数称为数组的元素</li></ul></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li>instanceof 运算符<ul><li>instanceof 可以判断一个对象是否是某个构造函数的实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line">console.log(obj instanceof Array); // false</span><br></pre></td></tr></table></figure></li></ul></li><li>Array.isArray()<ul><li>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(Array.isArray(arr));   // true</span><br><span class="line">console.log(Array.isArray(obj));   // false</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><ul><li>数组中有进行增加、删除元素的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/uebmUwin5S3j91r.png" alt="pushpop"><br>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</li></ul><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li><strong>数组中有对数组本身排序的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/DOPv2ZCqMBnpmsN.png"><br>注意：sort方法需要传入参数来设置升序、降序排序<ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul></li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><ul><li>数组中有获取数组指定元素索引值的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/IFPG26TQdrbw1NK.png"></li></ul><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><ul><li><strong>数组中有把数组转化为字符串的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/fGBnsd1I65ZK7tz.png"><br><strong>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</strong></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>数组中还有其他操作方法，同学们可以在课下自行查阅学习<br><img src="https://s2.loli.net/2024/03/17/3iDC7uAtBHdKRGr.png"></li></ul><h3 id="1-6-字符串对象"><a href="#1-6-字符串对象" class="headerlink" title="1.6 字符串对象"></a>1.6 字符串对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 下面代码有什么问题？</span><br><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure><p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="line">var temp = new String(&#x27;andy&#x27;);</span><br><span class="line">// 2. 赋值给我们声明的字符变量</span><br><span class="line">str = temp;</span><br><span class="line">// 3. 销毁临时变量</span><br><span class="line">temp = null;</span><br></pre></td></tr></table></figure><h4 id="字符串的不可变"><a href="#字符串的不可变" class="headerlink" title="字符串的不可变"></a>字符串的不可变</h4><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><p>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>由于字符串的不可变，在****大量拼接字符串的时候会有效率问题</p><h4 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p><p><img src="https://s2.loli.net/2024/03/17/7QdYZoglVsuOrxw.png"></p><p><strong>案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;oabcoefoxyozzopp&quot;;</span><br><span class="line">var index = str.indexOf(&#x27;o&#x27;);</span><br><span class="line">var num = 0;</span><br><span class="line">// console.log(index);</span><br><span class="line">while (index !== -1) &#123;</span><br><span class="line">      console.log(index);</span><br><span class="line">      num++;</span><br><span class="line">      index = str.indexOf(&#x27;o&#x27;, index + 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;o出现的次数是: &#x27; + num);</span><br></pre></td></tr></table></figure><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p><p><img src="https://s2.loli.net/2024/03/17/6S5Z3Ezf4BYJH9T.png"></p><p>案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      var o = &#123;&#125;;</span><br><span class="line">      var str = &quot;abcoefoxyozzopp&quot;;</span><br><span class="line">      //   for (var k in str) &#123;</span><br><span class="line">      //     if (o[str[k]]) &#123;</span><br><span class="line">      //       o[str[k]]++;</span><br><span class="line">      //     &#125; else &#123;</span><br><span class="line">      //       o[str[k]] = 1;</span><br><span class="line">      //     &#125;</span><br><span class="line">      //   &#125;</span><br><span class="line">      for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        var chars = str.charAt(i);</span><br><span class="line">        if (o[chars]) &#123;</span><br><span class="line">          o[chars]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          o[chars] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(o);</span><br><span class="line">      var max = 0;</span><br><span class="line">      var ch = &quot;&quot;;</span><br><span class="line">      for (var k in o) &#123;</span><br><span class="line">        if (o[k] &gt; max) &#123;</span><br><span class="line">          max = o[k];</span><br><span class="line">          ch = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(max);</span><br><span class="line">      console.log(ch);</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p><strong>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</strong></p><p><img src="https://s2.loli.net/2024/03/17/zO5PavVILoNGh9l.png"></p><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p><strong>replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.replace(被替换的字符串， 要替换为的字符串)；</span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p><strong>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.split(&quot;分割字符&quot;)</span><br></pre></td></tr></table></figure><h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><p><strong>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;//构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function f1(x) &#123; // x = p</span><br><span class="line">    console.log(x.name); // 2.刘德华   </span><br><span class="line">    x.name = &quot;张学友&quot;;</span><br><span class="line">    console.log(x.name); // 3. 张学友  </span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;刘德华&quot;); //实例</span><br><span class="line">console.log(p.name);    // 1.刘德华</span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name);    // 4. 张学友</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/</id>
    <published>2024-03-17T01:27:26.000Z</published>
    <updated>2024-03-17T01:32:58.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="7-运算符（操作符）"><a href="#7-运算符（操作符）" class="headerlink" title="7. 运算符（操作符）"></a>7. 运算符（操作符）</h2><p><strong>浮点数的精度问题</strong></p><p><strong>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;    <span class="comment">// 结果不是 0.3，而是：0.30000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.07</span> * <span class="number">100</span>);   <span class="comment">// 结果不是 7，  而是：7.000000000000001</span></span><br></pre></td></tr></table></figure><p><strong>所以：不要直接判断两个浮点数是否相等 !</strong></p><h2 id="8-断点调试"><a href="#8-断点调试" class="headerlink" title="8. 断点调试"></a>8. 断点调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试的流程：</span><br><span class="line">1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点</span><br><span class="line">2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。</span><br><span class="line">3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</span><br></pre></td></tr></table></figure><p><strong>标识符命名规范</strong></p><ul><li><strong>变量、函数的命名必须要有意义</strong></li><li><strong>变量的名称一般用名词</strong></li><li><strong>函数的名称一般用动词</strong></li></ul><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><p><strong>JS 中创建数组有两种方式：</strong></p><ul><li><p><strong>利用  new 创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>() ；</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// 创建一个新的空数组</span></span><br></pre></td></tr></table></figure><p><strong>注意 Array () ，A 要大写</strong></p></li><li><p><strong>利用数组字面量创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []；</span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>**数组的字面量是方括号 [ ] **</li><li><strong>声明数组并赋值称为数组的初始化</strong></li><li><strong>这种字面量方式也是我们以后最多使用的方式</strong></li></ul></li><li><p><strong>数组元素的类型</strong><br><strong>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrStus = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">12</span>,<span class="literal">true</span>,<span class="number">28.9</span>];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 获取数组中的第2个元素</span></span><br><span class="line"><span class="title function_">alert</span>(arrStus[<span class="number">1</span>]);    </span><br></pre></td></tr></table></figure><p><strong>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</strong></p><ul><li><p><strong>数组的长度</strong><br><strong>数组的长度：默认情况下表示数组中元素的个数</strong><br><strong>使用“数组名.length”可以访问数组元素的数量（数组长度）。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrStus = [1,2,3];</span><br><span class="line">alert(arrStus.length);  // 3</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p></li><li><p><strong>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</strong></p></li><li><p><strong>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</strong></p></li><li><p><strong>数组的length属性可以被修改：</strong></p></li><li><p><strong>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</strong></p></li><li><p><strong>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</strong></p></li></ul><h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明函数</span><br><span class="line">function 函数名() &#123;</span><br><span class="line">    //函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>function 是声明函数的关键字,必须小写</strong></p></li><li><p><strong>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</strong></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用函数</span><br><span class="line">函数名();  // 通过调用函数名来执行函数体代码</span><br></pre></td></tr></table></figure><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p><strong>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</strong></p></li><li><p><strong>具有 length 属性</strong></p></li><li><p><strong>按索引方式储存数据</strong></p></li><li><p><strong>不具有数组的 push , pop 等方法</strong><br><strong>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</strong></p></li></ul><h3 id="函数案例"><a href="#函数案例" class="headerlink" title="函数案例"></a>函数案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</span><br></pre></td></tr></table></figure><h3 id="函数的两种声明方式"><a href="#函数的两种声明方式" class="headerlink" title="函数的两种声明方式"></a>函数的两种声明方式</h3><ul><li><p><strong>自定义函数方式(命名函数)</strong><br><strong>利用函数关键字 function 自定义函数方式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明定义方式</span><br><span class="line">function fn() &#123;...&#125;</span><br><span class="line">// 调用  </span><br><span class="line">fn();  </span><br></pre></td></tr></table></figure><ul><li><strong>因为有名字，所以也被称为命名函数</strong></li><li><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></li></ul></li><li><p><strong>函数表达式方式(匿名函数）</strong><br>**利用函数表达式方式的写法如下： **</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是函数表达式写法，匿名函数后面跟分号结束</span><br><span class="line">var fn = function()&#123;...&#125;；</span><br><span class="line">// 调用的方式，函数调用必须写到函数体下面</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ul><li><strong>因为函数没有名字，所以也被称为匿名函数</strong></li><li>**这个fn 里面存储的是一个函数  **</li><li><strong>函数表达式方式原理跟声明变量方式是一致的</strong></li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ul></li></ul><h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10 - 作用域"></a>10 - 作用域</h2><h3 id="1-1-作用域概述"><a href="#1-1-作用域概述" class="headerlink" title="1.1 作用域概述"></a>1.1 作用域概述</h3><p><strong>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</strong></p><p><strong>JavaScript（es6前）中的作用域有两种：</strong></p><ul><li><strong>全局作用域</strong></li><li><strong>局部作用域（函数作用域）</strong></li></ul><h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于所有代码执行的环境(整个script标签内部)或独立的js文件。</span><br></pre></td></tr></table></figure><h3 id="1-3-局部作用域"><a href="#1-3-局部作用域" class="headerlink" title="1.3 局部作用域"></a>1.3 局部作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于函数内的代码环境，就是局部作用域。 </span><br><span class="line">因为跟函数有关系，所以也称为函数作用域。</span><br></pre></td></tr></table></figure><h3 id="1-4-jS没有块级作用域"><a href="#1-4-jS没有块级作用域" class="headerlink" title="1.4 jS没有块级作用域"></a>1.4 jS没有块级作用域</h3><ul><li><strong>块作用域由 { } 包括。</strong></li><li><strong>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用；</strong><br><strong>js中没有块级作用域（在ES6之前）</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">  var num = 123;</span><br><span class="line">  //console.log(num); //123</span><br><span class="line">&#125;</span><br><span class="line">console.log(num);   //123</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-变量的作用域"><a href="#1-5-变量的作用域" class="headerlink" title="1.5 变量的作用域"></a>1.5 变量的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在JavaScript中，根据作用域的不同，变量可以分为两种：</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li><li><strong>局部变量</strong></li></ul><p><strong>2.1 全局变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量在代码的任何位置都可以使用</strong></li><li><strong>在全局作用域下 var 声明的变量 是全局变量</strong></li><li><strong>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</strong></li></ul><p><strong>2.2 局部变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</span><br></pre></td></tr></table></figure><ul><li><strong>局部变量只能在该函数内部使用</strong></li><li><strong>在函数内部 var 声明的变量是局部变量</strong></li><li><strong>函数的形参实际上就是局部变量</strong></li></ul><p><strong>2.3 全局变量和局部变量的区别</strong></p><ul><li><strong>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</strong></li><li><strong>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</strong></li></ul><h3 id="1-6-作用域链"><a href="#1-6-作用域链" class="headerlink" title="1.6 - 作用域链"></a>1.6 - 作用域链</h3><p><strong>只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在</strong>**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例分析1：</span><br><span class="line">function f1() &#123;</span><br><span class="line">    var num = 123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">        console.log( num );//123</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line">var num = 456;</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域链：采取就近原则的方式来查找变量最终的值</span><br><span class="line">var a = 1;</span><br><span class="line">function fn1() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    var b = &#x27;22&#x27;;</span><br><span class="line">    fn2();</span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        var a = 3;</span><br><span class="line">        fn3();</span><br><span class="line">        function fn3() &#123;</span><br><span class="line">            var a = 4;</span><br><span class="line">            console.log(a); //a的值 4</span><br><span class="line">            console.log(b); //b的值 22</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><p><img src="file://F:/20-%E6%B1%82%E8%81%8C/02-%E5%89%8D%E7%AB%AF/images/js/%E5%9B%BE%E7%89%872-16779152458061.png?lastModify=1710638944"></p><h3 id="1-7-预解析"><a href="#1-7-预解析" class="headerlink" title="1.7 - 预解析"></a>1.7 - 预解析</h3><p><strong>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。</strong></p><p><strong>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：</strong></p><p><strong>预解析和代码执行。</strong></p><ul><li><strong>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</strong>，预解析也叫做变量、函数提升。</li><li><strong>代码执行： 从上到下执行JS语句。</strong><br><strong>注意：****预解析会把变量和函数的声明在代码执行之前执行完成。</strong></li></ul><p><strong>变量预解析：</strong></p><p><strong>变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(num);  // undefined</span><br><span class="line">var num = 10;</span><br><span class="line">//注意：变量提升只提升声明，不提升赋值</span><br></pre></td></tr></table></figure><p><strong>函数预解析：</strong></p><p><strong>函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;打印&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：控制台打印字符串 — ”打印“</strong></p><p><strong>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！</strong></p><p><strong>函数表达式声明函数问题：</strong></p><p><strong>函数表达式创建函数，会执行变量提升</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">var  fn = function() &#123;</span><br><span class="line">    console.log(&#x27;想不到吧&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：报错提示 ”fn is not a function”</strong></p><blockquote><p><strong>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>react+vite+hexo|项目呈现</title>
    <link href="https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"/>
    <id>https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</id>
    <published>2024-03-10T03:51:26.000Z</published>
    <updated>2024-03-09T03:55:48.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yayuya/p/17046666.html">Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/7208946311885586492">通过Hexo + Github Pages部署你的react项目 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yayuya/p/17046666.html&quot;&gt;Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post</summary>
      
    
    
    
    <category term="周边扩展" scheme="https://youxt-njnu.github.io/categories/%E5%91%A8%E8%BE%B9%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
    <category term="Hexo" scheme="https://youxt-njnu.github.io/tags/Hexo/"/>
    
    <category term="个人博客" scheme="https://youxt-njnu.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅱ(补)</title>
    <link href="https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%9821/"/>
    <id>https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%9821/</id>
    <published>2024-03-09T03:34:05.000Z</published>
    <updated>2024-06-13T02:14:51.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关库补充"><a href="#相关库补充" class="headerlink" title="相关库补充"></a>相关库补充</h1><h2 id="react-vertical-timeline-component"><a href="#react-vertical-timeline-component" class="headerlink" title="react-vertical-timeline-component"></a>react-vertical-timeline-component</h2><p><code>react-vertical-timeline-component</code> 是一个React库，用于创建和显示垂直时间线。这个库提供了一种简单而有效的方式来展示按时间顺序排列的事件或步骤，非常适合用于展示项目里程碑、历史事件、工作经历等。它基于React开发，因此可以轻松地集成到现有的React应用中。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>易于使用</strong>：通过提供的组件和属性，开发者可以快速构建出美观、响应式的时间线。</li><li><strong>高度可定制</strong>：支持自定义颜色、图标和内容，使时间线能够匹配应用的风格和主题。</li><li><strong>响应式设计</strong>：时间线会自动适应不同屏幕尺寸，保证在移动设备和桌面设备上都能良好展示。</li><li><strong>动画效果</strong>：内置动画效果，为时间线的展示增添视觉吸引力。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要开始使用 <code>react-vertical-timeline-component</code>，首先需要将它添加到你的React项目中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react-vertical-timeline-component</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">yarn add react-vertical-timeline-component</span><br></pre></td></tr></table></figure><p>接下来，你可以在你的组件中引入并使用时间线组件及其相关的子组件。以下是一个简单的示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">VerticalTimeline</span>,</span><br><span class="line">  <span class="title class_">VerticalTimelineElement</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-vertical-timeline-component&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;react-vertical-timeline-component/style.min.css&#x27;</span>; <span class="comment">// 引入样式文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyTimeline</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">VerticalTimeline</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">VerticalTimelineElement</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element--work&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">date</span>=<span class="string">&quot;2011 - present&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">iconStyle</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> &#x27;<span class="attr">rgb</span>(<span class="attr">33</span>, <span class="attr">150</span>, <span class="attr">243</span>)&#x27;, <span class="attr">color:</span> &#x27;#<span class="attr">fff</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      // <span class="attr">icon</span>=<span class="string">&#123;</span>&lt;<span class="attr">WorkIcon</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span> <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element-title&quot;</span>&gt;</span>Creative Director<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element-subtitle&quot;</span>&gt;</span>Miami, FL<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Creative Direction, User Experience, Visual Design, Project Management, Team Leading</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">VerticalTimelineElement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 可以添加更多的 VerticalTimelineElement 组件来展示其他事件 */&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">VerticalTimeline</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyTimeline</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>VerticalTimeline</code>是容纳所有时间线元素的容器，而 <code>VerticalTimelineElement</code>代表时间线上的单个事件或里程碑。你可以通过传递不同的props来定制每个时间线元素的外观和内容。</p><h3 id="自定义和样式"><a href="#自定义和样式" class="headerlink" title="自定义和样式"></a>自定义和样式</h3><p><code>react-vertical-timeline-component</code>提供了多种方式来定制时间线的样式和行为：</p><ul><li><strong>颜色和图标</strong>：通过 <code>iconStyle</code>属性自定义图标样式，以及通过 <code>icon</code>属性添加自定义图标。</li><li><strong>内容布局</strong>：每个 <code>VerticalTimelineElement</code>可以包含标题、副标题和任意的HTML内容，允许灵活地展示信息。</li><li><strong>自定义类名</strong>：可以为时间线元素添加自定义CSS类名，进一步通过CSS来定制样式。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>react-vertical-timeline-component</code>是一个功能丰富且易于使用的React库，它能够帮助开发者在应用中快速创建出美观、响应式的垂直时间线。通过广泛的定制选项，它能够满足多种展示需求，使得时间线既能传达必要的信息，又具有吸引人的视觉效果。</p><h2 id="emailjs-x2F-browser"><a href="#emailjs-x2F-browser" class="headerlink" title="@emailjs&#x2F;browser"></a>@emailjs&#x2F;browser</h2><p><code>@emailjs/browser</code> 是一个JavaScript库，用于在客户端直接从前端应用中发送电子邮件，无需后端服务器。通过使用 EmailJS 服务，开发者可以在Web页面中集成电子邮件发送功能，而不需要编写服务器端代码或存储用户的电子邮件凭据。这使得在联系表单、通知系统或任何需要发送电子邮件的场景中，实现邮件发送变得异常简单和安全。</p><h3 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>无服务器</strong>：不需要自己的服务器来发送电子邮件，减少了开发和维护成本。</li><li><strong>简单易用</strong>：提供了简洁的API，可以快速在前端代码中集成和使用。</li><li><strong>安全</strong>：不需要在客户端暴露敏感信息，如SMTP服务器登录凭据等。</li><li><strong>灵活性</strong>：支持自定义电子邮件模板，可以根据需要发送不同内容的邮件。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>**通过npm或yarn安装 **<code>@emailjs/browser</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @emailjs/browser</span><br><span class="line"># 或者</span><br><span class="line">yarn add @emailjs/browser</span><br></pre></td></tr></table></figure><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>**要使用 **<code>@emailjs/browser</code>发送电子邮件，首先需要在 EmailJS 网站上注册账户，创建邮件模板，并获取必要的服务ID、模板ID和用户ID。</p><p>**在React项目中使用 **<code>emailjs</code>或任何其他依赖于环境变量的服务时，创建一个 <code>.env.local</code>文件的主要目的是为了安全和配置的灵活性。这个文件被用来存储敏感信息和项目配置，如API密钥、服务ID、用户ID等，这些信息对于应用的运行至关重要，但你不希望它们被直接硬编码到源代码中或被提交到版本控制系统（如Git）中。这样做主要有以下几个原因：</p><ol><li><strong>安全性</strong>：保护你的敏感信息不被公开，如API密钥和密码。如果这些信息被硬编码在应用程序的源代码中，并且源代码被上传到了公开的代码仓库，那么这些敏感信息就有泄露的风险。</li><li><strong>配置的灵活性</strong>：允许你在不同的环境（开发、测试、生产等）中使用不同的配置，而不需要改变代码。比如，在开发环境和生产环境中使用不同的API密钥。</li><li><strong>便于维护</strong>：将配置从代码中分离，使得配置的更改更加容易，而不需要每次都触摸代码本身。</li></ol><p><code>.env.local</code>是一种特殊的 <code>.env</code>文件，它被设计用来在你的本地开发环境中覆盖 <code>.env</code>文件中的默认设置。React和许多其他现代前端框架都支持使用 <code>.env</code>文件来定义环境变量。这些变量在构建过程中会被嵌入到最终的JavaScript包中，因此在运行时可以访问它们。</p><p>**要在React项目中使用 **<code>.env.local</code>中定义的环境变量，你需要遵循以下步骤：</p><ol><li>**在项目根目录下创建一个 **<code>.env.local</code>文件。</li><li>**在 **<code>.env.local</code>文件中添加环境变量，遵循 <code>REACT_APP_</code>前缀的规则。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REACT_APP_EMAILJS_USER_ID=你的用户ID</span><br><span class="line">REACT_APP_EMAILJS_SERVICE_ID=你的服务ID</span><br><span class="line">REACT_APP_EMAILJS_TEMPLATE_ID=你的模板ID</span><br></pre></td></tr></table></figure></li><li>**在你的React应用中，你可以通过 **<code>process.env.REACT_APP_EMAILJS_USER_ID</code>这样的方式访问这些变量。</li></ol><p>**使用 **<code>.env.local</code>文件是一种实践，旨在提高项目的安全性和配置的灵活性，特别是当涉及到处理敏感信息时。这种方法有助于避免将敏感数据暴露给公众，同时还提供了在不同环境下轻松切换配置的能力。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_APP_EMAILJS_SERVICE_ID=service_5bezaam</span><br><span class="line">VITE_APP_EMAILJS_TEMPLATE_ID=template_dafnzfi</span><br><span class="line">VITE_APP_EMAILJS_PUBLIC_KEY=JpbkxBEdlS8faxCrq</span><br></pre></td></tr></table></figure><p><strong>在使用Vite作为构建工具的项目中，环境变量的命名遵循特定的前缀规则，这是为了确保这些变量在构建时被正确地加载和注入到项目中。</strong></p><ol><li><strong><code>VITE_</code>前缀</strong>：Vite要求所有应该暴露给项目前端代码的环境变量都必须以 <code>VITE_</code>为前缀。这是一个约定，用于保护你的环境变量，确保只有带有这个前缀的变量才会被包含在最终的前端构建中。这样可以防止无意间将敏感的服务器端环境变量暴露给客户端。</li><li>**<code>APP</code>**：这个部分不是必需的，但它是一个常见的做法，用于指示这些环境变量是应用级别的。加上 <code>APP</code>（或者其他类似的标识符）有助于在环境变量中创建一个逻辑上的分组，使得它们更易于管理和识别。</li><li>**<code>EMAILJS_SERVICE_ID</code>、<code>EMAILJS_TEMPLATE_ID</code>、<code>EMAILJS_PUBLIC_KEY</code>**：这些部分具体指明了变量的用途。在这个例子中，它们分别用于标识EmailJS服务的ID、模板的ID和公共密钥。这样的命名方法有助于清晰地表达每个环境变量的作用和关联的服务。</li></ol><p>**你可以修改环境变量的名称，但需要保持 **<code>VITE_</code>前缀不变，以确保Vite能够正确地处理这些变量。如果你决定更改变量名称（比如，将 <code>VITE_APP_EMAILJS_PUBLIC_KEY</code>更改为 <code>VITE_APP_EMAILJS_KEY</code>），你需要在项目中引用这些环境变量的地方也做相应的更改，以确保一致性和正确的变量访问。</p><p><strong>然后，可以在前端代码中使用这些ID来发送邮件：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import emailjs from &#x27;@emailjs/browser&#x27;;</span><br><span class="line"></span><br><span class="line">// 在组件加载时初始化 EmailJS 服务（例如，在React组件的useEffect中）</span><br><span class="line">emailjs.init(&quot;your-user-id&quot;); // 使用你的User ID替换&quot;your-user-id&quot;</span><br><span class="line"></span><br><span class="line">// 创建发送邮件的函数</span><br><span class="line">const sendEmail = () =&gt; &#123;</span><br><span class="line">  const templateParams = &#123;</span><br><span class="line">    to_name: &#x27;收件人名字&#x27;,</span><br><span class="line">    from_name: &#x27;发件人名字&#x27;,</span><br><span class="line">    message: &#x27;邮件内容&#x27;,</span><br><span class="line">    // ...其他模板参数</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  emailjs.send(&#x27;your-service-id&#x27;, &#x27;your-template-id&#x27;, templateParams)</span><br><span class="line">    .then((response) =&gt; &#123;</span><br><span class="line">       console.log(&#x27;SUCCESS!&#x27;, response.status, response.text);</span><br><span class="line">    &#125;, (error) =&gt; &#123;</span><br><span class="line">       console.log(&#x27;FAILED...&#x27;, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>@emailjs/browser</code>适用于多种场景，如：</p><ul><li><strong>联系表单</strong>：在静态网站或SPA中收集用户反馈或查询，直接从前端发送邮件。</li><li><strong>注册确认</strong>：在用户注册流程中发送欢迎邮件或确认邮件。</li><li><strong>通知系统</strong>：向用户发送通知邮件，如订单状态更新、活动提醒等。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>@emailjs/browser</code>提供了一种简单而强大的方式，使得在没有后端的情况下直接从浏览器发送电子邮件成为可能。通过减少服务器端的需求和复杂性，开发者可以更专注于用户体验和前端功能的实现，同时保持应用的安全性和可维护性。</p><h2 id="tailwindcss"><a href="#tailwindcss" class="headerlink" title="tailwindcss"></a>tailwindcss</h2><p><a href="https://tailwindcss.com/docs/installation">官方文档</a></p><p><a href="https://segmentfault.com/a/1190000022622923">15分钟入门</a></p><p><a href="http://www.xcj.com/front-end-life/CSS/TailwindCSS.html">入门教程</a></p><p><strong>延申插件：</strong></p><blockquote><p><strong>Typography</strong></p><p><strong>Forms</strong></p><p><strong>Aspect Ratio</strong></p><p><strong>Container Queries</strong></p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><strong>安装和配置Tailwind CSS主要涉及两个步骤，这两个步骤通过上述命令完成。下面是对这两条命令的解释：</strong></p><ol><li><code>npm install -D tailwindcss postcss autoprefixer</code></li></ol><p><strong>这条命令使用npm（Node.js包管理器）来安装三个开发依赖：</strong></p><ul><li>**<code>tailwindcss</code>**：Tailwind CSS库本身，它是一个功能类优先的CSS框架，允许你通过在HTML中添加类来直接应用样式，从而加快开发速度。</li><li>**<code>postcss</code>**：PostCSS是一个用JavaScript工具和插件转换CSS代码的工具。Tailwind CSS依赖于PostCSS，因为它实际上是一组PostCSS插件，用于生成和处理Tailwind的工具类。</li><li>**<code>autoprefixer</code>**：Autoprefixer是一个PostCSS插件，用于自动添加浏览器厂商前缀到CSS规则中，确保CSS属性在不同的浏览器中能够正常工作。这对于兼容性是非常有用的。</li></ul><p><code>-D</code>标志表示这些包被安装为开发依赖项，这意味着它们只在开发过程中需要，在生产环境的构建过程中不会被使用。</p><ol start="2"><li><code>npx tailwindcss init -p</code></li></ol><p><strong>这条命令用于初始化Tailwind CSS的配置文件，并自动生成PostCSS配置文件。</strong></p><ul><li><code>npx</code>是一个npm包运行器，它允许你执行安装在本地node_modules目录中的包而不需要全局安装这些包。</li><li><code>tailwindcss init</code>是Tailwind CLI的一部分，用于生成 <code>tailwind.config.js</code>文件。这个文件是Tailwind CSS的配置文件，你可以在其中自定义你的设计系统，如颜色、字体大小、间距等。</li><li><code>-p</code>标志表示同时生成 <code>postcss.config.js</code>文件，这是PostCSS的配置文件，Tailwind CSS作为PostCSS插件运行时需要这个文件。这个标志确保了 <code>autoprefixer</code>也被包含在PostCSS配置中，因为它通常与Tailwind CSS一起使用以确保最佳的浏览器兼容性。</li></ul><p><strong>总的来说，这两个命令共同完成了Tailwind CSS和其依赖的安装，以及为项目生成必要的配置文件，让你可以开始使用Tailwind CSS来构建项目。</strong></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>**在 **<code>tailwind.config.js</code>文件中，<code>content</code>、<code>theme</code>、和 <code>plugins</code>是Tailwind CSS配置的主要部分，它们各自承担着不同的角色，以便定制和控制Tailwind CSS的行为。下面是它们各自的作用：</p><ol><li><code>content</code></li></ol><p><code>content</code>属性用于指定Tailwind CSS应该扫描哪些文件来寻找类名。这是Tailwind CSS的一个重要特性，称为PurgeCSS（在Tailwind CSS v3.x中，这一特性已经内置且默认启用），它用于移除最终CSS文件中未使用的样式，以减小文件大小和提高加载速度。</p><p>**在 **<code>tailwind.config.js</code>文件中，你可以这样配置 <code>content</code>属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  content: [&#x27;./src/**/*.&#123;html,js,jsx,ts,tsx&#125;&#x27;],</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**这告诉Tailwind CSS扫描你项目中的 **<code>src</code>目录下所有的HTML和JavaScript文件，包括React（<code>.jsx</code>）、TypeScript（<code>.ts</code>、<code>.tsx</code>）等文件，来确定哪些样式是实际被使用的。</p><ol start="2"><li><code>theme</code></li></ol><p><code>theme</code>属性用于定制Tailwind CSS提供的默认设计系统。你可以在这里调整颜色、字体、间距等默认设置，或者添加自己的设计令牌（tokens）。这使得Tailwind CSS极其灵活，能够适应几乎任何设计需求。</p><p><strong>例如，你可以定制主题颜色和字体大小：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;</span><br><span class="line">      colors: &#123;</span><br><span class="line">        &#x27;custom-blue&#x27;: &#x27;#5b6d5b&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      fontSize: &#123;</span><br><span class="line">        &#x27;big&#x27;: &#x27;2rem&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>extend</code>属性用于扩展而不是覆盖默认的主题设置。</p><p>**在 **<code>tailwind.config.js</code>文件的 <code>extend</code>对象中对 <code>colors</code>的设置允许你自定义或扩展默认的颜色系统。这种方式让你可以添加新的颜色或覆盖现有颜色的某些阶级（如100-900这样的权重级别通常用于表示颜色的浅到深）。这里是对给出的设置的详细解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colors: &#123;</span><br><span class="line">  black: &#123;</span><br><span class="line">    DEFAULT: &#x27;#000&#x27;,</span><br><span class="line">    500: &#x27;#1D2235&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>**<code>black</code>**：</p><ul><li><code>DEFAULT</code>：这里指定了 <code>black</code>颜色的默认值为 <code>#000</code>。在Tailwind CSS中，如果你直接使用 <code>text-black</code>或 <code>bg-black</code>这样的类，将会应用这个默认颜色值。</li><li><code>500</code>：除了默认值之外，还定义了一个 <code>500</code>阶级的黑色 <code>black-500</code>为 <code>#1D2235</code>。这意味着你可以通过 <code>text-black-500</code>或 <code>bg-black-500</code>来使用这个特定的深度值。</li></ul><ol start="3"><li><code>plugins</code></li></ol><p><code>plugins</code>属性允许你添加第三方插件或自定义的插件到Tailwind CSS中，以扩展其功能。这些插件可以添加新的工具类、组件，或是在构建过程中使用的功能性钩子。</p><p><strong>你可以这样添加插件：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&#x27;@tailwindcss/forms&#x27;),</span><br><span class="line">    // 其他插件...</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**这个例子中，我们添加了 **<code>@tailwindcss/forms</code>插件，它是一个官方插件，用于重置和定制表单元素的样式。</p><p><strong>总的来说，</strong><code>tailwind.config.js</code>中的 <code>content</code>、<code>theme</code>、和 <code>plugins</code>配置项提供了一个强大的机制来定制和优化你的Tailwind CSS集成，使其更适合你的项目需求。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>**在Tailwind CSS中，使用 **<code>@tailwind</code>指令在 <code>index.css</code>（或任何主CSS文件）中导入Tailwind的层是初始化和使用Tailwind CSS框架的关键步骤。这些指令告诉Tailwind CSS在构建过程中将其功能类和样式注入到CSS文件中。下面是这三个指令的作用：</p><ol><li><code>@tailwind base;</code></li></ol><p>**这个指令导入Tailwind的基础样式，这些样式包括浏览器样式的重置和归一化以及一些基本的HTML元素样式。这为你的项目提供了一个一致的基线样式，确保在不同浏览器中具有一致的外观和感觉。基础样式还包括对标准元素（如 **<code>&lt;h1&gt;</code>到 <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>等）的默认样式设置，这样你可以在不需要额外类的情况下立即开始工作。</p><ol start="2"><li><code>@tailwind components;</code></li></ol><p>**这个指令导入由你或其他人创建的组件类。在Tailwind中，组件不是指UI组件库中的组件，而是一组可以重用的工具类组合，用于构建界面元素。通过在 **<code>tailwind.config.js</code>文件中自定义或扩展，你可以创建自定义的组件样式，这些自定义样式将通过这个指令被引入。这允许你定义一些常用的样式模式，如按钮、卡片等，以便在整个项目中重用。</p><ol start="3"><li><code>@tailwind utilities;</code></li></ol><p><strong>这个指令导入Tailwind的工具类，这是Tailwind CSS最强大的特性之一。工具类包括了边距、填充、文字大小、颜色等几乎所有CSS属性的类。这些类设计为原子类，意味着每个类都具有单一的责任，你可以组合它们来创建复杂的设计。这种方法提供了极高的灵活性和定制性，使得你能够快速构建和调整界面。</strong></p><p>**通过在CSS文件中包含这些 **<code>@tailwind</code>指令，你实际上是在激活Tailwind CSS的强大功能，使其成为构建和设计你的Web项目的基础。这种方法允许你利用Tailwind的所有预定义样式和工具，同时保持了扩展和自定义的能力。</p><h3 id="Tailwind-CSS-IntelliSense"><a href="#Tailwind-CSS-IntelliSense" class="headerlink" title="Tailwind CSS IntelliSense"></a>Tailwind CSS IntelliSense</h3><p><strong>Tailwind CSS IntelliSense 是一个 Visual Studio Code (VSCode) 插件，它极大地增强了在使用VSCode开发时使用Tailwind CSS的体验。这个插件提供了一系列功能，旨在提高开发效率和减少编码错误。主要功能包括：</strong></p><ul><li><strong>类名提示</strong>：在编写HTML或JSX等文件时，<strong>插件会提供Tailwind CSS类名的自动完成建议</strong>。这意味着你开始键入时，它会显示可用的Tailwind 类名列表，让你快速选择而不需要记住每个具体的类名。</li><li><strong>悬停后可以样式预览</strong>：当你将鼠标悬停在某个Tailwind CSS类名上时，IntelliSense会显示一个小弹窗，其中展示了这个类名对应的CSS样式。这使得理解和检查类名的作用变得直接且方便。</li><li><strong>错误检查</strong>：插件能够识别并高亮显示不存在的Tailwind CSS类名，帮助你快速定位并修正错误或拼写问题。</li><li><strong>颜色预览</strong>：对于颜色相关的类名（如背景、文字颜色等），IntelliSense会在类名旁边显示一个小色块，直观地展示这个类名对应的颜色，增强了颜色选择的直观性。</li><li><strong>@apply指令支持</strong>：当使用 <code>@apply</code>指令在CSS或SCSS文件中应用Tailwind CSS实用程序类时，IntelliSense也会提供自动完成和验证功能。</li><li><strong>自定义配置支持</strong>：IntelliSense插件能够读取并根据你的 <code>tailwind.config.js</code>文件提供自定义配置的自动完成建议，这包括你添加或修改的颜色、间距等自定义主题设置。</li></ul><p><strong>总之，Tailwind CSS IntelliSense 插件通过提供强大的代码完成、验证和预览功能，极大地提高了使用Tailwind CSS进行开发的效率和舒适度。它帮助开发者更快地编写代码，减少错误，并在编码时获得即时的样式反馈。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅳ</title>
    <link href="https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%984/"/>
    <id>https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%984/</id>
    <published>2024-03-09T03:26:05.000Z</published>
    <updated>2024-06-13T02:14:58.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>本文是对Island.jsx及其相关文件的学习解读，内容中含ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关案例补充"><a href="#相关案例补充" class="headerlink" title="相关案例补充"></a>相关案例补充</h1><h2 id="Bird案例"><a href="#Bird案例" class="headerlink" title="Bird案例"></a>Bird案例</h2><h3 id="const-x3D-useGLTF-birdScene"><a href="#const-x3D-useGLTF-birdScene" class="headerlink" title="const &#x3D; useGLTF(birdScene)"></a>const &#x3D; useGLTF(birdScene)</h3><p><code>&lt;primitive /&gt;</code> is a component from React Three Fiber that allows you to directly include three.js objects into the React component tree. By setting the <code>object</code> prop to <code>scene</code>, you’re telling React Three Fiber to render the entire GLTF scene, which <code>useGLTF</code> hook returns, without having to manually construct the scene with React components. This is a straightforward way to include complex 3D models and their associated hierarchies into your 3D scene.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这种形式</span><br><span class="line">&lt;mesh</span><br><span class="line">   geometry=&#123;nodes.pCube11_rocks1_0.geometry&#125;</span><br><span class="line">   material=&#123;materials.PaletteMaterial001&#125;</span><br><span class="line">/&gt;</span><br><span class="line">//和这种形式</span><br><span class="line">&lt;mesh</span><br><span class="line">   ref=&#123;birdRef&#125;</span><br><span class="line">   position=&#123;[-5, 2, 1]&#125;</span><br><span class="line">   scale=&#123;[0.003, 0.003, 0.003]&#125;</span><br><span class="line">&gt;</span><br><span class="line">   &lt;primitive object=&#123;scene&#125; /&gt;</span><br><span class="line">&lt;/mesh&gt;</span><br></pre></td></tr></table></figure><p>**第一种形式直接使用了GLTF模型中的具体节点（如 **<code>pCube11_rocks1_0</code>）和材质（如 <code>PaletteMaterial001</code>）来创建一个 <code>&lt;mesh&gt;</code>。这种方式允许你精细控制模型的每个部分，例如指定使用模型中的哪个节点和哪种材质。</p><p>**第二种形式使用了 **<code>&lt;primitive object=&#123;scene&#125; /&gt;</code>来直接渲染整个场景（<code>scene</code>），这里的 <code>scene</code>是 <code>useGLTF</code>钩子返回的整个GLTF场景对象。通过这种方式，你可以简单快捷地在React Three Fiber中渲染整个3D模型，而不需要逐个指定模型的每个部分。这种方法适用于当你想要原封不动地渲染整个模型，而不需要对模型的单独部分进行精细控制。</p><h3 id="Unity中导入glb-x2F-gltf"><a href="#Unity中导入glb-x2F-gltf" class="headerlink" title="Unity中导入glb&#x2F;gltf"></a>Unity中导入glb&#x2F;gltf</h3><p><strong>在Unity中导入GLB模型，可以使用Unity的GLTFUtility插件，支持导入GLB和GLTF格式的3D模型。首先需要从</strong><a href="https://github.com/Siccity/GLTFUtility">GitHub获取URL</a>，然后在Unity中使用package manager来进行安装。导入插件后，你可以直接将GLB模型拖拽到Unity的Assets文件夹中，插件会自动处理模型的导入过程。这个过程简单快速，不需要复杂的配置。</p><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame()"></a>useFrame()</h3><p>**在 **<code>useFrame</code>回调函数中，<code>&#123; clock, camera &#125;</code>是从React Three Fiber的渲染循环中解构出来的对象。<code>clock</code>是一个 <code>THREE.Clock</code>实例，用于追踪时间；<code>camera</code>是当前场景中的相机对象。这种写法允许你直接访问这些对象而不需要从外部传入，因为 <code>useFrame</code>已经为你提供了对它们的引用，这是React Three Fiber框架的一部分，旨在简化动画和渲染逻辑的实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useFrame((&#123; clock, camera &#125;) =&gt; &#123; // 这里需要给clock, camera外面加上&#123;&#125;，不然会报错</span><br><span class="line">    // Update the Y position simulate the flight moving in a sin wave </span><br><span class="line">    birdRef.current.position.y = Math.sin(clock.elapsedTime) * 0.2 + 2;</span><br><span class="line"></span><br><span class="line">    // 控制鸟在island的范围内（相机位置的前后10个单位）</span><br><span class="line">    if (birdRef.current.position.x &gt; camera.position.x + 10) &#123;</span><br><span class="line">      birdRef.current.rotation.y = Math.PI;</span><br><span class="line">    &#125; else if (birdRef.current.position.x &lt; camera.position.x - 10) &#123;</span><br><span class="line">      birdRef.current.rotation.y = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**在 **<code>useFrame</code>中，除了 <code>clock</code>和 <code>camera</code>，你还可以接收到一个 <code>state</code>对象作为参数，它包含了React Three Fiber渲染循环中的当前状态和一些实用的属性和方法。这些包括场景（<code>scene</code>）、渲染器（<code>gl</code>）、大小（<code>size</code>）、鼠标位置（<code>mouse</code>）等。<code>useFrame</code>函数提供了一个强大的接口，让你可以在每一帧中访问和修改这些对象，从而创建动画和交互。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  useFrame((_, delta) =&gt; &#123;</span><br><span class="line">    if (isRotating) &#123;</span><br><span class="line">      skyRef.current.rotation.y += 0.15 * delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>**In the **<code>useFrame</code> hook, the first parameter (<code>_</code> in this case) is the state object provided by React Three Fiber, which contains information about the current render state, such as the scene, camera, etc. The underscore <code>_</code> is often used to indicate that the parameter is not being used in the function. The second parameter, <code>delta</code>, represents the time in seconds since the last frame was rendered. This is useful for creating time-dependent animations or simulations, ensuring smooth and consistent motion regardless of the frame rate.</p><h2 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h2><h3 id="Audio的使用"><a href="#Audio的使用" class="headerlink" title="Audio的使用"></a>Audio的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const audioRef = useRef(new Audio(sakura));</span><br></pre></td></tr></table></figure><p>**The **<code>Audio</code> in refers to the HTML Audio element, which is a standard part of the Web APIs provided by browsers for playing sound. It does not need to be imported from a module because it’s globally available in the browser environment, similar to <code>document</code> or <code>window</code>. This API allows you to programmatically control audio playback, such as play, pause, and volume control directly from your React components.</p><p>**To use the **<code>Audio</code> interface in JavaScript, you simply create a new <code>Audio</code> object, optionally passing the URL of the audio file you wish to play as a parameter. You can then use methods like <code>play()</code>, <code>pause()</code>, and properties such as <code>volume</code> to control playback.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const audio = new Audio(&#x27;path/to/your/audio/file.mp3&#x27;);</span><br><span class="line">audio.play(); // To start playing the audio</span><br><span class="line">audio.pause(); // To pause the audio</span><br><span class="line">audio.volume = 0.5; // To set the volume to 50%</span><br></pre></td></tr></table></figure><p>**In a React component, you might use it with **<code>useRef</code> to keep a reference to the audio object.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [isPlayingMusic, setIsPlayingMusic] = useState(false);</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    if (isPlayingMusic) &#123; audioRef.current.play(); &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      audioRef.current.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [isPlayingMusic]);</span><br><span class="line"></span><br><span class="line">// return里面：</span><br><span class="line">&lt;div className=&#x27;absolute bottom-2 left-2&#x27;&gt;</span><br><span class="line">        &lt;img</span><br><span class="line">          src=&#123;!isPlayingMusic ? soundoff : soundon&#125;</span><br><span class="line">          alt=&quot;sound&quot;</span><br><span class="line">          className=&#x27;w-10 h-10 cursor-pointer object-contain&#x27;</span><br><span class="line">          onClick=&#123;() =&gt; setIsPlayingMusic(!isPlayingMusic)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>**This component plays the audio when it mounts and pauses when it unmounts, with the **<code>src</code> prop specifying the audio file’s path.</p><h3 id="currentStage的切换"><a href="#currentStage的切换" class="headerlink" title="currentStage的切换"></a>currentStage的切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;absolute top-28 left-0 right-0 z-10 flex items-center justify-center&quot;&gt;</span><br><span class="line">        &#123;currentStage &amp;&amp; &lt;HomeInfo currentStage=&#123;currentStage&#125; /&gt;&#125; &lt;/div&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>HomeInfo中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HomeInfo = (&#123; currentStage &#125;) =&gt; &#123;</span><br><span class="line">  return renderContent[currentStage] || null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Island中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (true) &#123;</span><br><span class="line">        case normalizeRotation &gt;= 5.45 &amp;&amp; normalizeRotation &lt;= 5.85:</span><br><span class="line">          setCurrentStage(4);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 0.85 &amp;&amp; normalizeRotation &lt;= 1.3:</span><br><span class="line">          setCurrentStage(3);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 2.4 &amp;&amp; normalizeRotation &lt;= 2.6:</span><br><span class="line">          setCurrentStage(2);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 4.25 &amp;&amp; normalizeRotation &lt;= 4.75:</span><br><span class="line">          setCurrentStage(1);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          setCurrentStage(null); // 当不在特定角度下，currentStage为null，所以Home.jsx里要对currentStage进行判断</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>所以需要先判断currentStage，不是null之后再渲染HomeInfo</strong></p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#x27;flex justify-center items-center&#x27;&gt;</span><br><span class="line">        &lt;div className=&quot;w-20 h-20 border-4 border-opacity-20 border-purple-500 border-t-purple-800 rounded-full animate-spin&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>这段代码是一个使用Tailwind CSS实现的简单旋转动画示例。它创建了一个居中的圆形div，该div具有旋转动画。下面是详细解析：</strong></p><ul><li><code>className=&#39;flex justify-center items-center&#39;</code>：这三个类一起使用，创建了一个flex容器，其中的内容水平（<code>justify-center</code>）和垂直（<code>items-center</code>）居中。这确保了内部的div（旋转元素）在父容器中居中。</li><li>**<code>w-20 h-20</code>**：设置div的宽度和高度为5rem（根据Tailwind CSS的默认配置，<code>20</code>单位等于5rem，如果没有自定义配置的话）。</li><li>**<code>border-4</code>**：设置边框宽度为4像素。</li><li>**<code>border-opacity-20</code>**：设置边框透明度为20%，使边框颜色较浅。</li><li>**<code>border-purple-500</code>**：设置边框的默认颜色为紫色，透明度由 <code>border-opacity-20</code>控制。</li><li>**<code>border-t-purple-800</code>**：特别为上边框设置了较深的紫色（<code>purple-800</code>），这在旋转时会产生视觉效果，使得看起来像是在旋转。</li><li>**<code>rounded-full</code>**：使div变为圆形。</li><li>**<code>animate-spin</code>**：应用Tailwind CSS内置的旋转动画，使div无限期旋转。这个动画是通过CSS的 <code>@keyframes</code>实现的，定义了从0%到100%的转动，实现了连续旋转的效果。Tailwind CSS内部定义了这个动画关键帧，实现了元素的360度旋转。动画是循环播放的，因此旋转动画会一直持续，直到被另外的CSS规则覆盖或者从DOM中移除。</li></ul><h3 id="匿名函数的-和"><a href="#匿名函数的-和" class="headerlink" title="匿名函数的()和{}"></a>匿名函数的()和{}</h3><ul><li>**使用 **<code>()=&gt;()</code>时，箭头函数会直接返回圆括号 <code>()</code>中的表达式结果。这适用于返回单个表达式或JSX元素的简短函数。</li><li>**使用 **<code>()=&gt;&#123;&#125;</code>时，你可以在花括号 <code>&#123;&#125;</code>中执行多个语句，但如果想要返回值，需要显式使用 <code>return</code>语句。这适用于更复杂的函数，其中包含了多条语句。</li></ul><h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><h3 id="useAnimations"><a href="#useAnimations" class="headerlink" title="useAnimations"></a>useAnimations</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const group = useRef();</span><br><span class="line">  const &#123; nodes, materials, animations &#125; = useGLTF(scene);</span><br><span class="line">  const &#123; actions &#125; = useAnimations(animations, group);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(actions);// 可以查看模型有哪些动画</span><br><span class="line">    Object.values(actions).forEach((action) =&gt; &#123; action.stop() &#125;);</span><br><span class="line">    if (actions[currentAnimation]) actions[currentAnimation].play();</span><br><span class="line"></span><br><span class="line">  &#125;, [actions, currentAnimation]);</span><br></pre></td></tr></table></figure><p><code>Object.values()</code> 是一个JavaScript方法，它从一个对象中提取出所有可枚举的属性值，并以数组的形式返回这些值。这个方法让你能够更方便地遍历对象的值。</p><p><strong>使用方法:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const object = &#123; a: 1, b: &#x27;text&#x27;, c: true &#125;;</span><br><span class="line">const values = Object.values(object);</span><br><span class="line">console.log(values); // 输出: [1, &#x27;text&#x27;, true]</span><br></pre></td></tr></table></figure><p><strong>案例:</strong><br><strong>假设你有一个对象，存储了不同动画的状态，你想要停止所有正在播放的动画，可以这样做:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const animations = &#123;</span><br><span class="line">  walk: &#123; /* 动画对象 */ &#125;,</span><br><span class="line">  run: &#123; /* 动画对象 */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 停止所有动画</span><br><span class="line">Object.values(animations).forEach(animation =&gt; &#123;</span><br><span class="line">  animation.stop(); // 假设每个动画对象都有一个stop方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>这样，</strong><code>Object.values()</code>帮助你获取了 <code>animations</code>对象中所有动画的集合，然后你可以使用 <code>forEach</code>遍历这个集合，并对每个动画调用 <code>stop</code>方法。</p><h3 id="useAlert"><a href="#useAlert" class="headerlink" title="useAlert"></a>useAlert</h3><p><strong>新建的一个自定义Hook;</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const useAlert = () =&gt; &#123;</span><br><span class="line">  const [alert, setAlert] = React.useState(&#123;</span><br><span class="line">    show: false,</span><br><span class="line">    text: &#x27;&#x27;,</span><br><span class="line">    type: &#x27;danger&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">  const showAlert = (&#123; text, type = &#x27;danger&#x27; &#125;) =&gt;</span><br><span class="line">    setAlert(&#123; show: true, text, type &#125;)</span><br><span class="line">  const hideAlert = () =&gt; setAlert(&#123; show: false, text: &#x27;&#x27;, type: &#x27;danger&#x27; &#125;)</span><br><span class="line">  return &#123; alert, showAlert, hideAlert &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default useAlert</span><br></pre></td></tr></table></figure><p><strong>在useState的基础上，新建了两个函数，这两个函数都是传入参数+setAlert进行组合；最后返回alert，升级的setAlert(也就是这两个函数)</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/02/25/threejs%E5%AE%9E%E6%88%983/"/>
    <id>https://youxt-njnu.github.io/2024/02/25/threejs%E5%AE%9E%E6%88%983/</id>
    <published>2024-02-25T03:50:05.000Z</published>
    <updated>2024-06-13T02:15:02.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>本文是对Island.jsx及其相关文件的学习解读，内容中含ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><h2 id="Island-jsx"><a href="#Island-jsx" class="headerlink" title="Island.jsx"></a>Island.jsx</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Auto-generated by: https://github.com/pmndrs/gltfjsx</span></span><br><span class="line"><span class="comment">Author: nimzu (https://sketchfab.com/nimzuk)</span></span><br><span class="line"><span class="comment">License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)</span></span><br><span class="line"><span class="comment">Source: https://sketchfab.com/3d-models/foxs-islands-163b68e09fcc47618450150be7785907</span></span><br><span class="line"><span class="comment">Title: Fox&#x27;s islands</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-spring/three&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useGLTF &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/drei&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useFrame, useThree &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/fiber&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> isLandScene <span class="keyword">from</span> <span class="string">&#x27;../assets/3d/island.glb&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Island</span> = (<span class="params">&#123; isRotating, setIsRotating, setCurrentStage, ...props &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> islandRef = <span class="title function_">useRef</span>(); <span class="comment">// 对应到了Three的Group, 用于控制整个模型(islandRef.current, 即island的gameobject)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; gl, viewport &#125; = <span class="title function_">useThree</span>();<span class="comment">// 获取Three的渲染器，视口</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nodes, materials &#125; = <span class="title function_">useGLTF</span>(isLandScene); <span class="comment">// 获取模型的nodes和materials</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastX = <span class="title function_">useRef</span>(<span class="number">0</span>); <span class="comment">// 用于记录上一次的鼠标位置。这个值在组件的重渲染之间保持不变，而且这些值的变化不会触发组件的重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> rotationSpeed = <span class="title function_">useRef</span>(<span class="number">0</span>);  <span class="comment">// 这个值在组件的重渲染之间保持不变，而且这些值的变化不会触发组件的重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> dampingFactor = <span class="number">0.95</span>; <span class="comment">// 阻尼系数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerDown</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> clientX = e.<span class="property">touches</span> ? e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span> : e.<span class="property">clientX</span>; <span class="comment">//只需要考虑X方向的</span></span><br><span class="line">    lastX.<span class="property">current</span> = clientX;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerUp</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">setIsRotating</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerMove</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRotating) &#123;</span><br><span class="line">      <span class="keyword">const</span> clientX = e.<span class="property">touches</span> ? e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span> : e.<span class="property">clientX</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> delta = (clientX - lastX.<span class="property">current</span>) / viewport.<span class="property">width</span>;</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += delta * <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      lastX.<span class="property">current</span> = clientX;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = delta * <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyDown</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowLeft&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRotating) <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = <span class="number">0.0125</span>;<span class="comment">// 让旋转的效果更舒适些</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowRight&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRotating) <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> -= <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = -<span class="number">0.0125</span>;<span class="comment">// 让旋转的效果更舒适些</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyUp</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowLeft&#x27;</span> || e.<span class="property">key</span> === <span class="string">&#x27;ArrowRight&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">setIsRotating</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRotating) &#123;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> *= dampingFactor; <span class="comment">//每帧都会减小旋转速度</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(rotationSpeed.<span class="property">current</span>) &lt; <span class="number">0.001</span>) &#123; <span class="comment">//设定阈值后，停止旋转</span></span><br><span class="line">        rotationSpeed.<span class="property">current</span> = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += rotationSpeed.<span class="property">current</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rotation = islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mormalize the rotation value to ensure it stays within the range[0, 2 * Math.PI].</span></span><br><span class="line">      <span class="comment">// The goal is to ensure that the rotation value remains within a specific range to prevent potential issues with very large or negative rotation values.</span></span><br><span class="line">      <span class="comment">//   Here&#x27;s a step-by-step explanation of what this code does:</span></span><br><span class="line">      <span class="comment">// 1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided by 2 * Math.PI.This essentially wraps the rotation value around once it reaches a full circle(360 degrees) so that it stays within the range of 0 to 2 * Math.PI.</span></span><br><span class="line">      <span class="comment">// 2.(rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1. This is done to ensure that the value remains positive and within the range of 0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.</span></span><br><span class="line">      <span class="comment">// 3. Finally, ((rotation%(2*Math.PI))+2*Math.PI)%(2*Math.PI) applies another modulo operation to the value obtained in step 2. This step guarantees that the value always stays with the range of 0 to 2*Math.PI, which is equivalent to a full circle in radians.</span></span><br><span class="line">      <span class="keyword">const</span> normalizeRotation = ((rotation % (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)) + <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) % (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//set the current stage based on the island&#x27;s orientation</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">5.45</span> &amp;&amp; normalizeRotation &lt;= <span class="number">5.85</span>: </span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">0.85</span> &amp;&amp; normalizeRotation &lt;= <span class="number">1.3</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">3</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">2.4</span> &amp;&amp; normalizeRotation &lt;= <span class="number">2.6</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">4.25</span> &amp;&amp; normalizeRotation &lt;= <span class="number">4.75</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = gl.<span class="property">domElement</span>;</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, handlePointerDown);</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerup&#x27;</span>, handlePointerUp);</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointermove&#x27;</span>, handlePointerMove);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, handleKeyDown);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, handleKeyUp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, handlePointerDown);</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointerup&#x27;</span>, handlePointerUp);</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointermove&#x27;</span>, handlePointerMove);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, handleKeyDown);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, handleKeyUp);</span><br><span class="line">    &#125;  <span class="comment">// 返回的这个函数将在组件卸载或依赖项改变之前执行</span></span><br><span class="line">  &#125;, [gl, handlePointerDown, handlePointerUp, handlePointerMove]); <span class="comment">//只有当这三个变量改变时，里面函数才会执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a.group</span> <span class="attr">ref</span>=<span class="string">&#123;islandRef&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface945_tree1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface946_tree2_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface947_tree1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface948_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface949_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.pCube11_rocks1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a.group</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Island</span>;</span><br></pre></td></tr></table></figure><h2 id="Home-jsx"><a href="#Home-jsx" class="headerlink" title="Home.jsx"></a>Home.jsx</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Canvas</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-three/fiber&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span>, useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeInfo</span> <span class="keyword">from</span> <span class="string">&#x27;../components/HomeInfo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loader</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Loader&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Island</span> <span class="keyword">from</span> <span class="string">&#x27;../models/Island&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">const</span> [isRotating, setIsRotating] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [currentStage, setCurrentStage] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">adjustIslandForScreenSize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> screenScale = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> screenPosition = [<span class="number">0</span>, -<span class="number">6.5</span>, -<span class="number">43</span>];</span><br><span class="line">    <span class="keyword">let</span> rotation = [<span class="number">0.1</span>, <span class="number">4.7</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt; <span class="number">768</span>) &#123;</span><br><span class="line">      screenScale = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      screenScale = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [screenScale, screenPosition, rotation];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [islandScale, islandPosition, islandRotation] = <span class="title function_">adjustIslandForScreenSize</span>();</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#x27;w-full h-screen relative&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;absolute top-28 left-0 right-0 z-10 flex items-center justify-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;currentStage &amp;&amp; <span class="tag">&lt;<span class="name">HomeInfo</span> <span class="attr">currentStage</span>=<span class="string">&#123;currentStage&#125;</span> /&gt;</span>&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Canvas</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">w-full</span> <span class="attr">h-screen</span> <span class="attr">bg-transparent</span> $&#123;<span class="attr">isRotating</span> ? &#x27;<span class="attr">cursor-grabbing</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">cursor-grab</span>&#x27;&#125; `&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">camera</span>=<span class="string">&#123;&#123;</span> <span class="attr">near:</span> <span class="attr">0.1</span>, <span class="attr">far:</span> <span class="attr">1000</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* Suspense 用于解决加载组件时的白屏，可以显示其他的内容，而其他内容不允许使用 lazy加载 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loader</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">directionalLight</span> <span class="attr">position</span>=<span class="string">&#123;[1,</span> <span class="attr">1</span>, <span class="attr">1</span>]&#125; <span class="attr">intensity</span>=<span class="string">&#123;2&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          ......</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Island</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">position</span>=<span class="string">&#123;islandPosition&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scale</span>=<span class="string">&#123;islandScale&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">rotation</span>=<span class="string">&#123;islandRotation&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">isRotating</span>=<span class="string">&#123;isRotating&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">setIsRotating</span>=<span class="string">&#123;setIsRotating&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">setCurrentStage</span>=<span class="string">&#123;setCurrentStage&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ......</span></span><br><span class="line"><span class="language-xml">    &lt;/section &gt;</span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">export default Home</span></span><br></pre></td></tr></table></figure><h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><h2 id="Three"><a href="#Three" class="headerlink" title="Three"></a>Three</h2><h3 id="a-in-‘-react-spring-x2F-three’"><a href="#a-in-‘-react-spring-x2F-three’" class="headerlink" title="a in ‘@react-spring&#x2F;three’"></a>a in ‘@react-spring&#x2F;three’</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-spring/three&#x27;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a.group</span> <span class="attr">ref</span>=<span class="string">&#123;islandRef&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ......</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a.group</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个上下文中，<code>a</code>很可能是 <code>@react-spring/three</code>库的命名导入，用于访问 <code>react-spring</code>提供的用于Three.js对象的动画化包装器。<code>react-spring</code>是一个流行的React库，用于创建流畅和自然的动画效果。<code>@react-spring/three</code>是专门为Three.js集成提供的，使得在Three.js环境中使用 <code>react-spring</code>变得简单。</p><p>在这段代码中：</p><ul><li>**<code>a.group</code>**：这是 <code>@react-spring/three</code>提供的一个组件，它是对Three.js中 <code>THREE.Group</code>的动画化包装。在Three.js中，<code>Group</code>对象用于创建对象的集合，这样你可以作为一个单元来平移、旋转和缩放它们。在 <code>react-spring/three</code>中，<code>a.group</code>允许你对这个组应用动画，比如平移、旋转或透明度变化等。</li><li>**<code>&lt;mesh /&gt;</code>**：这是一个Three.js中用于表示具有几何形状和材质的物体的组件。在这个示例中，<code>mesh</code>组件使用了 <code>geometry</code>（几何体）和 <code>material</code>（材质）两个属性，分别指定了物体的形状和表面处理。这不是 <code>react-spring</code>特有的，而是Three.js中的基本概念，但在这里它被放置在 <code>a.group</code>内部，表明你可以对整个组和组内的单个物体进行动画处理。</li></ul><p><code>a</code>是一个特殊的前缀，用于访问 <code>react-spring/three</code>提供的动画化组件。使用 <code>react-spring/three</code>，你可以给Three.js的对象添加流畅的物理基础动画，比如弹簧动画。<code>react-spring</code>的动画不仅限于简单的过渡，它支持从初始状态到结束状态的自然动画，包括反弹、停止等自然运动的效果。</p><p><code>&lt;a.group&gt;</code>组件继承自Three.js的 <code>Group</code>类，将Three.js对象（如 <code>Group</code>、<code>Mesh</code>等）用 <code>a.</code>前缀包装，并通过 <code>@react-spring/three</code>获得了动画能力。在Three.js中，<code>Group</code>是一个用于包含和管理多个其他对象（例如，几何体、网格等）的容器。它本身是 <code>Object3D</code>的一个子类，这意味着它继承了 <code>Object3D</code>的所有属性，包括 <code>position</code>、<code>scale</code>和 <code>rotation</code>。</p><h3 id="useThree-“-react-three-x2F-fiber”"><a href="#useThree-“-react-three-x2F-fiber”" class="headerlink" title="useThree “@react-three&#x2F;fiber”"></a>useThree “@react-three&#x2F;fiber”</h3><p>在 <code>@react-three/fiber</code> 中，<code>useThree</code> 是一个 React Hook，它提供了访问 Three.js 渲染上下文中的各种属性和方法的能力。</p><p>当你在组件中调用 <code>useThree()</code> 时，它返回一个对象，这个对象包含了当前 Three.js 渲染上下文的多个属性和实例。这样，你就可以在你的组件中直接访问和使用这些属性和实例，而无需手动管理它们。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gl, viewport &#125; = <span class="title function_">useThree</span>();</span><br></pre></td></tr></table></figure><p>这行代码的作用是从 <code>useThree()</code> 返回的上下文对象中解构出 <code>gl</code> 和 <code>viewport</code> 两个属性：</p><ul><li>**<code>gl</code>**：这是对 WebGLRenderer 的引用，即 Three.js 使用的 WebGL 渲染器实例。通过这个实例，你可以控制渲染过程，比如调整清除颜色、执行后处理等。</li><li>**<code>viewport</code>**：这包含了关于当前视口的信息，如视口的宽度和高度，以及一些用于将屏幕坐标转换为Three.js世界坐标的工具函数。这对于响应式设计和动态布局非常有用。</li></ul><p>在Three.js中，<code>WebGLRenderer</code>是用来渲染场景（<code>THREE.Scene</code>）到一个Web页面上的canvas元素中。它使用WebGL API来绘制定义好的3D对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br></pre></td></tr></table></figure><p><code>WebGLRenderer</code>生成的canvas元素需要被添加到HTML文档中，这样渲染的结果才能显示给用户。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span><br><span class="line">......</span><br><span class="line">renderer.<span class="title function_">render</span>(scene, camera);</span><br></pre></td></tr></table></figure><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame()"></a>useFrame()</h3><p><code>useFrame</code> 是一个来自 <code>@react-three/fiber</code> 的 React Hook，它允许你在 React 的函数组件中插入和使用渲染循环。在 3D 应用和游戏开发中，渲染循环（也称为动画循环）是核心概念之一，负责在每一帧更新场景、相机、物体状态等，以及执行渲染操作。</p><p><code>useFrame</code> 接受一个回调函数作为参数，这个回调函数会在浏览器的动画帧循环中被不断调用。通常，这个回调函数接受两个参数：一个是渲染器的 <code>state</code>，另一个是渲染的 <code>delta</code> 时间（即从上一帧到当前帧的时间差，单位为秒）。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useFrame</span>(<span class="function">(<span class="params">state, delta</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里编写每帧要执行的操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设你想在一个三维场景中旋转一个立方体，你可以使用 <code>useFrame</code> 来更新立方体的旋转状态：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useFrame &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-three/fiber&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Mesh</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">RotatingBox</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;<span class="title class_">Mesh</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useFrame</span>(<span class="function">(<span class="params">state, delta</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.<span class="property">current</span>) &#123;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">x</span> += delta;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">mesh</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">boxGeometry</span> <span class="attr">args</span>=<span class="string">&#123;[1,</span> <span class="attr">1</span>, <span class="attr">1</span>]&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">meshStandardMaterial</span> <span class="attr">color</span>=<span class="string">&quot;orange&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">mesh</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，每一帧都会增加立方体的 <code>x</code> 和 <code>y</code> 轴旋转，<code>delta</code> 参数确保了旋转速度与帧率无关，提供了平滑一致的动画效果。</p><p>注意事项</p><ul><li>使用 <code>useFrame</code> 时要考虑性能。因为回调函数会在每一帧被调用，避免在其中执行复杂的计算或状态更新，这可能会导致性能问题。</li><li><code>useFrame</code> 是 <code>@react-three/fiber</code> 特有的，不是 React 官方 API 的一部分。它专门用于在 <code>@react-three/fiber</code> 提供的 <code>&lt;Canvas&gt;</code> 组件中使用，这个组件用于渲染 Three.js 的 3D 场景。</li></ul><h3 id="交互事件pointerdown"><a href="#交互事件pointerdown" class="headerlink" title="交互事件pointerdown"></a>交互事件pointerdown</h3><p>在Three.js中，虽然库本身主要聚焦于3D场景的渲染，但它通常用于Web环境，因此经常与HTML元素（如 <code>canvas</code>）以及Web事件模型进行交互。<code>pointerdown</code>、<code>pointerup</code>和 <code>pointermove</code>是指针事件，是Web标准的一部分，用于处理各种指针设备（如鼠标、触摸屏和笔设备）的输入。这些事件可以被用来增强Three.js场景的交互性。下面是每个事件的基本说明：</p><p>pointerdown</p><ul><li><strong>操作</strong>：当用户按下任何指针设备（例如，鼠标按键、触摸屏的触摸）时触发。</li><li><strong>用途</strong>：在Three.js应用中，<code>pointerdown</code>可以用来检测用户开始与场景中的对象进行交互的时刻，比如开始拖动物体、选中一个物体等。</li></ul><p>pointerup</p><ul><li><strong>操作</strong>：当用户释放之前按下的指针设备时触发。</li><li><strong>用途</strong>：在Three.js应用中，<code>pointerup</code>事件可以用来检测用户结束交互的时刻，例如放开拖动的物体、确认选中的物体等。</li></ul><p>pointermove</p><ul><li><strong>操作</strong>：当指针设备在屏幕上移动时触发，不论是否按下。</li><li><strong>用途</strong>：<code>pointermove</code>在Three.js中非常有用，可以用来实现对象的拖拽效果、在场景中导航（如旋转视角、缩放场景）或实时追踪鼠标&#x2F;触摸的位置以创建动态效果。</li></ul><p>为了在Three.js的 <code>canvas</code>元素上监听这些事件，你可以直接在 <code>canvas</code>元素上添加事件监听器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = renderer.<span class="property">domElement</span>; <span class="comment">// 假设你已经有一个Three.js渲染器</span></span><br><span class="line"></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Pointer down&#x27;</span>, event);</span><br><span class="line">    <span class="comment">// 在这里添加当指针按下时的处理逻辑</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Pointer Type: <span class="subst">$&#123;event.pointerType&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Pointer Position: (<span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>)`</span>);</span><br><span class="line">    <span class="comment">// 阻止默认行为和事件冒泡</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>event</code>对象的作用</p><ul><li><strong>事件类型识别</strong>：<code>event.type</code>属性可以告诉你事件的具体类型（如 <code>&quot;pointerdown&quot;</code>），有助于在使用同一个事件处理函数处理多种事件类型时进行区分。</li><li><strong>获取指针位置</strong>：<code>event.clientX</code>和 <code>event.clientY</code>属性提供了指针在视口中的坐标位置，而 <code>event.pageX</code>和 <code>event.pageY</code>则提供了指针在整个页面中的位置。这对于实现拖拽功能或在画布上绘图等功能非常有用。</li><li><strong>区分指针设备</strong>：<code>event.pointerType</code>属性可以告诉你触发事件的指针设备类型（如 <code>&quot;mouse&quot;</code>、<code>&quot;pen&quot;</code>或 <code>&quot;touch&quot;</code>），这有助于实现针对不同设备的特定交互响应。</li><li><strong>阻止默认行为</strong>：<code>event.preventDefault()</code>方法可以用来阻止事件的默认行为（如果有的话），例如阻止点击链接导航到新页面的默认行为。</li><li><strong>停止事件冒泡</strong>：<code>event.stopPropagation()</code>方法可以阻止事件进一步传播到其他事件监听器。</li></ul><p>注意事项</p><ul><li>使用指针事件可以让你的应用更好地适应不同的输入设备，而不仅仅是鼠标。</li><li>确保合理使用事件监听器，避免在高频事件（如 <code>pointermove</code>）中执行计算量大的操作，这可能会影响性能。</li><li>在处理这些事件时，考虑事件对象（<code>event</code>）提供的信息，如指针位置、按下的按钮等，这些信息对于实现精确的交互逻辑非常有用。</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 是React的一个Hook，它允许你在函数组件中添加状态。在React 16.8之前，函数组件被称为无状态组件，意味着你不能在其中使用状态（state）或生命周期方法。<code>useState</code>的引入改变了这一点，让函数组件也能够拥有和类组件一样的状态管理能力。</p><p><code>useState</code>的基本用法非常简单。它接受一个参数，这个参数是状态的初始值，然后返回一个数组，这个数组包含两个元素：当前的状态值和一个更新这个状态值的函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  // 声明一个新的状态变量，我们将其称之为 &quot;count&quot;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>useState(0)</code>声明了一个新的状态变量 <code>count</code>，并将其初始值设为0。<code>setCount</code>是一个函数，用于更新 <code>count</code>的值。当你点击按钮时，调用 <code>setCount(count + 1)</code>来增加 <code>count</code>的值。</p><p><strong>你可以在一个组件中多次调用</strong> <code>useState</code>，以声明多个状态变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  // 声明多个状态变量</span><br><span class="line">  const [age, setAge] = useState(42);</span><br><span class="line">  const [fruit, setFruit] = useState(&#x27;banana&#x27;);</span><br><span class="line">  const [todos, setTodos] = useState([&#123; text: &#x27;学习 Hook&#x27; &#125;]);</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数式更新：如果新的状态依赖于前一个状态，你可以给更新函数传入一个函数，这个函数将接收前一个状态作为参数，并返回一个新状态。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The count is &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="惰性初始状态"><a href="#惰性初始状态" class="headerlink" title="惰性初始状态"></a>惰性初始状态</h4><p><code>useState</code>允许你传入一个函数来延迟计算初始状态，这对于初始状态计算开销较大的情况非常有用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [state, setState] = useState(() =&gt; &#123;</span><br><span class="line">  const initialState = someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>someExpensiveComputation</code>只会在组件初次渲染时被调用，从而避免了在每次渲染时都重新计算初始状态的开销。</p><p><strong>通过</strong> <code>useState</code>，React为函数组件提供了状态管理的能力，使得开发者能够在不使用类组件的情况下，以一种简洁且易于理解的方式构建动态且响应式的用户界面。</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 是React的一个Hook，它用于在函数组件中存储一个可变的引用对象，这个对象在组件的整个生命周期内保持不变。<code>useRef</code>最常见的用途有两个：一是访问DOM节点，二是存储任何可变值。</p><h4 id="访问DOM节点"><a href="#访问DOM节点" class="headerlink" title="访问DOM节点"></a>访问DOM节点</h4><p><strong>当你需要直接操作DOM元素时，比如设置焦点、测量元素大小或位置等，</strong><code>useRef</code>可以用来获取DOM节点的引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function TextInputWithFocusButton() &#123;</span><br><span class="line">  // 初始化一个ref</span><br><span class="line">  const inputEl = useRef(null);</span><br><span class="line"></span><br><span class="line">  const onButtonClick = () =&gt; &#123;</span><br><span class="line">    // 当按钮被点击时，使用current属性访问DOM节点，并调用focus方法</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;/* 使用ref属性将inputEl ref附加到输入元素上 */&#125;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储任何可变值"><a href="#存储任何可变值" class="headerlink" title="存储任何可变值"></a>存储任何可变值</h4><p><code>useRef</code>也可以用来存储任何可变值，<strong>这个值在组件的重渲染之间保持不变。这对于存储任意值，如计时器ID、外部库的实例等特别有用，而且这些值的变化不会触发组件的重新渲染</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function TimerComponent() &#123;</span><br><span class="line">  const intervalId = useRef(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    intervalId.current = setInterval(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Timer tick&#x27;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      clearInterval(intervalId.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;Check the console for timer ticks.&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>intervalId</code>用于存储计时器ID，以便可以在组件卸载时清除计时器，防止内存泄露。</p><h4 id="useRef-vs-useState"><a href="#useRef-vs-useState" class="headerlink" title="useRef vs. useState"></a><code>useRef</code> vs. <code>useState</code></h4><p><strong>虽然</strong> <code>useState</code>也可以用于存储数据，但与 <code>useRef</code>相比，当状态更新时，<code>useState</code>会触发组件的重新渲染，而 <code>useRef</code>中的变化不会。因此，如果你需要在组件的多次渲染之间保持不变的数据，且这些数据的变化不应该触发组件的重新渲染，<code>useRef</code>是更合适的选择。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>useRef</code>在React函数组件中提供了一种简单的方式来访问DOM节点和存储可变数据。通过 <code>useRef</code>，你可以在组件的整个生命周期内保持对某个值的引用，而不会引起额外的渲染。这使得 <code>useRef</code>成为在需要直接操作DOM或需要跨渲染周期保持数据不变时的理想选择。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect</code> 是 React 的一个 Hook，它允许你在函数组件中执行副作用操作。副作用可以包括数据获取、订阅或手动修改 DOM 等操作，这些操作通常在组件渲染到屏幕之后执行。<code>useEffect</code> 的用法提供了一个优雅的方式来处理这些操作。<code>useEffect</code> 提供了一种在函数组件中处理生命周期事件的灵活方式，使得开发者能够更容易地管理副作用和资源。</p><p><code>useEffect</code> 接收两个参数：一个是副作用函数，另一个是依赖数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 在这里执行副作用操作</span><br><span class="line">&#125;, [/* 依赖项列表 */]);</span><br></pre></td></tr></table></figure><h4 id="没有依赖的-useEffect"><a href="#没有依赖的-useEffect" class="headerlink" title="没有依赖的 useEffect"></a>没有依赖的 useEffect</h4><p>如果 <code>b</code> 的依赖项列表为空（<code>[]</code>），副作用函数只会在组件挂载（mount）后执行一次。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 只会在组件挂载后执行一次</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h4 id="带有依赖的-useEffect"><a href="#带有依赖的-useEffect" class="headerlink" title="带有依赖的 useEffect"></a>带有依赖的 useEffect</h4><p><strong>当你在依赖项列表中指定变量时，只有当这些变量改变时，副作用函数才会执行。这提供了一种方式来优化性能，避免不必要的副作用操作。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 当 `count` 变化时，这个副作用就会执行</span><br><span class="line">  document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">&#125;, [count]); // 依赖项列表中包含 `count`</span><br></pre></td></tr></table></figure><h4 id="清理副作用"><a href="#清理副作用" class="headerlink" title="清理副作用"></a>清理副作用</h4><p><strong>有时候，你可能需要在组件卸载（unmount）或下一次副作用执行之前执行一些清理操作，比如取消订阅或清除定时器等。为此，你的副作用函数可以返回一个清理函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    // 执行一些重复的操作</span><br><span class="line">  &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  // 返回的这个函数将在组件卸载或依赖项改变之前执行</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [/* 依赖项 */]);</span><br></pre></td></tr></table></figure><h4 id="没有依赖项的-useEffect"><a href="#没有依赖项的-useEffect" class="headerlink" title="没有依赖项的 useEffect"></a>没有依赖项的 useEffect</h4><p>**如果 **<code>useEffect</code> 被调用时没有提供依赖项列表，副作用函数将在组件每次渲染后执行。这通常不推荐，因为它可能会导致性能问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 每次组件渲染后都会执行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="…props"><a href="#…props" class="headerlink" title="…props"></a>…props</h3><p><strong>在JSX中，</strong><code>...props</code>是一个使用了JavaScript的展开运算符（Spread Operator）的表达式，它用于将一个对象的所有可枚举属性，复制到当前对象中。在React组件中，这种语法经常用来传递 <code>props</code>（属性）。</p><p><strong>当你在JSX标签中使用</strong> <code>...props</code>时，你实际上是将一个包含多个属性的对象“展开”，并将这些属性作为单独的props传递给组件。这样做的好处是可以保持组件接口的灵活性，同时减少了代码的冗余。</p><p><strong>假设你有一个组件</strong> <code>&lt;MyComponent /&gt;</code>，你想传递给它多个props，如 <code>title</code>和 <code>onClick</code>等，而这些props是通过一个对象 <code>props</code>管理的，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const props = &#123;</span><br><span class="line">  title: &#x27;Hello World&#x27;,</span><br><span class="line">  onClick: () =&gt; console.log(&#x27;Clicked&#x27;),</span><br><span class="line">  // 更多props...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在不使用展开运算符的情况下，你需要逐一传递每个属性：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent title=&#123;props.title&#125; onClick=&#123;props.onClick&#125; /&gt;</span><br></pre></td></tr></table></figure><p><strong>使用展开运算符，上面的代码可以简化为：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent &#123;...props&#125; /&gt;</span><br></pre></td></tr></table></figure><p><strong>这行代码的作用是将</strong> <code>props</code>对象中的每个属性都作为单独的prop传递给 <code>MyComponent</code>组件。这不仅使代码更简洁，还使得 <code>MyComponent</code>组件能够接收任何通过 <code>props</code>对象传递的额外属性，而无需每次都显式声明它们。</p><p><strong>虽然使用展开运算符可以提高代码的灵活性和可读性，但在某些情况下也需要谨慎使用，因为：</strong></p><ul><li><strong>性能影响</strong>：如果对象很大，或这种操作在一个大型应用中频繁执行，它可能会对性能产生影响。</li><li><strong>属性覆盖</strong>：如果存在多个相同的属性名，后面的属性会覆盖前面的属性。在使用展开运算符时，需要注意属性的顺序和重复性。</li><li><strong>类型检查</strong>：在TypeScript等静态类型检查的环境中，使用展开运算符传递props时，可能需要确保传递的对象属性与组件的props类型兼容。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用为：</span><br><span class="line">&lt;Island</span><br><span class="line">position=&#123;islandPosition&#125;</span><br><span class="line">scale=&#123;islandScale&#125;</span><br><span class="line">rotation=&#123;islandRotation&#125;</span><br><span class="line">isRotating=&#123;isRotating&#125;</span><br><span class="line">setIsRotating=&#123;setIsRotating&#125;</span><br><span class="line">setCurrentStage=&#123;setCurrentStage&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">内容为：</span><br><span class="line">const Island = (&#123; isRotating, setIsRotating, setCurrentStage, ...props &#125;) =&gt; &#123; </span><br><span class="line">    ......</span><br><span class="line">    return (</span><br><span class="line">        &lt;a.group ref=&#123;islandRef&#125; &#123;...props&#125;&gt;</span><br><span class="line">            &lt;mesh</span><br><span class="line">                geometry=&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span><br><span class="line">                material=&#123;materials.PaletteMaterial001&#125; </span><br><span class="line">                /&gt;</span><br><span class="line">            ......</span><br><span class="line">    )&#125; </span><br></pre></td></tr></table></figure><p><strong>在这个示例中，</strong><code>&lt;Island /&gt;</code>组件接收了多个属性（<code>props</code>），包括 <code>isRotating</code>、<code>setIsRotating</code>、<code>setCurrentStage</code>以及其他可能的属性（如 <code>position</code>、<code>scale</code>、<code>rotation</code>等, 这些属性对于Three.js中的对象来说是常见的变换属性）。在 <code>Island</code>组件的函数签名中，<code>...props</code>使用了JavaScript的展开运算符来收集除 <code>isRotating</code>、<code>setIsRotating</code>、<code>setCurrentStage</code>之外的所有传递给组件的属性。</p><p><strong>在</strong> <code>Island</code>组件内部，<code>...props</code>的作用是将这些额外的属性传递给 <code>&lt;a.group&gt;</code>组件。这样做有几个好处：</p><ol><li><strong>灵活性</strong>：允许 <code>Island</code>组件接收任何额外的属性，并将它们直接传递给内部的 <code>&lt;a.group&gt;</code>组件，而无需组件显式地声明或处理这些属性。这使得 <code>Island</code>组件更加灵活，可以适应不同的使用场景。</li><li><strong>简洁性</strong>：避免了需要显式地为每个可能的属性编写传递逻辑，从而使组件代码更加简洁和易于维护。</li><li><strong>组件封装</strong>：保持了 <code>Island</code>组件对于其内部实现的封装性。调用者无需关心 <code>Island</code>如何处理或转发这些属性，只需要知道它可以接收并适当地使用这些属性。</li></ol><p><code>&lt;a.group&gt;</code>组件继承自Three.js的 <code>Group</code>类，将Three.js对象（如 <code>Group</code>、<code>Mesh</code>等）用 <code>a.</code>前缀包装，并通过 <code>@react-spring/three</code>获得了动画能力。在Three.js中，<code>Group</code>是一个用于包含和管理多个其他对象（例如，几何体、网格等）的容器。它本身是 <code>Object3D</code>的一个子类，这意味着它继承了 <code>Object3D</code>的所有属性，包括 <code>position</code>、<code>scale</code>和 <code>rotation</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%982/"/>
    <id>https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%982/</id>
    <published>2024-02-25T03:28:05.000Z</published>
    <updated>2024-06-13T02:14:37.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h1><h2 id="React-Three"><a href="#React-Three" class="headerlink" title="React Three"></a>React Three</h2><p><code>@react-three/fiber</code>表明这个包是React Three（一个专注于在React中使用three.js的项目）下的一个模块或子项目。这有助于开发者快速识别包的来源，同时也方便了对项目包的管理。</p><p>作用域包的结构让开发者更容易地发现和维护相关的包。例如，React Three项目可能包含多个相关包（如 <code>@react-three/fiber</code>、<code>@react-three/drei</code>等），这些都被归类在 <code>@react-three</code>这个作用域下。这种组织方式使得维护者和使用者能够轻松地识别和更新这些相互关联的包。</p><h3 id="1-react-three-fiber"><a href="#1-react-three-fiber" class="headerlink" title="1. @react-three/fiber"></a>1. <code>@react-three/fiber</code></h3><ul><li><strong>作用</strong>：这是React Three Fiber项目的核心库，提供了将three.js集成到React的基础架构。它是一个React渲染器，允许你以声明式的方式在React应用中创建和控制3D场景。</li><li><strong>区别</strong>：作为基础库，它不提供额外的three.js对象或抽象，而是专注于提供与React兼容的three.js渲染环境。</li></ul><h3 id="2-react-three-drei"><a href="#2-react-three-drei" class="headerlink" title="2. @react-three/drei"></a>2. <code>@react-three/drei</code></h3><ul><li><strong>作用</strong>：<code>drei</code>是一个工具包，提供了许多有用的辅助组件和钩子（hooks），以简化在React Three Fiber中开发3D场景的过程。这些组件包括环境灯光、效果、加载器、抽象的3D对象等。</li><li><strong>区别</strong>：与 <code>@react-three/fiber</code>相比，<code>drei</code>更多地提供了构建3D场景时的”快捷方式”，帮助开发者减少样板代码和加快开发流程。</li></ul><h3 id="3-react-three-cannon"><a href="#3-react-three-cannon" class="headerlink" title="3. @react-three/cannon"></a>3. <code>@react-three/cannon</code></h3><ul><li><strong>作用</strong>：这个包提供了物理引擎的集成，基于 <code>cannon.js</code>物理引擎。它允许开发者在React Three Fiber创建的3D场景中添加物理效果，如碰撞检测、重力和弹性。</li><li><strong>区别</strong>：专注于为3D对象添加物理特性，而不是3D渲染或组件的直接创建。</li></ul><h3 id="4-react-three-postprocessing"><a href="#4-react-three-postprocessing" class="headerlink" title="4. @react-three/postprocessing"></a>4. <code>@react-three/postprocessing</code></h3><ul><li><strong>作用</strong>：该包提供了对后处理效果的支持，允许开发者在React Three Fiber场景中添加和配置后处理效果，如模糊、光晕、色彩校正等。</li><li><strong>区别</strong>：专注于渲染流程中的后期处理效果，改善或增加场景的视觉效果。</li></ul><h3 id="5-react-three-gui"><a href="#5-react-three-gui" class="headerlink" title="5. @react-three/gui"></a>5. <code>@react-three/gui</code></h3><ul><li><strong>作用</strong>：提供了一个简易的图形用户界面（GUI），用于在开发过程中调试和修改three.js场景的参数。</li><li><strong>区别</strong>：主要用于开发和调试阶段，通过图形界面快速调整场景参数，而不直接影响3D内容的渲染或逻辑。</li></ul><h3 id="6-react-three-xr"><a href="#6-react-three-xr" class="headerlink" title="6. @react-three/xr"></a>6. <code>@react-three/xr</code></h3><ul><li><strong>作用</strong>：支持构建虚拟现实（VR）和增强现实（AR）体验。它提供了创建和管理XR会话的工具，允许开发者在兼容的设备上提供沉浸式的3D体验。</li><li><strong>区别</strong>：专门针对XR应用的开发，提供了与VR和AR技术集成的工具和组件</li></ul><h1 id="React-Three-Fiber"><a href="#React-Three-Fiber" class="headerlink" title="React Three Fiber"></a>React Three Fiber</h1><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">官网教程</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a><a href="https://docs.pmnd.rs/react-three-fiber/api/canvas">Canvas</a></h2><p><strong>Scene+Camera+raycaster+(shadow)</strong></p><p>**Canvas里面的内容，可以用驼峰法写，不需要导入，直接是原生的JSX组件。如 **<code>&lt;mesh&gt;&lt;/mesh&gt;</code>, <code>&lt;boxGeometry /&gt;</code>, <code>&lt;meshStandardMaterial /&gt;</code>。但从v8以后，不会自动化导入这些，可以导入react-three-fiber，然后可以直接写这些；或者是通过import ‘three’</p><p><strong>ThreeJS里的类的构造器的参数传入，</strong><code>&lt;boxGeometry args=&#123;[w,h,d]&#125;/&gt;</code></p><h2 id="与threejs的转换"><a href="#与threejs的转换" class="headerlink" title="与threejs的转换"></a>与threejs的转换</h2><p><a href="https://docs.pmnd.rs/react-three-fiber/api/objects">对象，属性和构造器参数设置</a>（说明了从ThreeJS过渡到react-three-fiber的一些注意点）</p><p><strong>有set方法的对象</strong></p><blockquote><p><strong>可以直接用&#x3D;，如果有多个参数，可以放入array</strong></p><p><code>color=&quot;hotpink&quot;</code> not <code>color=&#123;new THREE.Color(&#39;hotpink&#39;)&#125;</code></p><p><code>position=&#123;[100,0,0]&#125;</code> not set</p></blockquote><p><strong>有setScalar这种类似的方法，可以直接用属性scale</strong></p><blockquote><p><code>&lt;mesh scale=&#123;1&#125; /&gt;</code> or <code>&lt;mesh scale=&#123;[1,1,1]&#125; /&gt;</code></p></blockquote><p><strong>有类似mesh.rotation.x这种串接的方法，使用-来连接</strong></p><blockquote><p><code>&lt;mesh rotation-x =&#123;1&#125; /&gt;</code></p></blockquote><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>**在 **<code>react-three-fiber</code>（R3F）中，<code>attach</code>属性是一个非常重要的概念，用于将React组件的某些属性或对象“附加”到Three.js的父对象上。这样做的目的是为了在R3F的React元素树中保持Three.js场景图的结构和属性同步。</p><p><code>attach</code>属性通常用于 <code>&lt;primitive&gt;</code>组件或任何自定义组件内部，来指定如何将当前组件的Three.js对象（如材质、几何体、相机等）附加到其父Three.js对象上。例如，你可以将一个材质附加到一个网格上，或者将一个相机附加到场景中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mesh&gt;</span><br><span class="line">  &lt;boxGeometry attach=&quot;geometry&quot; args=&#123;[1, 1, 1]&#125; /&gt;</span><br><span class="line">  &lt;meshStandardMaterial attach=&quot;material&quot; color=&quot;orange&quot; /&gt;</span><br><span class="line">&lt;/mesh&gt;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中：</strong></p><ul><li><code>&lt;boxGeometry&gt;</code>的 <code>geometry</code>对象被附加到父 <code>&lt;mesh&gt;</code>的 <code>geometry</code>属性上。</li><li><code>&lt;meshStandardMaterial&gt;</code>的 <code>material</code>对象被附加到相同 <code>&lt;mesh&gt;</code>的 <code>material</code>属性上。</li></ul><p><strong>在传统的Three.js应用中，你需要手动管理场景图的所有方面，包括创建对象、设置属性、添加到场景中等。而在R3F中，</strong><code>attach</code>属性简化了这一过程，允许你直接在JSX中以声明式的方式组织和连接Three.js的对象。</p><p><strong>例如，传统Three.js中创建和添加一个带材质的立方体可能需要这样：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const geometry = new THREE.BoxGeometry(1, 1, 1);</span><br><span class="line">const material = new THREE.MeshStandardMaterial(&#123;color: &#x27;orange&#x27;&#125;);</span><br><span class="line">const mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><p>**而在R3F中，相同的操作可以通过使用 **<code>attach</code>属性在JSX中直接声明，如前面的例子所示，这使得代码更加简洁并且保持了React的声明式风格。</p><p><strong>总之，</strong><code>attach</code>属性是 <code>react-three-fiber</code>中连接React组件属性和Three.js对象的强大工具，它简化了在React中构建和管理复杂3D场景的过程。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><strong>只能使用在Canvas元素里，因为Hooks依赖于context.</strong></p><h3 id="useThree"><a href="#useThree" class="headerlink" title="useThree"></a>useThree</h3><p><strong>const state &#x3D; useThree()</strong></p><p><strong>state.gl, .scene, .camera, .raycaster, .pointer(.mouse), .clock, .linear, .legacy, .frameloop, .performace, .size, .viewport, .set(), .get(), .invalidate(), .setSize(), .setDpr(), .setFrameloop(), .setEvents(), .onPointerMissed(), .events</strong></p><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame"></a>useFrame</h3><p><strong>useFrame((state, clock_delta, xrFrame) &#x3D;&gt;{})</strong></p><h3 id="useLoader"><a href="#useLoader" class="headerlink" title="useLoader"></a>useLoader</h3><h3 id="useGraph"><a href="#useGraph" class="headerlink" title="useGraph"></a>useGraph</h3><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/examples">官方案例</a></p><h2 id="react-spring"><a href="#react-spring" class="headerlink" title="@react-spring"></a>@react-spring</h2><p><code>@react-spring</code>是一个基于Spring物理原理的现代React动画库，它允许开发者以声明式的方式在React应用中创建流畅、自然的动画效果。<code>@react-spring</code>的设计旨在简化动画的创建和管理，提供了一种简单而强大的方法来实现复杂的动画效果，无论是简单的值变化、列表的动态排序，还是复杂的交互动画。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>简洁的API</strong>：通过简单的API，开发者可以轻松创建和控制动画。</li><li><strong>物理原理驱动</strong>：动画效果基于真实的物理原理，使得动画看起来更自然。</li><li><strong>高性能</strong>：优化的性能确保即使在复杂动画中也能保持流畅。</li><li><strong>适用范围广</strong>：支持Web（React）、React Native和其他平台，通过相同的API在不同平台上创建动画。</li></ul><h3 id="主要子项目"><a href="#主要子项目" class="headerlink" title="主要子项目"></a>主要子项目</h3><p><code>@react-spring</code>项目包含了几个子项目，分别针对不同的平台或提供特定的功能：</p><ol><li>**<code>@react-spring/web</code>**：专为Web平台设计，用于在Web应用中创建动画。它提供了与DOM元素交互的能力，是构建Web界面动画的理想选择。</li><li>**<code>@react-spring/native</code>**：专为React Native设计，允许在React Native应用中创建流畅的原生动画效果。它利用React Native的动画库来实现高性能的动画。</li><li>**<code>@react-spring/core</code>**：是 <code>@react-spring</code>库的核心，提供了动画功能的基本实现。其他子项目如 <code>@react-spring/web</code>和 <code>@react-spring/native</code>都是在这个核心基础上扩展而来，以支持特定平台的动画效果。</li><li>**<code>@react-spring/three</code>**：为three.js提供动画支持，允许在使用React Three Fiber开发的3D场景中创建和管理动画。这使得开发者可以在3D应用中实现复杂的动画效果。</li><li>**<code>@react-spring/konva</code>**：用于在React Konva（一个用于在React中绘制2D canvas图形的库）项目中创建动画。这使得开发者可以为2D图形和图像添加动画效果。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><strong>平台支持</strong>：主要区别在于各个子项目针对的平台或库不同。<code>@react-spring/web</code>专注于Web平台，<code>@react-spring/native</code>专注于React Native，而 <code>@react-spring/three</code>和 <code>@react-spring/konva</code>则分别针对three.js和Konva。</li><li><strong>使用场景</strong>：虽然这些子项目在API设计上保持一致性，但它们提供的动画能力和使用场景各有侧重，例如 <code>@react-spring/three</code>专门处理3D动画，而 <code>@react-spring/konva</code>处理2D canvas动画。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@react-spring</code>提供了一个跨平台的动画解决方案，通过不同的子项目满足了在Web、React Native、3D场景和2D canvas图形中创建动画的需求。</p><h2 id="React-router-dom"><a href="#React-router-dom" class="headerlink" title="React router dom"></a>React router dom</h2><p>**在React应用中使用 **<code>react-router-dom</code>库时，<code>Route</code>、<code>BrowserRouter</code>（在这里使用别名 <code>Router</code>），和 <code>Routes</code>组件是构建单页面应用（SPA）路由系统的核心。下面是每个组件的作用以及为什么它们通常会一起被导入和使用：</p><p><strong>BrowserRouter (别名 Router)</strong></p><ul><li><strong>作用</strong>：<code>BrowserRouter</code>是一个使用HTML5历史API（<code>pushState</code>、<code>replaceState</code>和 <code>popstate</code>事件）来保持UI与URL同步的路由器。它为React应用提供了一个路由的上下文环境。使用 <code>BrowserRouter</code>时，你的网址看起来很“干净”，不会有 <code>#</code>符号。</li></ul><p><strong>Routes</strong></p><ul><li><strong>作用</strong>：<code>Routes</code>组件在 <code>react-router-dom</code> v6中引入，用于替代v5中的 <code>Switch</code>组件。它负责根据当前的URL决定哪一个子 <code>Route</code>组件应该被渲染。<code>Routes</code>组件会选择与当前URL匹配的最佳 <code>Route</code>来渲染，并提供了嵌套路由的支持。</li></ul><p><strong>Route</strong></p><ul><li><strong>作用</strong>：<code>Route</code>组件用于在路由系统中定义单个路由规则。它接受一个 <code>path</code>属性，用于指定路由的匹配路径，以及一个 <code>element</code>属性，用于指定当该路由匹配时应该渲染的组件。</li></ul><p><strong>这三个组件通常一起使用来构建React应用的路由系统。</strong><code>BrowserRouter</code>提供了一个高阶的路由容器，<code>Routes</code>用于管理路由的选择逻辑，而 <code>Route</code>用于定义具体的路由规则和对应渲染的组件。没有 <code>BrowserRouter</code>，路由系统将无法工作，因为它提供了路由的上下文；没有 <code>Routes</code>和 <code>Route</code>，你就无法定义和管理你的路由规则。这种模式允许React开发者以一种声明式的方式来组织和管理用户在应用中的导航路径，同时确保应用的UI与URL保持同步，从而提高用户体验和应用的可维护性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Routes&gt;</span><br><span class="line">    &#123;/* 路由配置 */&#125;</span><br><span class="line">    &lt;Route path=&quot;/&quot; element=&#123;&lt;HomePage /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; element=&#123;&lt;AboutPage /&gt;&#125; /&gt;</span><br><span class="line">  &lt;/Routes&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%981/"/>
    <id>https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%981/</id>
    <published>2024-02-25T03:23:05.000Z</published>
    <updated>2024-06-13T02:14:46.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><code>npm create vite@latest ./</code> 在当前目录安装react</p><p><code>npm install</code> 安装需要的包</p><p><code>npm run dev</code> 运行开发环境</p><p>delete src folder, and create a new one called ‘src’.</p><p>new file ‘main.jsx’ and code, change ‘tsx’ to ‘jsx’ in ‘main.html’</p><p>new file ‘App.jsx’ and code ➡️ rafce shortcut(ES7+React… plugin embeded)</p><p>open a new TERMINAL then <code>npm install -D tailwindcss postcss autoprefixer</code>, <code>npx tailwindcss init -p</code>, configure path,</p><blockquote><p><a href="https://tailwindcss.com/docs/installation">documentation</a></p><p>install ‘npx’ in advance: <code>npm i -g npx</code></p></blockquote><p>new file ‘index.css’, and import it in ‘main.jsx’</p><p>copy the downloaded file ‘index.css’ for your ‘index.css’</p><p>copy the downloaded file ‘tailwind.cofig.js’ for your ‘tailwind.config.js’</p><p>install the plugin ‘Tailwind CSS IntelliSense’ , then vscode can recognize the css code in html</p><p>then restart the server, the result is shown!</p><p>install: <code>npm i react-router-dom</code></p><p>create folder ‘components’, and create file ‘Navbar.jsx’, and code</p><p>create folder ‘pages’ and file ‘About.jsx’, ‘Contact.jsx’, ‘Home.jsx’, ‘Projects.jsx’</p><p>create index.js to import all the following, then export for use</p><p><code>npm i @react-three/fiber</code></p><p><code>npm i @react-three/drei</code></p><p>download foxs_islands.glb from sketchfab, use <a href="https://gltf.pmnd.rs/">this website</a> to simplize and transfer it.</p><blockquote><p>use model offered by author directly</p><p>可以找一些教程，来使用这个网站对模型进行简化。</p></blockquote><p>create folder ‘models’ and file ‘Island.jsx’, then copy and paste the model info</p><blockquote><p><code>npm i @react-spring/three</code></p><p>修改成能导出的模型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useRef, useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; useGLTF &#125; from &quot;@react-three/drei&quot;;</span><br><span class="line">import &#123; useFrame, useThree &#125; from &quot;@react-three/fiber&quot;;</span><br><span class="line">import isLandScene from &#x27;../assets/3d/island.glb&#x27;</span><br><span class="line">import &#123; a &#125; from &#x27;@react-spring/three&#x27;</span><br><span class="line"></span><br><span class="line">const &#123; nodes, materials &#125; = useGLTF(isLandScene);</span><br><span class="line">const Island = (props) =&gt; &#123; ..return(&lt;a.group&#123;&#125;..)..&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default Island;</span><br></pre></td></tr></table></figure></blockquote><p>删除：</p><blockquote><p>dispose&#x3D;{null}</p><p>castShadow</p><p>receiveShadow</p><p>useGLTF.preload(“&#x2F;island.glb”);</p></blockquote><p>修改：</p><blockquote><p>&lt;a.group ref&#x3D;{islandRef} {…props}&gt;</p></blockquote><p>in vite.config.js, modify:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [react()],</span><br><span class="line">  assetsInclude: [&#x27;**/*.glb&#x27;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>给light添加属性的时候，会提示“unknown property ‘position’ found“，这个时候需要在.eslintrc.cjs里添加：</p><p><code>ignorePatterns: [&#39;dist&#39;, &#39;.eslintrc.cjs&#39;, &#39;src&#39;],</code></p><p>加载上各类模型，然后尝试实现拖动旋转和飞行 ➡️ 这个效果就是这个的<a href="https://www.joshuas.world/">初级版</a></p><p>GitHub Copilot的使用，免费1个月的订阅，也认证了<a href="https://education.github.com/discount_requests/application">学生身份</a>（可以免费使用）</p><p>报错提示Island.jsx:109  Uncaught ReferenceError: setCurrentStage is not defined</p><p>在jsx文件内部定义的节点，需要注意返回return，外面的才能使用节点定义的结构；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i @emailjs/browser</span><br></pre></td></tr></table></figure><p>在<a href="https://dashboard.emailjs.com/admin/templates/0hhd7hu/settings">emailjs官网</a>上，creat free account</p><p>add new service → Service ID → connect account → create service</p><p>Email Template → Save → Settings, Template ID</p><p>把这些参数放到新的文件.env.local里面</p><p>错误：message栏总是输入无响应，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;textarea</span><br><span class="line">              name=<span class="string">&quot;message&quot;</span> </span><br><span class="line">              rows=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">              className=<span class="string">&#x27;textarea&#x27;</span></span><br><span class="line">              placeholder=<span class="string">&#x27;Let me know how I can help you!&#x27;</span></span><br><span class="line">              required</span><br><span class="line">              value=&#123;form.<span class="property">message</span>&#125;</span><br><span class="line">              onChange=&#123;handleChange&#125;</span><br><span class="line">              onFocus=&#123;handleFocus&#125;</span><br><span class="line">              onBlur=&#123;handleBlur&#125;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="comment">// 是name=&quot;message&quot;,而不是type=&quot;message&quot;</span></span><br><span class="line"><span class="comment">// row=&#x27;4&#x27; 而不是row=&#123;4&#125;</span></span><br></pre></td></tr></table></figure><p>对于fox的模型，可以去gltf.pmnd.rs网站，拖入后，把代码复制到Fox.jsx里进行调整（这个网站实现了GLTF -&gt; React Three Fiber）</p><p>之后记得修改，不然会报错 <code>Contact.jsx:5 Uncaught SyntaxError: The requested module &#39;/src/models/Fox.jsx&#39; does not provide an export named &#39;default&#39; (at Contact.jsx:5:8)</code></p><p>导入images文件夹，以及构建constants-&gt;index.js，复制粘贴进去内容；可以针对自己情况进行修改；</p><p>为了实现时间线的功能，需要 <code>npm i react-vertical-timeline-component</code></p><p>参考案例进行模仿使用；</p><p>最后作者完成了部署deployment，通过hostinger网站</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ARFoundation学习</title>
    <link href="https://youxt-njnu.github.io/2024/02/17/ARFoundation%E5%85%A5%E9%97%A8/"/>
    <id>https://youxt-njnu.github.io/2024/02/17/ARFoundation%E5%85%A5%E9%97%A8/</id>
    <published>2024-02-17T00:44:05.000Z</published>
    <updated>2024-02-20T09:59:22.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h1><blockquote><p>加入一些 ar 技术交流群，看一些博客。博客推荐_davidwang_的 arfoundation 之路，csdn 上的。<br>可以读一些官方文档，像 ARCore 和 ARKit 的。每年的 wwdc 苹果全球开发者大会都会有人讲 ARKit 有哪些新的功能，可以去理解底层是如何设计的。unity 官方也会出一些视频讲 ar 方面的内容<br><img src="https://cdn.jsdelivr.net/gh/youxt-njnu/blog-img/46F5DA628CA079FB5612771E5407D8AE.png"></p></blockquote><h1 id="打包教程"><a href="#打包教程" class="headerlink" title="打包教程"></a>打包教程</h1><p> <a href="https://www.bilibili.com/video/BV1Qt4y1a7aW?p=11&vd_source=5270415d668b21206238403450bb29b5">https://www.bilibili.com/video/BV1Qt4y1a7aW?p=11&amp;vd_source=5270415d668b21206238403450bb29b5</a><br> notes:<br> ios的打包<a href="https://cloud.tencent.com/developer/article/2098356">教程</a>，需要有ios的环境（但我们没有苹果电脑，此外我在尝试给实验室工位上的电脑装虚拟机，之前试过一次失败了；可以回头搜一搜哔哩哔哩，找找怎么配置）<br> <a href="https://blog.51cto.com/myselfdream/2493033">https://blog.51cto.com/myselfdream/2493033</a><br> 2</p><h1 id="实操案例"><a href="#实操案例" class="headerlink" title="实操案例"></a>实操案例</h1><p><a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.1/manual/index.html">AR Foundation | AR Foundation | 5.1.0 (unity3d.com)</a></p><p>AR Foundation手册：<br><a href="https://docs.unity3d.com/cn/2021.3/Manual/com.unity.xr.arfoundation.html">https://docs.unity3d.com/cn/2021.3/Manual/com.unity.xr.arfoundation.html</a></p><h2 id="Gaze-Interaction-in-Unity-Mapbox🔍"><a href="#Gaze-Interaction-in-Unity-Mapbox🔍" class="headerlink" title="Gaze Interaction in Unity+Mapbox🔍"></a>Gaze Interaction in Unity+Mapbox🔍</h2><blockquote><p><a href="https://www.youtube.com/watch?v=Xhz3cmnluNo&list=PL88ZsSjUqiTD0CJAdMQ9MO3m43mxVjMoU&index=1">https://www.youtube.com/watch?v=Xhz3cmnluNo&amp;list=PL88ZsSjUqiTD0CJAdMQ9MO3m43mxVjMoU&amp;index=1</a><br><a href="https://www.youtube.com/watch?v=OE66gtiF8QQ&list=PLNFBI1dJIh36ku4BVYGBEcvDuQAGSrcbn&index=14">https://www.youtube.com/watch?v=OE66gtiF8QQ&amp;list=PLNFBI1dJIh36ku4BVYGBEcvDuQAGSrcbn&amp;index=14</a></p></blockquote><p>安装包：AR Foundation; ARCore XR Plugin; ARKit XR Plugin<br>删除初始相机，构建XR-&gt;AR Session Origin;<br>构建XR-&gt; AR Session, XR-&gt;AR Default Point Cloud, XR-&gt;AR Default Plane<br>为AR Session Origin添加component：AR Point Cloud Manger, AR Plane Manager, AR Raycast Manager,并把之前的Point Cloud和Plane的gameobject挂载上去；</p><p>新建3D物体Plane，并确保zero out(就是reset为初始化0)，这个plane就是为了实现AR的shadow和stuff的渲染；删除mesh collider，并重命名为ContentParent; 所有它的子物体都会显示在AR的场景下；</p><p>新建子物体Cube，然后设置Scale为(0.2,0.2,.0.2),因为在AR的里面，一个单位对应的是一米，原始的1太大了。此外，把物体的y设置为0.1，这样物体就看着是放置在平面上了。</p><p>为了不看到plane,把mesh render设置为非激活状态；</p><p>之后添加toggle，来实现对点云呈现与否的切换：</p><blockquote><p>UI-&gt;Canvas, RenderMode:ScreenSpace-Overlay, UIScaleMode: ScaleWithScreenSize<br>UI-&gt;Toggle: 修改锚点到左上角，Pivot为x&#x3D;0,y1&#x3D;1,然后调整PosX&#x3D;0,PosY&#x3D;0; Toggle内部的把Text删掉，设置Background锚点下为Stretch，right为0；然后回到Toggle，设置宽高；再回到background里的checkmark，设置为stretch，调整left&#x3D;0, top&#x3D;0, right&#x3D;0,bottom&#x3D;0</p></blockquote><p>新建Scripts文件夹，构建脚本PlaceContent.cs, ToggleAR.cs</p><blockquote><p>PlaceContent挂在ContentParent上；<br>ToggleAR挂在Toggle上，同时Toggle添加OnValueChanged的事件，拖入的是Toggle的Toggle AR的脚本组件</p></blockquote><p>切换环境到安卓，并添加main到Scenes in Build里；<br>修改PlayerSettings里的PackageName为com.matt.GazeInteraction; 并同时修改到IOS的包里面；</p><p>之后在playsettings里</p><blockquote><p>IOS: 激活requires arkit support，修改target minimum iOS version为11.0;修改Architecture为arm64；<br>Android: 删除Graphics APIs里的Vulkan; 取消勾选Multithreaded rendering;  Minimum API Level为Android 7.0 ‘Nougat’(API level 24)；修改scripting backend为IL2CPP，勾选ARM64</p></blockquote><p>黑屏问题解决：<a href="https://blog.51cto.com/u_15127683/4151076">https://blog.51cto.com/u_15127683/4151076</a></p><p>对Cube修改大小scale为(0.5,0.5,0.5);<br>create Empty: SectionInfo<br>create Quard: InfoParent;<br>略微拉高SectionInfo, 修改Quard的rotation(0,180,0), scale(2,1,1)</p><p>新建材质文件夹，构建trans材质，设置为rgb0-1.0,调整透明度为0.7,黑色背景。</p><p>对InfoParent构建child object:Cube和Text(TMP)</p><blockquote><p>前者拉下来，然后调整scale，添加材质；<br>后者</p><ul><li>因为一开始添加之后字体扭曲了distorted，所以修改y的scale为2，</li><li>在Scene上方找到Gizmos并激活（这里我没有找到，而是默认就激活了，就是那个圆形按钮一样的带一个下拉框的，这个选项是让text上显示黄色线框）；</li><li>调整width和height（不要再修改scale了），使得text的边框可以和InfoParent大小一致</li><li>设置text里的内容居中，字体大小fontsize随着线框大小变化auto size，最小为0，最大为1000</li><li>如果在上y右x的坐标下，text显示在infoParent的里面，则需要把text往外拉；</li><li>修改里面的内容为Here is some infos.</li><li>关掉线框</li><li>为了让SectionInfo缩放的时候，感觉是从cube弹出来的，需要先把InfoParent从子物体拉出来，然后修改SectionInfo的Y大小为0.5，然后再把InfoParent拉进来还原为子物体。这个时候缩放SectionInfo就正常了</li></ul></blockquote><p>让text的Extra Settings里的order in layer设置为1，可以首先显示出来。<br>新建材质，命名为Blue，修改颜色为蓝色，然后给Cube这个材质；</p><p>添加脚本InfoBehaviour，实现SectionInfo的缩放，并给到Cube上（因为Cube上放了Box Collider），也拖入SectionInfo作为transform的那个参数；</p><p>为了让SectionInfo会始终面向摄像机，也就是随着相机旋转，添加脚本FaceCamera;</p><blockquote><p>我们不希望SectionInfo的x和z轴方向旋转，所以需要设置为0；<br>为了进行验证，加上了[ExecuteInEditMode]，这样就可以在编辑模式里面通过移动摄像机测试是否生效（为了让项目中的摄像机可以被获取到，需要在参数设置面板中设置为main camera</p></blockquote><p>之后新建gaze脚本，挂到AR Camera上（main camera)</p><blockquote><p>获取到射线投射到的物体，通过tag判断是否是有信息的可交互的gameobject</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充知识点：</span><br><span class="line">forward：Returns a normalized vector representing the blue axis of the transform in world space.</span><br><span class="line">语法：public Vector3 forward;</span><br><span class="line">该属性可以默认设置为局部坐标系Z轴的正向移动，同样的属性在Vector3类也有，与Transform类不同的是Transform.forward在考虑旋转的同时进行移动，而Vector3.foward不考虑旋转因素，若物体在旋转时发生移动，则移动情况会发生改变，也就是Transform.forward使用的时局部坐标系，若要忽略旋转对物体移动的影响，我们使用Vector3.foward，也会是说Vector3.foward用的是世界坐标系，这里补充一个小细节，Unity默认的坐标轴颜色，x轴为红色，z轴为蓝色，y轴为绿色，</span><br></pre></td></tr></table></figure><p>修改Game为800*480的Landscape，然后看到toggle有点大，所以进行width和height的大小，和location的位置，移动到左上角。</p><h2 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h2><p><a href="https://www.bilibili.com/video/BV1VT4y1z7MH?p=1&vd_source=5270415d668b21206238403450bb29b5">https://www.bilibili.com/video/BV1VT4y1z7MH?p=1&amp;vd_source=5270415d668b21206238403450bb29b5</a></p><blockquote><p>arfoundation教程里具备环境之后的操作：<br>登录：developer.apple.com&#x2F;download&#x2F;<br>需要一个新版本的Mac OS，Xcode(ios 13);<br>作者安装了macOS Catalina 10.15 beta, iOS 13 beta</p></blockquote><p>新建场景scene；<br>新建gameobject：</p><blockquote><p>ar session<br>ar session origin(在原点的地方新建了一个，然后里面的相机就是AR的相机)， add components(ar plane manager(script)<br>新建一个empty gameobject，add components(ar plane, ar plane mesh visulizer, mesh collider, mesh filter, mesh renderer, line renderer),针对line renderer，设置lighting里的shadow\width\materials\corner vertices\en cap vertices\use world space\loop ———-&gt; 也就是xr里的ar default plane<br>在ar session origin里的ar pane manager关联一下内置的prefab: ar default plane<br>新建脚本PlacementController.cs并挂到ar session origin上面<br>添加自定义的物体prefab，然后就可以打包了</p></blockquote><p>Selection 场景</p><blockquote><p>添加PlacedObject, 挂载Placement Object.cs<br>在AR Session Origin上，挂载PlacementWithManySelectionController.cs<br>notes: 注意，一个是物体的位置设置，可以把相机拉远一点，如果物体不在视锥体里面，是在相机里看不到的；<br>其他部分还是保持默认即可<br>这个最后的效果是以手机处为中心的，所以做不到锚点定位<br>但这个静态的，就可以考虑加上地形的一套</p></blockquote><h2 id="室内导航demo"><a href="#室内导航demo" class="headerlink" title="室内导航demo"></a>室内导航demo</h2><p><a href="https://www.youtube.com/watch?v=fuHFrMZ4q_s">https://www.youtube.com/watch?v=fuHFrMZ4q_s</a></p><h2 id="ardraw-demo"><a href="#ardraw-demo" class="headerlink" title="ardraw demo"></a>ardraw demo</h2><h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><p><a href="https://github.com/Unity-Technologies/arfoundation-samples/tree/4.2">https://github.com/Unity-Technologies/arfoundation-samples/tree/4.2</a></p><h2 id="ar云锚点等需要的功能"><a href="#ar云锚点等需要的功能" class="headerlink" title="ar云锚点等需要的功能"></a>ar云锚点等需要的功能</h2><p><a href="https://www.bilibili.com/video/BV1fX4y137BY/?vd_source=5270415d668b21206238403450bb29b5">bilibili视频</a></p><h1 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h1><p>打包的时候：Unity.IL2CPP.Building.BuilderFailedException</p><blockquote><p>切到新版本上(2020-&gt;2021)</p></blockquote><p>Building Library\Bee\artifacts\Android\d8kzr\libil2cpp.so failed with output:</p><blockquote><p>删掉Unity已经弃用的UnityARKitPlugin 的旧插件</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习方式&quot;&gt;&lt;a href=&quot;#学习方式&quot; class=&quot;headerlink&quot; title=&quot;学习方式&quot;&gt;&lt;/a&gt;学习方式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;加入一些 ar 技术交流群，看一些博客。博客推荐_davidwang_的 arfoundation</summary>
      
    
    
    
    <category term="AR开发" scheme="https://youxt-njnu.github.io/categories/AR%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="软件端AR" scheme="https://youxt-njnu.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%AB%AFAR/"/>
    
    <category term="ARFoundation" scheme="https://youxt-njnu.github.io/tags/ARFoundation/"/>
    
  </entry>
  
  <entry>
    <title>DOTween学习</title>
    <link href="https://youxt-njnu.github.io/2024/02/17/DOTween%E5%85%A5%E9%97%A8/"/>
    <id>https://youxt-njnu.github.io/2024/02/17/DOTween%E5%85%A5%E9%97%A8/</id>
    <published>2024-02-17T00:42:05.000Z</published>
    <updated>2024-02-20T09:58:08.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOTween入门"><a href="#DOTween入门" class="headerlink" title="DOTween入门"></a>DOTween入门</h1><p><a href="https://blog.csdn.net/LittleWhiteLv/article/details/101026616#:~:text=using%20DG.Tweening%3B%20public%20class%20Shake%20%3A%20MonoBehaviour%20%7B,0%29%2C%2030%2C%20360%2C%20false%2C%20false%29%3B%20%7D%20%7D%20%E7%84%B6%E5%90%8E%E6%8B%96%E6%8B%BD%E8%87%B3%E9%9C%80%E8%A6%81%E9%9C%87%E5%8A%A8%E7%9A%84%E7%89%A9%E4%BD%93%E4%B8%8A%E5%8D%B3%E5%8F%AF%E3%80%82">(81条消息) DOTween 插件下载及基本使用说明_dgtweening下载_四月的小白的博客-CSDN博客</a></p><p>面板Tools-&gt;Demigiant-&gt;DoTween utility panel</p><p>组件常用参数说明：</p><p>AutoPlay:自动播放动画</p><p>AutoKill:自动删除动画</p><p>Duration:动画时长</p><p>Delay:延迟时长（过一段时间再播放）</p><p>Ease:动画播放的速度曲线</p><p>Loop:循环的次数（-1表示一直执行）</p><p>LoopType:循环模式（Restart:重新开始，Yoyo:来回摆动，Incremental:增量模式）</p><p>PathType：路径模式（CatmullRom：曲线；Linear:直线）</p><p>ClosePath:路径是否首尾相连</p><p>LocalMovement:是否是本地坐标</p><p>Orientation:运动朝向（ToPath:朝向路径方向，Look At Transform:朝向物体，Look At Position：朝向坐标点）</p><p>Events中是动画各状态时的对应事件添加按钮，和Button的触发事件添加方法一样</p><p><a href="https://blog.csdn.net/qq_20179331/article/details/130592347">(81条消息) unity中的DG.Tweening详解_忽然602的博客-CSDN博客</a></p><p>DG.Tweening, Unity插件，创建Tween动画；</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> DG.Tweening;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">DOTween.To().OnComplete();</span><br><span class="line">Sequence sequence=DOTween.Sequence();</span><br><span class="line">sequence.Append(transform.DOMoveX()); <span class="comment">// DOTween.Sequence().Append().Append().Append();</span></span><br><span class="line">DoTween.Delay();</span><br><span class="line">DOTween.SetLoops();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tween tween=transform.DOMoveX(<span class="number">10f</span>,<span class="number">1f</span>).SetEase(Ease.InOutQuint); <span class="comment">//Tween还是Tweener</span></span><br><span class="line">DOTween.Kill(tween);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">tween.SetAutoKill(<span class="literal">false</span>); <span class="comment">//取消自动销毁</span></span><br><span class="line">tween.Pause(); <span class="comment">//设置暂停</span></span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">door.transform.DOMoveX(); <span class="comment">//需要把对应door添加到脚本交互界面上</span></span><br><span class="line">door.transform.DORotate();</span><br><span class="line">door.transform.DOScale();</span><br><span class="line">transform.DOPlayForwards(); <span class="comment">// 需要把脚本拖拽到对应物体上</span></span><br><span class="line">transform.DOPlayBakwards();</span><br><span class="line">transform.DOShakePosition();</span><br><span class="line"></span><br><span class="line">Renderer renderer = GetComponent&lt;Renderer&gt;(); <span class="comment">//直接获取到项目中的renderer</span></span><br><span class="line">renderer.material.DOFade(<span class="number">0f</span>, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><p>新建任务面板，将脚本挂载到UI面板上，以实现UI面板的移动</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClickButton</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>官方文档：<a href="http://dotween.demigiant.com/documentation.php#creatingSequence">DOTween - Documentation</a></p><p>一些案例：<a href="https://blog.csdn.net/xiaoguomumu/article/details/75243425">(81条消息) DoTween的使用与详解_牧guo的博客-CSDN博客</a></p><p>一些方法：<a href="https://www.cnblogs.com/zanzz/p/17077863.html">DoTween在lua中的添加以及DoTween的常用方法 - old_Host - 博客园 (cnblogs.com)</a></p><p>官网案例：</p><p> <code>&lt;mark&gt;</code>basic <code>&lt;/mark&gt;</code></p><p><img src="F:\marktextImg\2023-07-07-17-13-49-image.png"></p><p>Cube(w animation): DOTweenAnimaton.cs</p><p>Logo: DOTweenAnimation.cs</p><p>Image: Image, DOTweenAnimation.cs</p><p>Text、Text: Text(用了rich text), DOTweenAnimation.cs</p><p>Button: Button(OnClick(), 设置了DOTweenAnimation.DOPlay()</p><p>dotween里的动画曲线：<a href="https://blog.csdn.net/qq_33789001/article/details/124408540">Unity Dotween插件的运动曲线（Ease）介绍Ease选项Ease效果示例以及C#修改动画曲线功能_dotween ease_十幺卜入的博客-CSDN博客</a></p><p>dotween里的旋转模式：<a href="https://www.cnblogs.com/JunJiang-Blog/p/14883620.html">关于Dotween旋转以及OnValidate函数的解读 - 军酱不是酱 - 博客园 (cnblogs.com)</a></p><p>unity来控制旋转和朝向：<a href="https://blog.csdn.net/weixin_43994445/article/details/96354427#:~:text=1%2C%20transform.DORotate%20%28%29%20transform.DORotate%28new%20Vector3%280%2C%2060%2C%200%29%2C%200.3f%29%3B,Rotation%20DOTween%E7%9A%84%2C%20%E6%B3%A8%E6%84%8F%E4%BB%96%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%AA%E4%B8%89%E5%85%83%E6%95%B0%2C%20%E8%A6%81%E6%98%AF%E6%83%B3%E4%B8%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%89%A9%E4%BD%93%E7%9A%84%E6%9C%9D%E5%90%91%E4%B8%80%E8%87%B4%2C%20%E5%B0%B1%3A%20transform.DORotate%28other.transform.eulerAngles%2C%200.3f%29%3B%201">Unity 控制物体旋转、朝向的一些方法_dolookat_幻冬的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DOTween入门&quot;&gt;&lt;a href=&quot;#DOTween入门&quot; class=&quot;headerlink&quot; title=&quot;DOTween入门&quot;&gt;&lt;/a&gt;DOTween入门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LittleWhite</summary>
      
    
    
    
    <category term="AR开发" scheme="https://youxt-njnu.github.io/categories/AR%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unity" scheme="https://youxt-njnu.github.io/tags/Unity/"/>
    
    <category term="DOTween" scheme="https://youxt-njnu.github.io/tags/DOTween/"/>
    
  </entry>
  
  <entry>
    <title>Lua/XLua学习</title>
    <link href="https://youxt-njnu.github.io/2024/02/17/Lua%E5%AD%A6%E4%B9%A0/"/>
    <id>https://youxt-njnu.github.io/2024/02/17/Lua%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-17T00:26:05.000Z</published>
    <updated>2024-02-20T09:57:55.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua入门"><a href="#Lua入门" class="headerlink" title="Lua入门"></a>Lua入门</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>教程：<a href="https://www.dba.cn/book/lua/LUAJiaoCheng/LUAJiBenYuFa.html">Lua 基本语法 - Lua中文手册 (dba.cn)</a></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>) </span><br><span class="line"><span class="comment">-- note</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> note</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>执行</p><p>$ lua filename.lua</p><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p><p>在默认情况下，变量总是认为是全局的。</p><p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p><p>如果你想删除一个全局变量，只需要将变量赋值为nil。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">boolean, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">number</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>, <span class="string">&quot;&quot;</span>, <span class="string">[[]]</span>, str1 .. str2, #str, </span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>, &#123;&#125;, <span class="built_in">table</span>[key]=value, key从<span class="number">1</span>开始, </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>, <span class="title">function</span> <span class="title">end</span>, <span class="title">fun2</span>=<span class="title">fun1</span>, </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>匿名函数</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span><span class="params">(tab, fun)</span></span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(fun(k, v))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tab = &#123; key1 = <span class="string">&quot;val1&quot;</span>, key2 = <span class="string">&quot;val2&quot;</span> &#125;</span><br><span class="line">anonymous(tab, <span class="function"><span class="keyword">function</span><span class="params">(key, val)</span></span></span><br><span class="line">    <span class="keyword">return</span> key .. <span class="string">&quot; = &quot;</span> .. val</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>..是拼接的意思<br>#实现求字符串长度</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x <span class="comment">--多变量同时赋值</span></span><br><span class="line">x, y = y, x <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;，变量交换</span></span><br><span class="line"><span class="comment">-- 多值赋值经常用来交换变量，或将函数调用返回给变量：</span></span><br><span class="line">a, b = f()</span><br><span class="line"></span><br><span class="line">t = &#123;&#125;</span><br><span class="line">t[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;www.dba.cn&quot;</span></span><br><span class="line">t[<span class="string">&quot;key&quot;</span>]</span><br><span class="line">t.key  <span class="comment">-- 当索引为字符串类型时的一种简化写法</span></span><br></pre></td></tr></table></figure><p>Lua认为false和nil为假，true 和非nil为真。要注意的是Lua中 0 为 true。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">local</span>] <span class="function"><span class="keyword">function</span> <span class="title">fun1</span><span class="params">(x,y)</span></span> </span><br><span class="line">    x=x+<span class="number">1</span></span><br><span class="line">    y=y*<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&gt;b) <span class="keyword">then</span> t=a</span><br><span class="line"><span class="keyword">else</span> t=b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Lua 中我们可以将函数作为参数传递给函数，如下实例：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">myprint = <span class="function"><span class="keyword">function</span><span class="params">(param)</span></span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;这是打印函数 - ##&quot;</span>,param,<span class="string">&quot;##&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2,functionPrint)</span></span></span><br><span class="line"> result = num1 + num2 <span class="comment">-- 调用传递的函数参数</span></span><br><span class="line"> functionPrint(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">myprint(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- myprint 函数作为参数传递</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,myprint)</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">upper</span>()</span><br><span class="line">s.<span class="built_in">lower</span>()</span><br><span class="line">s.<span class="built_in">gsub</span>()</span><br><span class="line">s.<span class="built_in">find</span>()</span><br><span class="line">s.<span class="built_in">reverse</span>()</span><br><span class="line">s.<span class="built_in">format</span>()</span><br><span class="line">s.<span class="built_in">char</span>(), s.<span class="built_in">byte</span>()</span><br><span class="line">s.<span class="built_in">len</span>()</span><br><span class="line">s.<span class="built_in">rep</span>()</span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">-2</span>, <span class="number">2</span> <span class="keyword">do</span> <span class="comment">--这里是直接表示i从-2到2的这个闭区间</span></span><br><span class="line">   array[i] = i *<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>0</p><p>迭代器</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(iteratorMaxCount,currentNumber)</span></span></span><br><span class="line">   <span class="keyword">if</span> currentNumber&lt;iteratorMaxCount</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      currentNumber = currentNumber+<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> currentNumber, currentNumber*currentNumber</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,n <span class="keyword">in</span> square,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i,n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>1    1<br>2    4<br>3    9</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">maxn</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>()</span><br></pre></td></tr></table></figure><p>模块</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>=&#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">open</span>=<span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.fun1</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.<span class="built_in">open</span></span><br><span class="line"><span class="built_in">module</span>.fun1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> m=<span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line">m.<span class="built_in">open</span></span><br><span class="line">m.fun1()</span><br></pre></td></tr></table></figure><blockquote><p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua<br>Lua包的加载路径，需要注意默认路径和自行添加的路径：对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。<br>也可以用C为Lua写包；</p></blockquote><p>Lua元表Metatable</p><blockquote><p>setmetatable, getmetatable<br>__index, __newindex<br>rawset<br>加减乘除等操作, __sub<br>__call, __tostring</p></blockquote><p>Lua协程coroutine</p><blockquote><p><a href="https://www.dba.cn/book/lua/LUAJiaoCheng/LUAXieTongChengXuCOROUTINE.html">Lua 协同程序(coroutine) - Lua中文手册 (dba.cn)</a></p></blockquote><p><a href="https://blog.csdn.net/qq_43594278/article/details/116018869">(81条消息) 超级详细的Lua语言的基础教程_G东当的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/126578836">Lua脚本语言的使用笔记 - 知乎 (zhihu.com)</a></p><p>Lua中的冒号、点这些的含义：<a href="https://blog.csdn.net/wangbin_jxust/article/details/12170233">理解lua 语言中的点、冒号与self_lua语言中两个点什么意思_hello_wangbin的博客-CSDN博客</a></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="https://blog.csdn.net/linxinfa/article/details/109668372">(81条消息) 新发的日常小技巧——Sublime插件安装教程（例：lua开发环境插件安装）_林新发的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/yanzi-meng/p/9557379.html">sublime的lua插件 - yanzi_meng - 博客园 (cnblogs.com)</a></p><p><a href="https://www.open-open.com/news/view/26d731">20 个强大的 Sublime Text 插件 - Sublime Text - 软件编程 - 深度开源 (open-open.com)</a></p><p><a href="https://blog.csdn.net/u013052238/article/details/79740112">(81条消息) sublime Text3：安装相关Lua提示插件_断天涯zzz的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_38533963/article/details/120266107">(81条消息) 用sublime，优雅的写lua_sublime 写lua_菜鸟乎的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cheerupforyou/p/6576861.html">华丽的使用sublime写lua~ sublime lua相关必装插件推荐~~ - MorePower - 博客园 (cnblogs.com)</a></p><h1 id="XLua"><a href="#XLua" class="headerlink" title="XLua"></a>XLua</h1><p><a href="https://tencent.github.io/xLua/public/v1/guide/index.html">介绍 — XLua (tencent.github.io)</a></p><p><a href="https://github.com/Tencent/xLua">Tencent&#x2F;xLua: xLua is a lua programming solution for C# ( Unity, .Net, Mono) , it supports android, ios, windows, linux, osx, etc. (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/393839438">【XLua】学习笔记 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/159054613">Xlua基础(三) Lua调用C# - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/38322991">Unity热更新框架之xLua - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/BDFFZI/p/17152877.html">Xlua的热更新</a></p><p>实战（俄罗斯方块）：</p><p><a href="https://zhuanlan.zhihu.com/p/59358144">lua的俄罗斯方块</a></p><p><a href="https://juejin.cn/post/7069795082135666724">学习 2 天 lua 后开发俄罗斯方块的一些心得（耗时3天） - 掘金</a></p><p><a href="https://shenjun-coder.github.io/LuaBook/%E7%AC%AC%E4%B8%89%E7%AB%A0%20XLua%E6%95%99%E7%A8%8B/3_15%20Lua%E8%B0%83%E7%94%A8CS.html">3.15 Lua调用CS · GitBook</a></p><p><a href="https://zhuanlan.zhihu.com/p/408353700">官方案例教程篇</a></p><p><a href="https://zhuanlan.zhihu.com/p/642523728">Lua和C的集成</a></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.youtube.com/watch?v=Gz5W0Bo0fVc&list=PL0luF_aDUOooJvtTl7lwlR9xyAyWNZ41p&index=1">链接</a></p><blockquote><p>相关的代码实验在LuaTutorial项目里；</p></blockquote><p>只是Lua的一个插件，可以实现和c#的交互，也可以实现游戏的热更新。这样游戏出现新的功能更新到时候，用户只需要下载小部分内容，就能实现更新内容的体验。<br>lua不需要编译，且跨平台。c#编译成dll，然后打包成安装包。</p><p>导入xlua插件进入unity工程</p><blockquote><p>直接把assets里的内容放到工程里就行；（把XLua的都放进去也行）<br>Xlua和Plugins两个文件夹<br>学习路径：Xlua教程→Examples→<br>空间组织：Scenes文件夹，Xlua的两个文件夹(Plugins, XLua)</p></blockquote><p>Lua输出的会在控制台前面有一个LUA的标识；<br>因为在c#里没办法识别lua的，只会识别文本类型的；所以文件命名需要在.lua后面加上.txt<br>此外，要确定lua文件是放在Resources的文件夹下面的，这样内置的Loader才会找到；</p><p>c#里自定义Loader加载指定目录下的lua脚本：</p><blockquote><p>文件需要放到StreamingAssets里，而这个文件夹需要在根目录下，这样子c#里就可以找得到；</p></blockquote><h3 id="c-里访问Lua的table"><a href="#c-里访问Lua的table" class="headerlink" title="c#里访问Lua的table"></a>c#里访问Lua的table</h3><ul><li><p>通过class访问的话，是值拷贝，修改不会影响lua里的数值，比较耗费性能；</p></li><li><p>映射到一个接口上，此时要注意添加[]，不然会报错为invalidCastException。此外，接口上对于table属性的修改，是引用修改，会同步到table上</p><ul><li>此外，如果报错说&#x3D;&#x3D;LuaException: attemp to perform arithmetric on a table value(local ‘a’)&#x3D;&#x3D; ➡️ 此时是因为在lua里第一个参数指向的是本身，所以在lua里第一个参数应该是arg&#x2F;self这些表示第一个参数, 而c#调用里参数的就是实例化对象p</li><li>也可以不设置第一个参数，但需要用冒号来进行定义</li><li>需要重新generate code，如果还是不能运行，考虑兼容性问题，或者是需要在Xlua配置文档里学习并进行配置</li></ul></li><li><p>轻量级映射：映射到C#的Dictionary或List内</p><ul><li>dictionary只能映射有键值的；</li><li>list只能映射没有键值的数值，c#会根据定义的类型来决定获取到哪些映射值</li><li></li></ul></li></ul><p>如果文件出现了乱码问题，可以把代码文件，在记事本里另存为UTF8的格式。</p><p>如果报错说&#x3D;&#x3D;InvalidOperationException: try to dispose a LuaEnv with C# callback!&#x3D;&#x3D;，是因为c#有变量引用了lua的内容，但lua已经设置了释放，这就产生了冲突，无法释放。</p><p>在使用Action&lt;int,int&gt;的时候，报错说&#x3D;&#x3D;InvalidCastException: This type must add to CSharpCallLua: System.Action&lt;int, int&gt;&#x3D;&#x3D;，一种方式是进行配置，另一种是自己定义一个委托。因为在lua里面函数是function类型的，而c#里面函数可以说是delegate类型的。</p><ul><li>但还是说InvalidCastException: This type must add to CSharpCallLua，也就说还是得添加[CSharpCallLua]，然后需要先clear generate code, 再generate code</li></ul><h3 id="Lua访问C-里的内容"><a href="#Lua访问C-里的内容" class="headerlink" title="Lua访问C#里的内容"></a>Lua访问C#里的内容</h3><p>&#x3D;&#x3D;new c#对象&#x3D;&#x3D;</p><p>在C#这样new一个对象：<br>var newGameObj &#x3D; new UnityEngine.GameObject(“new gameobject”);</p><p>对应到Lua是这样：<br>local newGameObj &#x3D; CS.UnityEngine.GameObject(“new gameobject”)<br>直接CS.命名空间.类名，就可以</p><p>基本类似，除了：<br><strong>lua里头没有new关键字；</strong><br><strong>所有C#相关的都放到CS下，包括构造函数，静态成员属性、方法；</strong><br><strong>如果有多个构造函数呢？放心，xlua支持重载</strong>，比如你要调用GameObject的带一个string参数的构造函数，这么写：</p><p>local newGameObj2 &#x3D; CS.UnityEngine.GameObject(‘helloworld’)</p><p>&#x3D;&#x3D;访问C#静态属性，方法&#x3D;&#x3D;</p><p>读静态属性</p><p>CS.UnityEngine.Time.deltaTime</p><p>写静态属性</p><p>CS.UnityEngine.Time.timeScale &#x3D; 0.5</p><p>调用静态方法</p><p>CS.UnityEngine.GameObject.Find(‘helloworld’)</p><p>小技巧：如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能：</p><p>local GameObject &#x3D; CS.UnityEngine.GameObject</p><p>GameObject.Find(‘helloworld’)</p><p>&#x3D;&#x3D;访问C#成员属性，方法&#x3D;&#x3D;</p><p>读成员属性<br>testobj.DMF</p><p>写成员属性<br>testobj.DMF &#x3D; 1024</p><p>调用成员方法<br>注意：调用成员方法，<strong>第一个参数需要传该对象，建议用冒号语法糖</strong>，如下：testobj:DMFunc()</p><p>&#x3D;&#x3D;访问父类属性，方法&#x3D;&#x3D;</p><p>xlua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类实例）访问基类的成员属性，成员方法。</p><p>&#x3D;&#x3D;参数的输入输出属性（out，ref）&#x3D;&#x3D;</p><p>Lua调用测的参数处理规则：C#的普通参数算一个输入形参，ref修饰的算一个输入形参</p><p>out修饰的不算，然后从左往右对应lua 调用测的实参列表；</p><p>Lua调用测的返回值处理规则：C#函数的返回值（如果有的话）算一个返回值，out算一个返回值，ref算一个返回值，然后从左往右对应lua的多返回值。</p><p>&#x3D;&#x3D;重载方法&#x3D;&#x3D;</p><p>直接通过不同的参数类型进行重载函数的访问，例如：</p><p>testobj:TestFunc(100)</p><p>testobj:TestFunc(‘hello’)</p><p>将分别访问整数参数的TestFunc和字符串参数的TestFunc。</p><p>注意：xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，上面的例子中TestFunc如果有这些重载参数，第一行将无法区分开来，只能调用到其中一个（生成代码</p><p>中排前面的那个）。</p><p>&#x3D;&#x3D;操作符&#x3D;&#x3D;</p><p>支持的操作符有：+，-，*，&#x2F;，&#x3D;&#x3D;，一元 -，&lt;，&lt;&#x3D;， %，[]</p><p>&#x3D;&#x3D;参数带默认值的方法&#x3D;&#x3D;</p><p>和C#调用有默认值参数的函数一样，如果所给的实参少于形参，则会用默认值补上。</p><p>&#x3D;&#x3D;可变参数方法&#x3D;&#x3D;</p><p>对于C#的如下方法：void VariableParamsFunc(int a, params string[] strs)</p><p>可以在lua里头这样调用：testobj:VariableParamsFunc(5, ‘hello’, ‘john’)</p><p>&#x3D;&#x3D;使用Extension methods&#x3D;&#x3D;</p><p>在C#里定义了，lua里就能直接使用。</p><p>&#x3D;&#x3D;泛化（模版）方法&#x3D;&#x3D;</p><p><strong>不直接支持，可以通过Extension methods功能进行封装后调用。</strong></p><p>&#x3D;&#x3D;枚举类型&#x3D;&#x3D;</p><p>枚举值就像枚举类型下的静态属性一样。</p><p>testobj:EnumTestFunc(CS.Tutorial.TestEnum.E1)</p><p>上面的EnumTestFunc函数参数是Tutorial.TestEnum类型的</p><p>另外，如果枚举类加入到生成代码<strong>（就是在c#的枚举之前，添加[LuaCallCSharp]）</strong>的话，枚举类将支持__CastFrom方法，可以实现从一个整数或者字符串到枚举值的转换，例如：</p><p>CS.Tutorial.TestEnum.__CastFrom(1)</p><p>CS.Tutorial.TestEnum.__CastFrom(‘E1’)</p><p>&#x3D;&#x3D;delegate使用（调用，+，-）&#x3D;&#x3D;</p><p>C#的delegate调用：和调用普通lua函数一样</p><p>+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C#delegate或者是lua函数。</p><p>-操作符：和+相反，把一个delegate从调用链中移除。</p><p>Ps：delegate属性可以用一个luafunction来赋值。</p><p><code>&lt;mark&gt;</code>event <code>&lt;/mark&gt;</code></p><p>比如testobj里头有个事件定义是这样：public event Action TestEvent;</p><p>增加事件回调 testobj:TestEvent(‘+’, lua_event_callback)</p><p>移除事件回调 testobj:TestEvent(‘-‘, lua_event_callback)</p><p><code>&lt;mark&gt;</code>C#复杂类型和table的自动转换 <code>&lt;/mark&gt;</code></p><p>对于一个有无参构造函数的C#复杂类型，在lua侧可以直接用一个table来代替，该table对应复杂类型的public字段有相应字段即可，支持函数参数传递，属性赋值等，例如：</p><p>C#下B结构体（class也支持）定义如下：</p><p>public struct A{ public int a;}</p><p>public struct B{ public A b; public double c;}</p><p>某个类有成员函数如下：void Foo(B b)</p><p>在lua可以这么调用：</p><p>obj:Foo({b &#x3D; {a &#x3D; 100}, c &#x3D; 200})</p><p>获取类型（相当于C#的typeof）</p><p>比如要获取UnityEngine.ParticleSystem类的Type信息，可以这样 typeof(CS.UnityEngine.ParticleSystem)。</p><p><code>&lt;mark&gt;</code>“强”转 <code>&lt;/mark&gt;</code></p><p>lua没类型，所以不会有强类型语言的“强转”，但有个有点像的东西：告诉xlua要用指定的生成代码去调用一个对象，这在什么情况下能用到呢？有的时候第三方库对外暴露的是一个interface或者抽象类，实现类是隐藏的，这样我们无法对实现类进行代码生成。该实现类将会被xlua识别为未生成代码而用反射来访问，如果这个调用是很频繁的话还是很影响性能的，这时我们就可以把这个interface或者抽象类加到生成代码，然后指定用该生成代码来访问：</p><p>cast(calc, typeof(CS.Tutorial.Calc))</p><p>上面就是指定用CS.Tutorial.Calc的生成代码来访问calc对象。</p><p>&#x3D;&#x3D;GetComponent()&#x3D;&#x3D;<br><a href="https://blog.csdn.net/gouki04/article/details/84784795">xLua下调用GetComponent时返回值不是nil的坑_xlua trygetcomponet-CSDN博客</a><br><a href="https://www.cnblogs.com/ProjectDeveloping/p/10765496.html">XLua 调用 unity 中获取组件的方法 - OldWu - 博客园 (cnblogs.com)</a></p><h3 id="热更新流程"><a href="#热更新流程" class="headerlink" title="热更新流程"></a>热更新流程</h3><p>写的lua代码是关联在AssetBundle上的，然后打包一起更新资源和逻辑到服务器上的项目中。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p><a href="https://blog.csdn.net/ddd2213sss/article/details/126403982">VSCode 如何将 .lua.txt 后缀文件识别为 lua_lua txt后缀-CSDN博客</a></p><h2 id="协程的调整"><a href="#协程的调整" class="headerlink" title="协程的调整"></a>协程的调整</h2><p>参考对ReloadMap.cs的改写</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> _waitSecond = <span class="literal">nil</span>; </span><br><span class="line">_waitSecond = <span class="number">0.3</span>; </span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>(UnityEngine.WaitForSeconds(_waitSecond));</span><br></pre></td></tr></table></figure><p>相当于c#里的下面三句话：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">WaitForSeconds _wait; </span><br><span class="line">_wait = <span class="keyword">new</span> WaitForSeconds(<span class="number">.3</span>f); </span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> _wait;</span><br></pre></td></tr></table></figure><h2 id="数据类型的变换"><a href="#数据类型的变换" class="headerlink" title="数据类型的变换"></a>数据类型的变换</h2><p>ua脚本语言不像C语言一样，整型除以整型结果为整型。lua得出的结果是浮点型，有时会用到整型，<a href="https://blog.csdn.net/FightIngWork/article/details/89281084">所以必须进行取整</a>。</p><blockquote><p>直接用lua math库函数<br>math.floor(s）输入参数为浮点型，整型都可</p></blockquote><h2 id="委托、事件"><a href="#委托、事件" class="headerlink" title="委托、事件"></a>委托、事件</h2><p><a href="https://blog.csdn.net/boyZhenGui/article/details/120956981">【Unity知识点】通俗解释delegate，事件event，Action，Func和UnityAction，UnityEvent_unity delegate-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_46044366/article/details/122806863">Unity 事件番外篇：UnityEvent-CSDN博客</a></p><p>XLua的API文档</p><p><a href="https://zhuanlan.zhihu.com/p/408353700">https://zhuanlan.zhihu.com/p/408353700</a></p><p><a href="https://www.jianshu.com/p/118d6c421549">Lua实现事件触发机制 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/weixin_41995872/article/details/97806978">https://blog.csdn.net/weixin_41995872/article/details/97806978</a></p><p><a href="https://blog.csdn.net/yiluxiangbei000/article/details/118723955">使用Lua语言实现简单的事件系统_lua语言互斥实现-CSDN博客</a></p><p>委托delegate</p><blockquote><p>可以被赋值，注册和注销, 多播委托+&#x3D; -&#x3D;. ?的使用表示非空则执行<br>《C#图解教程》<br>委托：持有一个或多个方法，以及一系列预定义操作的，用户定义的类型</p></blockquote><p>事件event</p><blockquote><p>对委托的一个限定，不需要被赋值，也不能被赋值，可以注册和注销方法。也可以注册和注销委托</p></blockquote><p>Action<br>Action和Func可以理解为系统定义好的带泛型的delegate， Action无返回值</p><p>Func<br>Action和Func可以理解为系统定义好的带泛型的delegate, Func有无返回值</p><p>UnityAction<br>Unity对C#中Action的再次封装, 更适合在Unity中使用的一种泛型委托. UnityAction对象可以用于Unity内的.AddListener()</p><p>UnityEvent</p><p>可以在面板中添加监听事件，也可以在代码中添加监听事件或UnityAction, 且这两个模式不会互通</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action OnUpdated = <span class="built_in">delegate</span> &#123; &#125;;</span><br><span class="line">_map.OnUpdated += () =&gt; &#123; _zoomSlider.<span class="keyword">value</span> = _map.Zoom; &#125;;</span><br></pre></td></tr></table></figure><p>这一句转换不过来，解决(<a href="https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/XLua_Tutorial_EN.md">参考链接</a>)：(注意是单引号）</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">_map:OnUpdated(<span class="string">&#x27;+&#x27;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> _zoomSlider.value = _map.Zoom; <span class="keyword">end</span>);</span><br></pre></td></tr></table></figure><p>报错：<br>This type must add to CSharpCallLua：typeof(UnityEngine.Events.UnityAction <code>&lt;float&gt;</code>), stack:……（后面还提示了其他路径，但最后查找修改的文件路径主要还是 <code>ExampleConfig.cs, ExampleGenConfig.cs, MessageBox.cs, </code><br>处理：</p><ol><li><a href="https://blog.csdn.net/X_King_Q/article/details/119376546%EF%BC%8C%E5%8F%82%E8%80%83%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%94%A8UnityAction%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9F%A5%E6%89%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%9D%A1">https://blog.csdn.net/X_King_Q/article/details/119376546，参考这个链接，用UnityAction关键词查找解决方案，添加一条</a> <code>typeof(UnityEngine.Events.UnityAction&lt;float&gt;),</code>;</li><li><a href="https://github.com/Tencent/xLua/issues/24%EF%BC%8C%E5%8F%82%E8%80%83%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B8%85%E9%99%A4%E5%B9%B6%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88Clear">https://github.com/Tencent/xLua/issues/24，参考这个链接，给项目清除并重新生成的代码（Clear</a> generate code, generate code)</li><li>经验：中文网站上查查，实现不了就转Google, 有些教程就是错误的，在那里误导我；</li></ol><p>如果报错提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LuaException: c# exception:Non-static method requires a target.,stack:  at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0004c] in &lt;695d1cc93cca45069c528c15c9fdd749&gt;:0 </span><br><span class="line">  at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] in &lt;695d1cc93cca45069c528c15c9fdd749&gt;:0 </span><br><span class="line">  at XLua.OverloadMethodWrap.Call (System.IntPtr L) [0x001ab] in E:\Internship\mapboxText\Assets\Retinar\XLua\Src\MethodWarpsCache.cs:242 </span><br><span class="line">  at XLua.MethodWrap.Call (System.IntPtr L) [0x00029] in E:\Internship\mapboxText\Assets\Retinar\XLua\Src\MethodWarpsCache.cs:297 </span><br><span class="line">stack traceback:</span><br><span class="line">[C]: in field &#x27;GetUrl&#x27;</span><br><span class="line">[string &quot;MapOperation.lua&quot;]:84: in function &lt;[string &quot;MapOperation.lua&quot;]:76&gt;</span><br></pre></td></tr></table></figure><p>一个是：LuaException: c# exception:Non-static method requires a target.，然后仔细看到最后，提示了[C]: in field ‘GetUrl’[string “MapOperation.lua”]:84: in function &lt;[string “MapOperation.lua”]:76&gt;，最后发现是_resource.GetUrl()错了，应该是_resource:GetUrl()</p><h3 id="lua调用c-里的泛型"><a href="#lua调用c-里的泛型" class="headerlink" title="lua调用c#里的泛型"></a>lua调用c#里的泛型</h3><p>有一句话转不过来(&#x3D;&#x3D;具体细节可以看问题梳理图示.pptx&#x3D;&#x3D;)，<br>c#:</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">_resource = <span class="keyword">new</span> ForwardGeocodeResource(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">MapboxAccess.Instance.Geocoder.Geocode(_resource, HandleGeocoderResponse);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IAsyncRequest <span class="title">Geocode</span>&lt;<span class="title">T</span>&gt;(<span class="params">GeocodeResource&lt;T&gt; geocode, Action&lt;ReverseGeocodeResponse&gt; callback</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IAsyncRequest <span class="title">Geocode</span>(<span class="params"><span class="built_in">string</span> geocodeUrl, Action&lt;ReverseGeocodeResponse&gt; callback</span>)</span></span><br></pre></td></tr></table></figure><p>Lua:</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">_resource = Geocoding.ForwardGeocodeResource(<span class="string">&quot;Nanjing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> geocoder = MapboxAccess.Instance.Geocoder; </span><br><span class="line"></span><br><span class="line">geocoder:Geocode(_resource:GetUrl(), HandleGeocoderResponse);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应该是数据类型不对，但就是不知道怎么要整才算对的<br>我一级级往上，一直到Deserialize这个函数，我的那个就报错了</p><p>&#x3D;&#x3D;解决方法：&#x3D;&#x3D;<br>重写一遍C#里的泛型：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IAsyncRequest <span class="title">Geocode</span>&lt;<span class="title">T</span>&gt;(<span class="params">GeocodeResource&lt;T&gt; geocode, Action&lt;ForwardGeocodeResponse&gt; callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.fileSource.Request(</span><br><span class="line">geocode.GetUrl(),</span><br><span class="line">(Response response) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> str = Encoding.UTF8.GetString(response.Data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Deserialize&lt;ForwardGeocodeResponse&gt;(str);</span><br><span class="line"></span><br><span class="line">callback(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IAsyncRequest <span class="title">Geocode</span>(<span class="params">GeocodeResource&lt;<span class="built_in">string</span>&gt; geocode, Action&lt;ForwardGeocodeResponse&gt; callback</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fileSource.Request(</span><br><span class="line">                geocode.GetUrl(),</span><br><span class="line">                (Response response) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> str = Encoding.UTF8.GetString(response.Data);</span><br><span class="line">                    <span class="keyword">var</span> data = Deserialize&lt;ForwardGeocodeResponse&gt;(str);</span><br><span class="line">                    callback(data);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/read/cv14380732/">简单的重写</a><br><a href="https://zhuanlan.zhihu.com/p/130860627">对c#泛型方法对应的类，添加扩展</a></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><a href="https://blog.csdn.net/qq_42672770/article/details/109669424">未将对象设置到对象实例 Object reference not set to an instance of an object-CSDN博客</a></p><h3 id="不懂的"><a href="#不懂的" class="headerlink" title="不懂的"></a>不懂的</h3><p>c#里添加自定义loader，对于delegate变量的定义；</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    LuaEnv env = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">    env.AddLoader(MyLoader);<span class="comment">//参数为LuaEnv.customLoader loader</span></span><br><span class="line">    <span class="comment">//要求是LuaEnv.customLoader类型的，也就是下面这个类型的byte[]</span></span><br><span class="line">    <span class="comment">//public delegate byte[] CustomLoader(ref string filepath);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">byte</span>[] <span class="title">MyLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filepath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lua入门&quot;&gt;&lt;a href=&quot;#Lua入门&quot; class=&quot;headerlink&quot; title=&quot;Lua入门&quot;&gt;&lt;/a&gt;Lua入门&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语</summary>
      
    
    
    
    <category term="AR开发" scheme="https://youxt-njnu.github.io/categories/AR%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="软件端AR" scheme="https://youxt-njnu.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%AB%AFAR/"/>
    
    <category term="Lua" scheme="https://youxt-njnu.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>源码学习技巧</title>
    <link href="https://youxt-njnu.github.io/2024/02/13/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://youxt-njnu.github.io/2024/02/13/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-13T01:03:16.000Z</published>
    <updated>2024-02-20T09:57:08.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://zhuangbiaowei.gitbook.io/learn-with-open-source/">https://zhuangbiaowei.gitbook.io/learn-with-open-source/</a><br><a href="https://boholder.github.io/blogs/learn-from-source-code/">https://boholder.github.io/blogs/learn-from-source-code/</a></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="如何选择开源项目"><a href="#如何选择开源项目" class="headerlink" title="如何选择开源项目"></a>如何选择开源项目</h2><p>一个领域的能力体系：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">1(创造能力) --&gt; 2(理解能力)</span><br><span class="line">1 --&gt; 3(逻辑能力)</span><br><span class="line">2 --&gt; 4(基础知识)</span><br><span class="line">3 --&gt; 4</span><br><span class="line">2 --&gt; 5(编程技能)</span><br><span class="line">3 --&gt; 5</span><br><span class="line">2 --&gt; 领域知识</span><br><span class="line">3 --&gt; 领域知识</span><br></pre></td></tr></table></figure><blockquote><p>基础知识：包括计算机、数学、算法、逻辑等，通过学习书本教材；</p><p>编程技能：学习具体的语言；</p><p>领域知识：和工作方向有关，如企业级应用的开发，需要了解管理制度、财务、成本、仓储等知识；</p></blockquote><p>提高代码质量的书推荐：</p><blockquote><p>Clean Code</p><p>Design Patterns: Elements of Reusable Object-Oriented Software</p><p>Clean Architecture: A Craftsman’s Guide to Software Structure and Design</p><p>How to Read a Book: The Classic Guide to Intelligent Reading</p><p>Head First设计模式</p></blockquote><p>寻找开源项目，可以查看该语言对应的Awesome List；</p><p>选择和自身当前的编程技能和知识水平相当的项目；</p><p>先读相对较小的项目，接着读更大的项目；</p><p>如果目前不能理解某些特定的代码片段，意味着存在知识缺口（Knowledge Gap），可以试着读一些相关的书、论文或其他文档，更有信心的时候再回来接着读代码；</p><p>一个模式：读（代码、书、论文），写，更多的读，更多的写。</p><h2 id="理解源代码"><a href="#理解源代码" class="headerlink" title="理解源代码"></a>理解源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">熟悉功能 --&gt; 静态理解 --&gt; 动态理解 --&gt; 主线和支线 --&gt; 外围代码 --&gt; 知其所以然</span><br></pre></td></tr></table></figure><blockquote><p>寻找文档,熟悉功能,先玩一遍；</p><p>静态理解项目：目录结构、包名和文件名、类名函数名和变量名、注释和Readme、UML图、外部文档</p><p>动态理解项目：输出日志、设置断点和单步跟踪、抛出异常、修改和破坏性尝试</p><p>主线和支线：寻找入口、跟踪关键流程、寻找挂接点</p><p>外围代码：必须存在的外围功能、demo和Example、单元测试</p></blockquote><p>UML的使用：</p><blockquote><p>UML系统开发中的三个重要模型：</p><ul><li>功能模型（从用户角度，展示系统的功能，包括用例图</li><li>对象模型（采用对象、属性、操作、关联登，展示系统的结构和基础，包括类图</li><li>动态模型（展示系统内部的行为，包括序列图、活动图、状态图</li></ul><p>建议：</p><ul><li>先建立对象的静态模型（画类图）</li><li>在UML规范之外可以添加一些辅助自己记忆的符号</li><li>其次，在动态理解的过程中，可以对关键的执行路径画出时序图</li><li>对于非面向对象的项目，可以参照类图和组件图的模式，画出模块图</li></ul></blockquote><p>日志(log, logger, logging)：</p><blockquote><p>通过修改源代码，增加更多的日志输出，帮助理解；</p><p>多线程程序输出的日志，会存在输出内容次序不一致的问题，需小心；</p></blockquote><p>异常：</p><blockquote><p>多种语言都支持异常处理和手动抛出异常；</p><p>在特定的位置，把整个调用序列打印出来，可以快速找到整个项目从何处开始，如何一层层调用，最终到达设置抛出异常的位置；</p></blockquote><p>单元测试：</p><blockquote><p>软件开发中最具有其他性的是“测试驱动开发（TDD）”，最易误导开发者的是“设计模式（DP）”；</p><p>完整而全面的单元测试代码，说明代码的质量也不赖；</p><p>好的单元测试，会测试关键逻辑与核心算法，差的单元测试会侧get&#x2F;set这种无关紧要代码；</p><p>先对项目有所了解后，阅读单元测试，以防现实琐碎细节而迷失方向；</p></blockquote><p>设计模式：</p><blockquote><p>具备一定的编程语言与设计模式的知识和经验，有助于阅读大项目；</p><p>了解有关源码组织和编程范式的最佳实践；</p></blockquote><p>开源软件的”知其所以然”</p><blockquote><ul><li>架构决策：理解项目为什么像这样的做架构设计</li><li>代码风格</li><li>领域知识</li><li>编程技巧</li></ul><p>如何搞清楚这些所以然：</p><ul><li>如果我来做一个，如何做？</li><li>如果对这个项目做减法，可以去掉哪些模块和代码？真的可以去掉吗？</li><li>通过阅读单元测试，理解开发者的设计思路</li><li>做一些破坏或修改，来理解项目中的那些做法</li><li>可以通过思考后，在开源社区发起讨论、向作者提问，阅读一些文档和书籍；</li></ul></blockquote><p>为开源项目做共享</p><blockquote><p>提Bug和建议；</p><p>帮助完善开发文档；</p><p>提交代码（功能代码和测试代码）；</p><p>周边代码（demo&#x2F;扩展&#x2F;子项目）；</p><p>外部宣传；</p><p>写一篇代码点评，记录代码中好的和不好的部分，以及学到的内容；</p></blockquote><p>编辑器的选择：</p><blockquote><p>熟练使用的，拥有快速检索关键字和变量名的能力；</p><p>熟练查找函数的引用和定义；</p><p>试着学习仅使用键盘操作编辑器；</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资源&quot;&gt;&lt;a href=&quot;#参考资源&quot; class=&quot;headerlink&quot; title=&quot;参考资源&quot;&gt;&lt;/a&gt;参考资源&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuangbiaowei.gitbook.io/learn-with-open-sour</summary>
      
    
    
    
    <category term="周边扩展" scheme="https://youxt-njnu.github.io/categories/%E5%91%A8%E8%BE%B9%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="源码" scheme="https://youxt-njnu.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Mapbox SDK for Unity | 官方案例Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/02/12/MSU2/"/>
    <id>https://youxt-njnu.github.io/2024/02/12/MSU2/</id>
    <published>2024-02-12T12:45:16.000Z</published>
    <updated>2024-02-12T12:47:05.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zoomable-map"><a href="#Zoomable-map" class="headerlink" title="Zoomable map"></a>Zoomable map</h1><p><code>&lt;b&gt;</code>Worldwide Dynamic Zoom &amp; Panning Support <code>&lt;/b&gt;</code><br>它里面用了SpawnOnMap的脚本，来在地图上自定义符号。<br>This example is a starting point for creating a traditional web-based zoomable map. Go anywhere in the world and check out Mapbox’s high-quality satellite imagery. It also uses the SpawnOnMap script to instantiate custom markers on the map at specified locations.</p><h1 id="Iconic-buildings"><a href="#Iconic-buildings" class="headerlink" title="Iconic buildings"></a>Iconic buildings</h1><p>涉及到对于高精度的模型，怎么放置到地图上；</p><p><code>&lt;mark&gt;</code>replace features <code>&lt;/mark&gt;</code>的demo是这个的具体操作，Globe的demo里也有放置了自定义标签在地图上的操作；</p><p>在abstract map里也可以挂一些modifier，然后设置modifier里的参数；</p><p>通过这个，可以实现自定义的高精度模型摆放到固定位置，然后点击图标导航到对应的位置；<br><img src="https://s2.loli.net/2023/11/03/7leL9EIJFfqsoBQ.png"></p><h1 id="POI-placement"><a href="#POI-placement" class="headerlink" title="POI placement"></a>POI placement</h1><p>这个里面就是给了POI，然后也能根据POI实现相应的交互；</p><p>有一个教程：<a href="https://blog.mapbox.com/build-ar-experiences-with-places-data-48a4856c482f">https://blog.mapbox.com/build-ar-experiences-with-places-data-48a4856c482f</a></p><p>POI点，添加标注，有触发交互；</p><p>这些POI点都是真实地理位置的，可选择的，可搜索的；可以通过名称、类别、地址等进行搜索，也比较方便；</p><p>有一个简单的添加场景、添加POI标注的教程；</p><h2 id="详细学习"><a href="#详细学习" class="headerlink" title="详细学习"></a>详细学习</h2><p>额外知识点：<br><a href="https://blog.csdn.net/keneyr/article/details/114380509">【Unity】对 Center&#x2F;Pivot 和 Global&#x2F;Local 的理解_unity global和local-CSDN博客</a><br><a href="https://www.cnblogs.com/dlyedu/p/7648463.html">Unity中Update，FixedUpdate，LateUpdate的区别 - 南山砍柴 - 博客园 (cnblogs.com)</a><br><a href="https://docs.unity.cn/cn/2019.4/Manual/class-FlareLayer.html">光晕层 (Flare Layer) - Unity 手册</a><br><a href="https://blog.csdn.net/qq_33795300/article/details/131492273">深入了解Unity的QualitySettings类：一份详细的技术指南(三)-CSDN博客</a></p><p>Scene学习：</p><table><thead><tr><th>GameObject</th><th>作用</th><th>组件</th></tr></thead><tbody><tr><td>Main Camera</td><td>相机</td><td>ChangeShadowDistance.cs(<a href="https://docs.unity.cn/cn/2019.4/ScriptReference/QualitySettings.html">QualitySettings - Unity 脚本 API</a>,修改阴影的绘制距离)；<code>&lt;br&gt;</code> CameraMovement.cs(拖拽和缩放地图，以及相机的设置)</td></tr><tr><td>LabelCamera</td><td>专门标签显示</td><td>Culling Mask的设置💡</td></tr></tbody></table><h1 id="AstronautGame"><a href="#AstronautGame" class="headerlink" title="AstronautGame"></a>AstronautGame</h1><p><code>&lt;b&gt;</code>Astronaut Game <code>&lt;/b&gt;</code><br>This is an enhanced version of the “Location-based Game Starting Point.” It features custom styling, procedural vehicle movement based on real road data, and dynamic lighting. Click on the road in the editor to navigate the astronaut character to a point via the Directions API. On a device, this example uses GPS location information to move and rotate the character.</p><p>和导航相关的，有物体的移动；<br>基于<strong>LocationBasedGame</strong>那个预制件，是 <code>&lt;mark&gt;</code>location based game <code>&lt;/mark&gt;</code>那个demo的进阶版；</p><p>这个挺有用的，就是点击屏幕上一个点，宇航员会导航过去，同时光照也可以恰当实现，而且地图也会自动放缩，保证人始终在屏幕的中心区域；<br>但导航的一个问题就是会走到楼里面，会穿越交通；<br>车辆也比较假；特别是移动的时候；</p><h2 id="map设计"><a href="#map设计" class="headerlink" title="map设计"></a>map设计</h2><p>此外这个很支持自定义，包括自定义图层和风格的加入，但是需要构建一个密钥，因为需要访问到我账户里的所有风格url；</p><p>对地理要素的显示的筛选也很细致了；<br><img src="https://s2.loli.net/2023/11/03/vu5mz6GfLYCQ297.png"></p><p>涉及到自定义风格这种，给了两个案例视频：<br><a href="https://www.youtube.com/watch?v=RhG1kfDBhgM">https://www.youtube.com/watch?v=RhG1kfDBhgM</a><br><a href="https://www.youtube.com/watch?v=-RMdkG0VL4A">https://www.youtube.com/watch?v=-RMdkG0VL4A</a></p><p><a href="https://www.w3cschool.cn/csharp/csharp-namespaces.html">c#的namespace和using</a><br><a href="https://blog.csdn.net/yangyong0717/article/details/71512251">Unity3D中[SerializeField]特性的使用</a><br><img src="https://s2.loli.net/2023/09/04/kprgie4NDudyM6S.png"></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="LocaitonProvider"><a href="#LocaitonProvider" class="headerlink" title="LocaitonProvider"></a>LocaitonProvider</h2><p>LocationProviderFactory.cs<br>DeviceLocationProvider.cs<br>EditorLocationProvider.cs<br>LocationArrayEditorLocationProvider.cs<br>TransformLocationProvider.cs<br>DeviceLocationProviderAndroidNative.cs</p><h2 id="TrafficAnimator"><a href="#TrafficAnimator" class="headerlink" title="TrafficAnimator"></a>TrafficAnimator</h2><p>调整交通流的速度</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>ImmediatePositionWithLocationProvider.cs<br>RotateWithLocationProvider.cs</p><h2 id="MapboxAstronaut"><a href="#MapboxAstronaut" class="headerlink" title="MapboxAstronaut"></a>MapboxAstronaut</h2><h2 id="RaycastPlane"><a href="#RaycastPlane" class="headerlink" title="RaycastPlane"></a>RaycastPlane</h2><h1 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h1><p>对一些API使用的示例：<br>Directions：输入起始点、目的地，给出两者之间的路线；<br>ForwardGeocoder：输入地点的名称，给出地点的GeoJSON数据；<br>LocationProvider：当从device location provider中加载读入的时候，用于debug的工具；<br>RasterTile：输入一个地点名称，返回该地区的风格化的栅格瓦片styled raster，还可以自定义调节地图的层级<br>RemoveZ-Fighting<br>ReverseGeocoder<br>VectorTile</p><h1 id="VoxelMap像素地图"><a href="#VoxelMap像素地图" class="headerlink" title="VoxelMap像素地图"></a>VoxelMap像素地图</h1><p><code>&lt;b&gt;</code>Real World Data, Minecraft-inspired Map <code>&lt;/b&gt;</code></p><p>This Minecraft-inspired example demonstrates a less traditional way to consume Mapbox data for maps or world construction.<br>VoxelTile is responsible for fetching both a styled raster tile and a mapbox.terrain-rgb (global elevation) tile. The styled raster pixels are sampled to determine which voxels to generate, via the VoxelFetcher. This is achieved using a nearest color formula. The elevation tile pixels are sampled to determine where to vertically place the voxels.<br>Zoom: the zoom level at which to request the tiles.<br>Elevation Multiplier: used to exaggerate the real-world height.<br>Voxel Depth Padding: determine how many voxels to spawn below the designated height. This helps fill holes in environments with extreme elevation variations.<br>Tile Width in Voxels: How many voxels to generate across each tile. This will affect the detail of the world. Raster textures are downsampled according to this value.<br>Voxel Batch Count: The number of voxels to spawn at once. Keep this number low to prevent locking the main thread during construction.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Zoomable-map&quot;&gt;&lt;a href=&quot;#Zoomable-map&quot; class=&quot;headerlink&quot; title=&quot;Zoomable map&quot;&gt;&lt;/a&gt;Zoomable map&lt;/h1&gt;&lt;p&gt;&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;Worldwid</summary>
      
    
    
    
    <category term="AR开发" scheme="https://youxt-njnu.github.io/categories/AR%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unity" scheme="https://youxt-njnu.github.io/tags/Unity/"/>
    
    <category term="mapbox" scheme="https://youxt-njnu.github.io/tags/mapbox/"/>
    
    <category term="开源" scheme="https://youxt-njnu.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Mapbox SDK for Unity | 官方案例Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/02/12/MapboxSDKforUnity/"/>
    <id>https://youxt-njnu.github.io/2024/02/12/MapboxSDKforUnity/</id>
    <published>2024-02-12T12:39:16.000Z</published>
    <updated>2024-02-12T12:47:36.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="City-simulator"><a href="#City-simulator" class="headerlink" title="City simulator"></a>City simulator</h1><p>主要是对基础场景的搭建，也包括了基础数据的一些图层的设置；</p><p>在瓦片地图之上，也可以进一步加载建筑数据、POI数据、路网数据、实时交通数据；</p><p><em>location-based game</em>里面涉及到了Player；<br><em>Data explorer</em>的demo是对其的补充和优化；<br><em>Zoomable map</em>的demo实现了基于底图的地点的搜索和缩放；</p><h2 id="city-simulator-x2F-location-based-game"><a href="#city-simulator-x2F-location-based-game" class="headerlink" title="city simulator&#x2F;location-based game"></a>city simulator&#x2F;location-based game</h2><p>界面</p><ul><li>Camera：Position，侧俯视地面</li><li>Light：Position，这两个部分都需要好好学习一下</li><li>叠加的数据源来自于MAP LAYERS里的Data Source，可以自定义</li></ul><p>脚本</p><ul><li>InitializeMapWithLocationProvider</li><li>ImmediatePositionWithLocationProvider<br>初始化mapbox的底图、player的位置、</li></ul><blockquote><p>在EditorLocationArrayProvider中定义物体的初始位置，也就是第一个点；<br>但无法实现绕着路走</p></blockquote><h2 id="Data-explorer"><a href="#Data-explorer" class="headerlink" title="Data explorer"></a>Data explorer</h2><p><strong>界面</strong></p><ul><li>为什么要叠加两个摄像机，以及Camera的设置</li><li>光照的location改变没啥影响？？？？</li></ul><p><strong>modifier</strong></p><p>modifier都继承自ScriptableObjects</p><p>GameObject Modifiers：</p><blockquote><p>Game object modifiers ran after the mesh modifiers and game object creation.Their main purpose is to work on game object and decorate&#x2F;improve them in their own ways.They ran for each game object individually.<br>It’s possible to do lots of different things with GameObject Modifiers.A simple example would be <strong>MaterialModifier, which simply sets random materials to gameobject and submeshes</strong>.A more complicated example would be <strong>SpawnInside Modifier which instantiates prefabs in a polygon, like trees in a park</strong>.<br>Any operation, you want to perform on generated entity, that would <strong>require a game object is a good candidate for game object modifiers</strong>. For example, things like adding a collider or animation would require a gameobject hence cannot be done in mesh modifier .<br>Game object modifiers is the suggested way of <strong>customizing generated game object</strong> and we expect developers to fully utilize this by creating their own custom game object modifiers.</p></blockquote><blockquote><p>Behavior modifiers are <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html"><code>ScriptableObjects</code></a> that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects.</p></blockquote><p>一个相关的问题：<a href="https://www.appsloveworld.com/gamedev/100/how-to-find-intersections-using-mapbox-unity-sdk?expand_article=1">https://www.appsloveworld.com/gamedev/100/how-to-find-intersections-using-mapbox-unity-sdk?expand_article=1</a><br>一个视频教程：<a href="https://youtu.be/cy49zMBZvhg?si=IDRboEIbW-wRPmjY">https://youtu.be/cy49zMBZvhg?si=IDRboEIbW-wRPmjY</a><br>一个挺好的文字版教程：<a href="https://blog.csdn.net/qq_46044366/article/details/124310241">Unity进阶：ScriptableObject使用指南-CSDN博客</a></p><p><strong>CreateAssetMenu</strong></p><blockquote><p>类上面添加一行<br>[CreateAssetMenu(fileName &#x3D; “Bullet”, menuName &#x3D; “New Bullet”, order &#x3D; 1)]<br>作用在 Assets 文件夹下，鼠标右键，菜单栏中添加一个按钮项，菜单名为 menuName，并执行生成名为 fileName 的脚本，order 为按钮显示顺序<br><a href="https://blog.csdn.net/lizhenxiqnmlgb/article/details/95603822">https://blog.csdn.net/lizhenxiqnmlgb/article/details/95603822</a></p></blockquote><p><strong>map layers</strong></p><p>mapbox.3d-buildings,mapbox.mapbox-streets-v7,mapbox.mapbox-traffic-v1,mapbox.mapbox-terrain-v2<br>地址：<a href="https://studio.mapbox.com/tilesets/">https://studio.mapbox.com/tilesets/</a><br>涉及图层：</p><blockquote><p>v7的已经找不着了，现在是v8的；<br>其他的也有更新，然后可以在mabox studio的tileset里，或者是mapbox预设的style里找到；但第一个3d_buildings感觉是mapbox官方账号自己定义的一个Tileset<br>下面的是以POI Label为例，v8里面的filterrank为1的显示为紫色的label<br><img src="https://s2.loli.net/2023/10/09/mNjZlvcTKGfg5Ww.png"><br>POI Label里还有一个prefab modifier，是scriptableobject的自定义子类，实现对label的批量设置；通过编写PrefabModifier，然后里面有三个变量。构建这个的实例是通过右键菜单里找自己定义的路径来实现的<br><img src="https://s2.loli.net/2023/10/09/1ITDPpornREuX35.png" alt="202310091154803.png"><br>PrefabModifier实现了对Prefab的初始化到清除的生命流程；<br>LabelPrefab里面<br><img src="https://s2.loli.net/2023/10/11/ByH5LGlu1TkzeFd.png"></p></blockquote><p><strong>Pois</strong><br><img src="https://s2.loli.net/2023/10/11/npbivGUcyPQXJqo.png" alt="img"><br>PoiDemo3dPoiModifier(Prefab Modifier): 还是继承自Prefab Modifier，里面的Prefab是下面这样的：<br><img src="https://s2.loli.net/2023/10/11/pm4WBKrvJ2RMoLu.png"><br>FeatureBehaviourModifier(Feature Behaviour Modifier): 继承自Feature Behaviour Modifier<br><img src="https://s2.loli.net/2023/10/11/6depCAaUzYlI3Qo.png"></p><p><strong>主要功能体现</strong></p><p><img src="https://s2.loli.net/2023/10/13/XtVmPIbZWaQh8rS.png"></p><p><a href="https://zhuanlan.zhihu.com/p/102057291">UGUI（三）- Graphic Raycaster - 知乎 (zhihu.com)</a><br><a href="https://blog.csdn.net/xinzhilinger/article/details/111186083">Unity 几种排版方式：Layout Group_unity layout group-CSDN博客</a><br><img src="https://s2.loli.net/2023/10/15/PlW6df23cHAbBhv.png"></p><h3 id="实现脚本"><a href="#实现脚本" class="headerlink" title="实现脚本"></a>实现脚本</h3><p><strong>ReloadMap.cs</strong></p><ol><li>Awake的时候，暂存相机起始位置，将当前地图更新到给定的缩放值，如果slider值发生了变化则reload地图</li><li>如果查询了地址，则进入函数，函数能让地图在缩放比例下，并以查询到的经纬度为地图的中心</li><li></li></ol><p>❗不知道HeroBuildingSelectionUserInput这个写在里面的作用<br>这个后面有案例涉及到的时候再看，还有一个就是点击出现对应名称的实现没看到❗</p><p><strong>ForwardGeocodeUserInput.cs</strong></p><ol><li>保证输入框有Input Field的属性</li><li>Awake的时候获取到输入框，并对输入框的更改完成状态添加监听器</li><li>初始化用于查询的“源”</li><li>mapbox的Geocoder api，根据输入框的内容进行地理编码</li><li>如果没查到，输入框的内容就是”没有编码响应“</li><li>如果查到了，则获取到坐标、响应、OnGeocoderResponse</li></ol><p>涉及到的知识点：<br><a href="https://blog.csdn.net/huoyixian/article/details/90386326">【Unity小知识】RequireComponent-CSDN博客</a></p><h3 id="POI的逻辑"><a href="#POI的逻辑" class="headerlink" title="POI的逻辑"></a>POI的逻辑</h3><p>在POI结构里的两个脚本</p><ul><li><p>PoiMarkerHelper.cs</p><blockquote><p>实现对poi信息点击后，打印出来</p></blockquote></li><li><p>FeatureBehaviour.cs</p></li></ul><blockquote><p>初始化参数；<br>创建primitive下的物体，设置名称、位置、父物体、位置<br>展现DebugData信息</p></blockquote><p>在POI数据里的两个modifier</p><ul><li>PrefabModifier.cs</li></ul><blockquote><p>创建右键菜单<br>构建POI的组织结构<br>设置位置<br>设置清除的方式</p></blockquote><ul><li>FeatureBehaviourModifier.cs</li></ul><blockquote><p>给poi挂载FeatureBehaviour的component</p></blockquote><h2 id="InteractiveStyledVectorMap"><a href="#InteractiveStyledVectorMap" class="headerlink" title="InteractiveStyledVectorMap"></a>InteractiveStyledVectorMap</h2><p><code>&lt;b&gt;</code>Styling Based on Vector Tile Data <code>&lt;/b&gt;</code><br>可以和特定的建筑物进行交互，展示他们对应的属性信息；<br>差异化对建筑物进行渲染贴图；<br>This is a vector tile map where you can interact with individual buildings to show their associated information (contained in the vector tile).<br>This example also shows how to procedurally decorate land use and how to render building types differently based on their classification.</p><h3 id="LoadingScreenCanvas"><a href="#LoadingScreenCanvas" class="headerlink" title="LoadingScreenCanvas"></a>LoadingScreenCanvas</h3><p>实现加载界面字颜色的变换</p><h3 id="Map设计❗"><a href="#Map设计❗" class="headerlink" title="Map设计❗"></a>Map设计❗</h3><p>（表示代码和细节还没看，现在看的只是逻辑和实现；<br>后面所有的案例就都是这样的）<br><img src="https://s2.loli.net/2024/02/12/7X85hElzSJi1ks6.png"></p><p>modifiers:</p><ul><li>ObjectInspector(Object Inspector Modifier)</li><li>HighLightModifier(Add Behaviours Modifier)</li><li>AddToTreeCollectionModifier(Add To Collection Modifier)</li><li>ParkLayerModifier(Layer Modifier)</li><li>SpawnInParkModifier(Spawn Inside Modifier)</li><li>DisableMeshRendererModifier(Disable Mesh Renderer Modifier)</li></ul><p>gameobject上的结构：</p><ul><li>RangeTileProvider.cs</li><li>HighlightFeature.cs</li><li>FeatureSelectionDetector.cs</li><li>FeatureUiMarkder.cs</li></ul><h3 id="InteractiveSelectionCanvas❗"><a href="#InteractiveSelectionCanvas❗" class="headerlink" title="InteractiveSelectionCanvas❗"></a>InteractiveSelectionCanvas❗</h3><p>实现点击对应物体，呈现出对应的信息<br>这个主要是在Map里的InteractiveSelectionCanvas里实现的</p><h2 id="TrafficAndDirections"><a href="#TrafficAndDirections" class="headerlink" title="TrafficAndDirections"></a>TrafficAndDirections</h2><p><code>&lt;b&gt;</code>Traffic and Directions <code>&lt;/b&gt;</code><br>通过交通矢量数据图层，提供交通信息。<br>通过简单的三维几何对交通进行了可视化；<br>给出了两个点，可以任意移动两个点，采用Direction API会返回两点之间的最短距离。<br>Mapbox provides traffic information through the traffic vector layer. In this example you can see an additional traffic map id added to Abstract Map under Map Layers segment. It’s then visualized by a simple 3D geometry. The Directions API returns the shortest route between two points. You can drag &amp; drop the two markers to update the route in this example. The Directions API call can also be used for walking directions.</p><h3 id="Map设计-地图"><a href="#Map设计-地图" class="headerlink" title="Map设计(地图)"></a>Map设计(地图)</h3><p>Modifiers:</p><ul><li>TrafficLoft(Loft Modifier)</li><li>LowTrafficMaterial(Material Modifier)</li><li>ModerateTrafficMateral(Material Modifier)</li><li>HeavyTrafficMaterial(Material Modifier)</li><li>Severe Traffic Material(Material Modifier)</li></ul><h3 id="TrafficUvAnimator-速度"><a href="#TrafficUvAnimator-速度" class="headerlink" title="TrafficUvAnimator(速度)"></a>TrafficUvAnimator(速度)</h3><p>控制交通流的速度</p><h3 id="Directions-点"><a href="#Directions-点" class="headerlink" title="Directions(点)"></a>Directions(点)</h3><p>有两个点<br>DirectionsFactory.cs<br>DragableDirectionWaypoint.cs</p><p>direction waypoint entity(最短路线)</p><p>在运行时动态生成，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;City-simulator&quot;&gt;&lt;a href=&quot;#City-simulator&quot; class=&quot;headerlink&quot; title=&quot;City simulator&quot;&gt;&lt;/a&gt;City simulator&lt;/h1&gt;&lt;p&gt;主要是对基础场景的搭建，也包括了基础数据的一</summary>
      
    
    
    
    <category term="AR开发" scheme="https://youxt-njnu.github.io/categories/AR%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unity" scheme="https://youxt-njnu.github.io/tags/Unity/"/>
    
    <category term="mapbox" scheme="https://youxt-njnu.github.io/tags/mapbox/"/>
    
    <category term="开源" scheme="https://youxt-njnu.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>初探即退之图形学Ⅲ|Games101</title>
    <link href="https://youxt-njnu.github.io/2024/02/08/%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%BD%A2%E5%AD%A63/"/>
    <id>https://youxt-njnu.github.io/2024/02/08/%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%BD%A2%E5%AD%A63/</id>
    <published>2024-02-08T00:58:05.000Z</published>
    <updated>2024-02-08T01:34:37.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="geometry"><a href="#geometry" class="headerlink" title="geometry"></a>geometry</h1><p>隐式几何 implicit，满足特定关系的 f(x,y,z)。较方便地判断光线和物体的相交。</p><p>显式几何 explicit，直接给出坐标，或者给出对应的参数映射。较方便的采样到所有的点。</p><h2 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h2><p>constructive solid geometry CSG 构造实体几何，隐式几何之间进行布尔运算，形成复杂形体。</p><p>signed distance function 符号距离函数，</p><p>level set 水平集，格子的双线性插值，</p><p>fractals 分形</p><p><img src="https://s2.loli.net/2023/12/21/t826aZjvzfcS1WC.png"></p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>point cloud</p><p>polygon mesh</p><p>.obj格式：先定义点，然后定义纹理坐标，再定义面的法线信息，最后定义面的组成</p><h3 id="curve"><a href="#curve" class="headerlink" title="curve"></a>curve</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>算法de Casteljau algorithm： 给任意点所在时间 t，找位置，递归思想</p><p>仿射变换下，贝塞尔曲线点画出来的，和变换后的一样。对于投影变换就不行。</p><p>高阶的贝塞尔曲线处理，进行逐段定义。四个点即可形成，也是 PS 里面的钢笔工具原理。共线等距算切线状态，此时大小和方向都一样。</p><h4 id="spline-样条"><a href="#spline-样条" class="headerlink" title="spline 样条"></a>spline 样条</h4><p>B- spline（Basis splines）</p><p><strong>B样条曲线相对于贝塞尔曲线可以更好的进行局部控制</strong> <strong>NURBS曲线可以得到一些B样条曲线无法精准描述的圆锥曲线</strong></p><h3 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h3><p>Bezier Surfaces：贝塞尔曲线到曲面</p><h3 id="mesh-operation-网格操作"><a href="#mesh-operation-网格操作" class="headerlink" title="mesh operation 网格操作"></a>mesh operation 网格操作</h3><h4 id="mesh-subdivision"><a href="#mesh-subdivision" class="headerlink" title="mesh subdivision"></a>mesh subdivision</h4><blockquote><p>提高分辨率，向上采样 upsampling<br>曲面细分</p></blockquote><p>loop subdivision 发明者姓 loop</p><blockquote><p>针对三角形面细分的方式，引入更多的三角形，并使得其位置发生变化</p></blockquote><blockquote><p>n 是顶点的度 u 是和顶点的度有关系的数</p></blockquote><p>cc 细分（Catmull-Clark细分），对于一般格网，不同</p><p>Pixar 做动画很强的</p><h4 id="mesh-simplification"><a href="#mesh-simplification" class="headerlink" title="mesh simplification"></a>mesh simplification</h4><blockquote><p>降低分辨率，向下采样 downsampling<br>曲面简化</p></blockquote><p>在什么场合，使用多少精细度的模型。<br>一种方法，edge collapsing，如何坍缩一条边，或者说坍缩哪一条边能够使得原模型样貌被改变的程度最小，这就是曲面简化的关键所在。因此引入了二次误差度量（点到原有点的二次平方和最小）。<br>测量哪边的坍缩最小，同时其他受到影响的边的变换也要最小。使用最小堆来实现。</p><h4 id="mesh-regularization"><a href="#mesh-regularization" class="headerlink" title="mesh regularization"></a>mesh regularization</h4><p>使得 mesh 的三角形里面不会出现那种很尖的或者很大的或者很小的三角形，而是都比较趋向于相近的正三角形。</p><h2 id="shader-mapping"><a href="#shader-mapping" class="headerlink" title="shader mapping"></a>shader mapping</h2><p>draw shadows using rasterization<br>经典的 shadow mapping 只能处理点光源&#x2F;方向光源。<br>出现误差&#x2F;质量不好的原因：进行数值比较的时候，一方面是数值精度（特别是浮点数）在进行比较的时候的影响，另一方面是 shadow map 的分辨率和整个场景的分辨率之间的差异。</p><h3 id="hard-shadows-amp-soft-shadows"><a href="#hard-shadows-amp-soft-shadows" class="headerlink" title="hard shadows &amp; soft shadows"></a>hard shadows &amp; soft shadows</h3><p>如果出现软阴影，说明不是点光源，光源存在着一定的大小，这样才能看到半影 penumbra</p><h1 id="Ray-tracing"><a href="#Ray-tracing" class="headerlink" title="Ray tracing"></a>Ray tracing</h1><p>光栅化无法很好的处理全局的效果。光栅化普遍比较快，但渲染质量比较差。光线追踪相反，所以经常用来处理动画，录成视频给我们看。</p><h2 id="基本的光线追踪"><a href="#基本的光线追踪" class="headerlink" title="基本的光线追踪"></a>基本的光线追踪</h2><p>光线可逆性，reciprocity<br>eye ray &#x2F; camera ray &#x2F; primary ray<br>Secondary ray<br>Shadow ray</p><h2 id="whitted-style-ray-tracing"><a href="#whitted-style-ray-tracing" class="headerlink" title="whitted- style ray tracing"></a>whitted- style ray tracing</h2><p>递归算法<br>多个点的着色的值都要加到里面<br><img src="https://s2.loli.net/2024/02/07/MwH1nCD3c6ghUXO.png"></p><h2 id="ray-surface-interaction"><a href="#ray-surface-interaction" class="headerlink" title="ray surface interaction"></a>ray surface interaction</h2><p>求交点<br>光线和球存在相离相切相交的问题。</p><p>隐式表面，通过方程组求。<br>显式表面，通过光线和三角形求交。</p><blockquote><p>光线和平面相交<br>求和三角的交点<br>MT 算法：写成用重心坐标形式表示的平面内的点，和光线上的点，解出 t,b1,b2.然后判断解出来的和不合理。是不是正的时间，是不是点在三角形内（b1,b2 大于 0</p></blockquote><p>加速光线和平面求交的效率（已经知道了光线和三角形求交的 方式，最不济就是和所有的三角形进行一一求交，但是很慢）</p><h3 id="bounding-volumes"><a href="#bounding-volumes" class="headerlink" title="bounding volumes"></a>bounding volumes</h3><p>使用包围盒来进行加速。<br>如果光线碰不到包围盒，那肯定碰不到物体。<br>最常见的就是长方体，有三个不同的对面构成的交集 3 pairs of slabs<br>轴对齐包围盒 AABB<br>判断光线和盒子有没有交点</p><blockquote><p>从二维到三维，<br>二维下，两个对面的交集，得到了光线实际进入和移出的 tmin和 tmax<br>光线和盒子有交点，当且仅当进入时间小于出去时间，且出去时间为正。</p></blockquote><h3 id="使用-AABB-来加速光线追踪-acceleration"><a href="#使用-AABB-来加速光线追踪-acceleration" class="headerlink" title="使用 AABB 来加速光线追踪 acceleration"></a>使用 AABB 来加速光线追踪 acceleration</h3><p>uniform spatial partitions，grids</p><blockquote><p>格子分辨率的选择，需要平衡；<br>在部分情况下，格子画了很多，但场景很空，还是得花很长时间才能到达物体所在的格子；</p></blockquote><p>Spatial partitioning examples</p><blockquote><p>oct-Tree，八叉树，在二维的情况下就是四叉树；<br>KD-Tree，为了让划分和维度没有关系，就是比上面的优化一下，提出的 KD 树；<br>BSP-Tree，相对 KD 树来说不是横平竖直的砍；在维度高的时候会越来越难计算；</p></blockquote><p>通过和包围盒进行判断有没有交点，一层一层按照树节点的顺序往下进行遍历判断；<br>kd 树的一个问题是，难以确定一个三角形和划分的 aabb 有交点。另一种划分方法想了出来，就是针对物体进行划分</p><h2 id="object-partitions"><a href="#object-partitions" class="headerlink" title="object partitions"></a>object partitions</h2><p>bounding volume hierarchy，BVH<br>kd 树先划分空间，再考虑和物体的相交情况，BVH 先分物体成两堆，再求包围盒。 这样一个物体只会存在于一个盒子里。<br>但存在的问题就是，BVH 对空间的划分并不能保证划分开，包围盒最后会有相交的部分。</p><h2 id="辐射度量学-basic-radiometry"><a href="#辐射度量学-basic-radiometry" class="headerlink" title="辐射度量学 basic radiometry"></a>辐射度量学 basic radiometry</h2><p>这一块的知识点很像遥感那边的。<br>精确地度量光照的系统和单位，以及光的空间属性。</p><blockquote><p>Radiant energy and flux(power)<br>Radiant intensity<br>radiant flux<br>intensity， solid angle 立体角，单位立体角，微分立体角<br><img src="https://s2.loli.net/2024/02/07/ZNzwnhDedvJpFLI.png"><br>irradiance，垂直投影下单位面积的 power，Lambert cosine law 里的也是这样<br>radiance</p></blockquote><p>bidirectional reflectance distributuion function(BRDF)</p><blockquote><p>可以告诉我们这么多的能量从不同方向进来，反射到不同方向下的能量是多少。<br>也可以理解成光线照射过来，被单位面积吸收，这个单位面积又自己发射能量，这样就能用 radiance 和 irradiance 来进行解释和计算。<br>radiance 除以 irradiance<br>反射方程 reflection equation<br>把 irradiance 乘以 BRDF，就变成了出射的 radiance，然后在所有的方向上进行积分。<br>一个挑战，到达这个物体的光不只是光源到达这个物体之后的反射，也会有其他物体对光源的反射出来的 radiance。所以是一个递归的问题。</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>渲染方程，物体往一个点发射出来的光，是包括了这个物体自己发射产生出去的光，和通过被人的反射过来或者其他光源照亮的入射 后反射的radiance。<br><img src="https://s2.loli.net/2024/02/07/ZT2O76yj8t3IN9C.png"><br><img src="https://s2.loli.net/2024/02/07/1dkRiFoyqxeAPhN.png"><br>面光源，进行积分<br><img src="https://s2.loli.net/2024/02/07/K98eWC5xswrT4Jl.png"><br>多个物体<br><img src="C:\Users\Xiangting\AppData\Roaming\Typora\typora-user-images\image-20240207084805768.png" alt="image-20240207084805768"><br>渲染方程拆分成不同弹射次数，所有不同的光线弹射次数加起来就是全局光照。<br><img src="https://s2.loli.net/2024/02/07/V6AemFfg9WYD8Ls.png"></p><h2 id="global-illumination"><a href="#global-illumination" class="headerlink" title="global illumination"></a>global illumination</h2><p>是直接和间接光照的集合。<br>光栅化主要做的是自己自发光和光源的部分，也就是零次和一次。<br>后面就是光线追踪Ray Tracing的部分。</p><h3 id="通过概率论来解渲染方程"><a href="#通过概率论来解渲染方程" class="headerlink" title="通过概率论来解渲染方程"></a>通过概率论来解渲染方程</h3><p>概率密度函数 PDF<br><img src="https://s2.loli.net/2024/02/07/TRt6LXp5W7OdniM.png"></p><h2 id="蒙特卡洛路径追踪"><a href="#蒙特卡洛路径追踪" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h2><h3 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h3><p>蒙特卡洛积分，针对复杂的函数，解一个定积分，也就是得到一个数值就行；</p><p>是通过随机采样的方式，通过采样近似成矩形，然后进行累加；</p><p><img src="https://s2.loli.net/2024/02/07/PYhZWupUBlEX8mK.png"></p><p><img src="https://s2.loli.net/2024/02/07/HmJ1Eo6kfKcPIWY.png"></p><p>主要可以采样，并且知道采样的PDF，就可以进行定积分；</p><p>蒙特卡洛积分的要求，在X上采样，就在X上进行积分。</p><h3 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><p>镜面反射：specular，Mirror Reflection;</p><p>Glossy Reflection;</p><p>漫反射：diffuse，</p><p>whitted-style ray tacing存在着很多问题；</p><p>尝试用蒙特卡洛来解渲染方程；</p><p><img src="https://s2.loli.net/2024/02/07/kuNwLdBo5WJYvSx.png"></p><p>当N过大的时候，会发生指数爆炸；所以令N&#x3D;1，也就是只有一条光线，这个时候也就是Path Tracing.</p><p><img src="https://s2.loli.net/2024/02/07/hNbMHmvPpUWsqrC.png"></p><p>此外，用多个方向，选取多束；</p><p>同时，递归需要有终止条件，但 现实世界中光线的反射是无限的；这个时候在程序中如何决定终止条件，可以引入Russian Roulette（RR）。</p><p>为了提高光线的利用，减少浪费，可以从光源入手，从光源发射出来，把渲染方程改成对光源面积进行积分；</p><p><img src="https://s2.loli.net/2024/02/07/iRG8ejxzkmbqIZt.png"></p><p><img src="https://s2.loli.net/2024/02/07/AExMNb54p7LaYDl.png"></p><p>路径追踪可以做到照片级真实感Photo-realistic</p><p>一些概念区分和变化：</p><p><img src="https://s2.loli.net/2024/02/07/qjYarOFhdyz1Vc7.png"></p><h1 id="Materials-and-Appearance"><a href="#Materials-and-Appearance" class="headerlink" title="Materials and Appearance"></a>Materials and Appearance</h1><p>BRDF定义反射，等于材质；</p><p>抛光的金属：Glossy Material;</p><p>玻璃和水：Ideal reflective&#x2F;refractive material;</p><blockquote><p>折射定律：Snell’s Law, Snell’s Window&#x2F;Circle</p><p>BSDF: 散射，BRDF+BTDF</p><p>Fresnel Reflection&#x2F;Term 菲涅耳项。</p></blockquote><p>镜面：Specular</p><p>微表面材质：Microfacet Material</p><blockquote><p>物体虽然表面是粗糙的，但从远处来看看成了平的；</p></blockquote><p>各向同性和各项异性材质</p><p><img src="https://s2.loli.net/2024/02/07/YufBe35V9MSP2GF.png"></p><h1 id="相机、透镜和光场"><a href="#相机、透镜和光场" class="headerlink" title="相机、透镜和光场"></a>相机、透镜和光场</h1><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>Field of View(FOV): 视场</p><blockquote><p>可以用传感器大小和焦距来表示；</p></blockquote><p>Exposure 曝光</p><p>aperture 光圈，焦距&#x2F;光圈的直径 是F-Number</p><p>shutter speed 快门开放的时间，快门速度</p><p>ISO gain 感光度</p><h2 id="Lenses"><a href="#Lenses" class="headerlink" title="Lenses"></a>Lenses</h2><p>focal point 焦点</p><p>focal length 焦距</p><p>depth of field 景深</p><h2 id="Light-Field-x2F-lumigraph"><a href="#Light-Field-x2F-lumigraph" class="headerlink" title="Light Field&#x2F;lumigraph"></a>Light Field&#x2F;lumigraph</h2><p>the plenoptic function 全光函数</p><p>holographic movie 全息电影</p><h1 id="颜色和感知"><a href="#颜色和感知" class="headerlink" title="颜色和感知"></a>颜色和感知</h1><p>Color and Perception</p><p>光谱，谱功率密度SPD。<br>颜色是人的感知，和实际光的分布无关。<br>metamers 同色异谱<br>color space颜色空间</p><blockquote><p>standard RGB (sRGB)<br>CIE XYZ<br>HSV<br>CIELAB<br>CMYK<br>人脑会自动互补色，颜色也是相对的，</p></blockquote><p>Gamut 色域<br>颜色的伽马校正</p><h1 id="animation-simulation"><a href="#animation-simulation" class="headerlink" title="animation simulation"></a>animation simulation</h1><ol><li>关键帧动画<br>keyframe，keyframe interpolation</li><li>物理模拟&#x2F;仿真<br>模拟的正常的话，就不会发生穿模的现象。<br>流体的模拟，水花的感觉</li></ol><h2 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h2><p>mass spring system<br>一系列相互连接的质点和弹簧</p><h2 id="particle-systems"><a href="#particle-systems" class="headerlink" title="particle systems"></a>particle systems</h2><p>attraction，repulsion，alignment</p><h2 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h2><p>kinematics<br>forward kinematics<br>inverse kinematics</p><h2 id="rigging"><a href="#rigging" class="headerlink" title="rigging"></a>rigging</h2><p>类似木偶操作，对模型添加控制点。</p><h2 id="motion-capture"><a href="#motion-capture" class="headerlink" title="motion capture"></a>motion capture</h2><p>将真人的动作，应用到模型上去。<br><img src="https://s2.loli.net/2024/02/08/OyR4mWAgEQDHXin.png"><img src="https://s2.loli.net/2024/02/08/OyR4mWAgEQDHXin.png"></p><h2 id="动画模拟补充"><a href="#动画模拟补充" class="headerlink" title="动画模拟补充"></a>动画模拟补充</h2><p>single particle simulation<br>euler’s method</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;geometry&quot;&gt;&lt;a href=&quot;#geometry&quot; class=&quot;headerlink&quot; title=&quot;geometry&quot;&gt;&lt;/a&gt;geometry&lt;/h1&gt;&lt;p&gt;隐式几何 implicit，满足特定关系的 f(x,y,z)。较方便地判断光线和物体的相交。</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="知识框架" scheme="https://youxt-njnu.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
