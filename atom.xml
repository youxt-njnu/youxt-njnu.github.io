<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pale Bule Dot</title>
  
  
  <link href="https://youxt-njnu.github.io/atom.xml" rel="self"/>
  
  <link href="https://youxt-njnu.github.io/"/>
  <updated>2024-10-05T12:06:36.549Z</updated>
  <id>https://youxt-njnu.github.io/</id>
  
  <author>
    <name>Shealin You</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>three案例实操|赛博风大屏坑①</title>
    <link href="https://youxt-njnu.github.io/2024/09/21/three-%E8%B5%9B%E5%8D%9A%E5%A4%A7%E5%B1%8F%E5%A1%AB%E5%9D%911/"/>
    <id>https://youxt-njnu.github.io/2024/09/21/three-%E8%B5%9B%E5%8D%9A%E5%A4%A7%E5%B1%8F%E5%A1%AB%E5%9D%911/</id>
    <published>2024-09-21T06:02:05.000Z</published>
    <updated>2024-10-05T12:06:36.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-第一批"><a href="#问题-第一批" class="headerlink" title="问题(第一批)"></a>问题(第一批)</h1><h2 id="球体的陆地和海洋并没有区分出来"><a href="#球体的陆地和海洋并没有区分出来" class="headerlink" title="球体的陆地和海洋并没有区分出来"></a>球体的陆地和海洋并没有区分出来</h2><p>尝试1：看看texture是否正确加载</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> earthTexture = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(earthImg, <span class="keyword">function</span> (<span class="params">texture</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;texture loaded successfully&#x27;</span>);</span><br><span class="line">    &#125;, <span class="literal">undefined</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;texture load failed&#x27;</span>, err); &#125;);</span><br></pre></td></tr></table></figure><p>问题是对UV的计算错了：<br>错处1：<code> let uv = [(sph + Math.PI) / (2 * Math.PI), 1 - (sph.theta / Math.PI)];</code></p><p>需要使用new Three.Vector2(),而不是直接构建数组；如果是直接构建数组，那下面就访问不到.x和.y，需要使用[0]和[1]来访问对应的内容。</p><p>错处2：<code>let uv = new Three.Vector2(sph + Math.PI) / (2 * Math.PI), 1 - (sph.theta / Math.PI));</code></p><p>这里对UV的映射计算错了</p><blockquote><p>在 Three.js 中，<code>Spherical</code> 类表示的球坐标系统是基于三维右手笛卡尔坐标系，其中 <code>phi</code>（仰角）和 <code>theta</code>（方位角）的定义具体如下：</p><ol><li><strong><code>phi</code>（仰角）</strong> - 这是从正Y轴向下至点P的线段与Y轴之间的角度。在 Three.js 中，<code>phi</code> 的范围通常是从0到π（即从0到180度），其中0对应于正Y轴（向上）的方向，而π对应于负Y轴（向下）的方向。</li><li><strong><code>theta</code>（方位角）</strong> - 这是在XZ平面上，从正Z轴向正X轴的角度。<code>theta</code> 的范围是从0到2π（即从0到360度），其中0开始于正Z轴，增加方向是逆时针（从屏幕向里到屏幕向外看为正Z方向）。<br>因此，<code>Spherical</code> 的 <code>phi</code> 和 <code>theta</code> 的直观理解如下：</li></ol><ul><li><code>phi = 0</code>：点位于Y轴的正方向（向上）。</li><li><code>phi = π/2</code>：点位于XZ平面。</li><li><code>phi = π</code>：点位于Y轴的负方向（向下）。</li><li><code>theta = 0</code>：点位于Z轴的正方向（向屏幕外）。</li><li><code>theta = π/2</code>：点位于X轴的正方向（向右）。</li><li><code>theta = π</code>：点位于Z轴的负方向（向屏幕里）。</li><li><code>theta = 3π/2</code>：点位于X轴的负方向（向左）。<br>这种球坐标系统非常有用于处理与球面或者环绕运动相关的场景，如天体模拟、相机环绕目标物体的动作等。</li></ul></blockquote><p>正确写法：<code>let uv = new Three.Vector2((sph.theta + Math.PI) / (2 * Math.PI), 1 - (sph.phi / Math.PI));</code> </p><p>为了正确理解这段代码 <code>let uv = [(sph.theta + Math.PI) / (2 * Math.PI), 1 - (sph.phi / Math.PI)];</code> 并将二维贴图UV映射到球面上，让我们逐一分析每个部分：</p><ol><li><p><strong><code>(sph.theta + Math.PI) / (2 * Math.PI)</code></strong>:</p><ul><li><code>sph.theta</code> 表示球坐标中的方位角，通常的取值范围是从 0 到 2π，表示从正Z轴顺时针到X轴再回到Z轴的全周角度。</li><li><code>+ Math.PI</code> 的作用是将θ的起始点从正Z轴（前面）调整到负Z轴（后面）。通常，这种调整是为了使UV映射的起点对应于模型的后方，从而使得当模型前向朝向观察者时，贴图的“前面”能够正对观察者。</li><li>除以 <code>(2 * Math.PI)</code> 将调整后的θ值归一化到 [0, 1] 的范围内，这样可以映射到贴图的水平坐标U。</li></ul></li><li><p><strong><code>1 - (sph.phi / Math.PI)</code></strong>:</p><ul><li><code>sph.phi</code> 是从正Y轴向球面的点的仰角，取值范围是从 0 到 π。</li><li><code>(sph.phi / Math.PI)</code> 将φ值归一化到 [0, 1] 范围内，其中0代表北极，1代表南极。</li><li><code>1 -</code> 的作用是反转V坐标，使得在UV贴图中，V &#x3D; 0 对应于球体的北极，V &#x3D; 1 对应于球体的南极。这样的反转是必要的，因为在大多数图形处理系统中，贴图的V坐标从下到上增加，而球坐标系统中的φ是从上到下增加的。</li></ul></li></ol><p>(Three.js地理坐标和三维空间坐标的转换)[<a href="https://blog.csdn.net/qihoo_tech/article/details/101443066]">https://blog.csdn.net/qihoo_tech/article/details/101443066]</a></p><p><img src="https://s2.loli.net/2024/09/09/pbtr2HfNW7xTSkC.png" alt="image-20240908162225403.png"></p><h2 id="trail没显示出来"><a href="#trail没显示出来" class="headerlink" title="trail没显示出来"></a>trail没显示出来</h2><p>vLineDistance &#x2F;&#x2F; 在使用 Three.js 的 LineDashedMaterial 时，确保顶点着色器正确地计算并传递 vLineDistance 变量到片元着色器是非常关键的，因为这个变量决定了线段的虚线效果。</p><p>原先是再setPath里修改点的位置，然后计算lineDistance，由于lineDistance计算有问题，所以在fragment shader里，vLineDistance就都是0</p><p>在setPath的代码里，求division需要用pos.count来-1，之前是pos直接-1，导致了错误，使得trail的pos都没有正确更新；</p><h2 id="按钮切换效果不出来"><a href="#按钮切换效果不出来" class="headerlink" title="按钮切换效果不出来"></a>按钮切换效果不出来</h2><p>如果在 <code>useEffect</code> 中的依赖数组（第二个参数）设置为空数组 <code>[]</code>，这意味着 <code>useEffect</code> 只会在组件首次挂载时运行一次，而不会在组件的状态或属性更新时再次运行。这常用于执行那些只需一次的初始化操作，如 API 调用或设置初始配置。</p><p>在您的情况中，如果 <code>animate</code> 函数在 <code>useEffect</code> 内定义，并且依赖数组为空，这会导致 <code>animate</code> 函数捕获到初始渲染时的状态值，例如 <code>renderGlithPass</code> 的初始值（<code>false</code>）。即使后续 <code>renderGlithPass</code> 状态更新，<code>animate</code> 函数中的值也不会更新，因为 <code>useEffect</code> 不会重新执行来更新闭包中的状态值。</p><p>解决方法</p><p>要让 <code>animate</code> 函数能够访问最新的 <code>renderGlithPass</code> 状态，您有两个选择：</p><ol><li><strong>更新 <code>useEffect</code> 的依赖数组</strong>：在依赖数组中包含 <code>renderGlithPass</code>，这样每次 <code>renderGlithPass</code> 改变时，<code>useEffect</code> 都会重新执行，<code>animate</code> 函数也将重新定义，从而捕获到最新的状态值。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(renderGlithPass);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> animationId = <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">cancelAnimationFrame</span>(animationId);</span><br><span class="line">&#125;, [renderGlithPass]); <span class="comment">// 现在包含 renderGlithPass 作为依赖</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用 <code>useRef</code> 追踪最新的状态</strong>：如之前所述，您可以使用 <code>useRef</code> 来追踪 <code>renderGlithPass</code> 的最新值，这样 <code>animate</code> 函数可以通过 ref 访问当前的状态，而无需重新定义 <code>animate</code> 函数。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderGlithPassRef = <span class="title function_">useRef</span>(renderGlithPass);</span><br><span class="line">renderGlithPassRef.<span class="property">current</span> = renderGlithPass;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(renderGlithPassRef.<span class="property">current</span>); <span class="comment">// 使用 ref 访问最新状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> animationId = <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">cancelAnimationFrame</span>(animationId);</span><br><span class="line">&#125;, []); <span class="comment">// 依赖数组仍然为空</span></span><br></pre></td></tr></table></figure><p>这两种方法各有优势，选择哪一种取决于您的具体需求和组件的其他逻辑。如果 <code>animate</code> 函数对性能要求较高并且状态更新频繁，使用 <code>useRef</code> 可能是一个更好的选择。如果状态更新对 <code>animate</code> 的影响比较大，并且确保每次都是最新的状态很重要，那么更新 <code>useEffect</code> 的依赖数组可能更适合。</p><h2 id="animate里的renderGlithPass总是false，未更新"><a href="#animate里的renderGlithPass总是false，未更新" class="headerlink" title="animate里的renderGlithPass总是false，未更新"></a>animate里的renderGlithPass总是false，未更新</h2><p>在你的React代码中，你遇到的问题是由于闭包（closure）引起的。在JavaScript和React中，闭包会捕获它们创建时的环境状态。当你在 <code>useEffect</code> 钩子里调用 <code>animate()</code> 函数时，这个函数被“固定”在了那一刻的状态，包括 <code>renderGlithPass</code> 的值。</p><p>因为 <code>useEffect</code> 仅在组件挂载时执行一次（因为它的依赖列表是空的 <code>[]</code>），所以 <code>animate</code> 函数只会捕获 <code>renderGlithPass</code> 最初的值，即 <code>false</code>。之后即使状态更新了，<code>animate</code> 函数中捕获的 <code>renderGlithPass</code> 的值仍然是最初的 <code>false</code>。</p><p>解决这个问题的一个方法是使用 <code>useRef</code> 钩子来持久化 <code>renderGlithPass</code> 的值，这样 <code>animate</code> 函数总是能获取到最新的状态。这里是如何修改你的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [renderGlitchPass, setRenderGlitchPass] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> renderGlitchPassRef = <span class="title function_">useRef</span>(renderGlitchPass);  <span class="comment">// 使用 useRef 来持久化状态</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  renderGlitchPassRef.<span class="property">current</span> = renderGlitchPass;  <span class="comment">// 更新 ref 的值</span></span><br><span class="line">&#125;, [renderGlitchPass]);  <span class="comment">// 每当 renderGlitchPass 更新时，更新 ref</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable constant_">TWEEN</span>.<span class="title function_">update</span>();</span><br><span class="line">    earth.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.001</span>;</span><br><span class="line">    renderer &amp;&amp; scene &amp;&amp; camera &amp;&amp; renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ref 的 current 值来获取最新状态</span></span><br><span class="line">    renderGlitchPassRef.<span class="property">current</span> &amp;&amp; composer.<span class="title function_">render</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">animate</span>();  <span class="comment">// 启动动画循环</span></span><br><span class="line">&#125;, []);  <span class="comment">// 空依赖列表，仅在组件挂载时执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleStartButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setRenderGlitchPass</span>(!renderGlitchPass);  <span class="comment">// 切换状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题-第一批&quot;&gt;&lt;a href=&quot;#问题-第一批&quot; class=&quot;headerlink&quot; title=&quot;问题(第一批)&quot;&gt;&lt;/a&gt;问题(第一批)&lt;/h1&gt;&lt;h2 id=&quot;球体的陆地和海洋并没有区分出来&quot;&gt;&lt;a href=&quot;#球体的陆地和海洋并没有区分出来&quot; cla</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/09/17/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%953/"/>
    <id>https://youxt-njnu.github.io/2024/09/17/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%953/</id>
    <published>2024-09-17T10:02:05.000Z</published>
    <updated>2024-10-05T12:05:02.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="机甲风head和card"><a href="#机甲风head和card" class="headerlink" title="机甲风head和card"></a>机甲风head和card</h1><p>新建constant.js，存放一些固定的内容文本数组；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> weekMap =&#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> tips = [...];</span><br></pre></td></tr></table></figure><p>设置state存放显示的内容；<br>在 React 中，组件可以是类组件或函数式组件。在函数式组件中，传统的类组件中的 state 和生命周期方法被 React Hooks 提供的功能所替代。最常用的 Hook 是 useState，它用于在函数式组件中添加状态管理功能。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [week, setWeek] = <span class="title function_">useState</span>(weekMap[<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>()]);</span><br><span class="line"><span class="keyword">const</span> [time, setTime] = <span class="title function_">useState</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>());</span><br><span class="line"><span class="keyword">const</span> [showModal, setShowModal] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [modelText, setModelText] = <span class="title function_">useState</span>(tips[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> [renderGlithPass, setRenderGlithPass] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>header结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&quot;hud-header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;`$&#123;week&#125;曜日`&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;time&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Kepler-90 +49°18′18.58″<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scss里写clip-path</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">  <span class="variable">$yellow-color</span>: <span class="number">#f9f002</span>;</span><br><span class="line">  <span class="variable">$border-color</span>: <span class="number">#8ae66e</span>;</span><br><span class="line">  <span class="variable">$blue-color</span>: <span class="number">#00e6f6</span>;</span><br><span class="line">  <span class="variable">$header-height</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="variable">$aside-width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="variable">$glitched-duration</span>: <span class="number">0.9s</span>;</span><br><span class="line">  <span class="variable">$clip-height</span>: <span class="number">18px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.earth-digital</span> &#123;</span><br><span class="line">  <span class="comment">// overflow: hidden; // 这样子就没有了右侧拖动条，多出来的直接消失了</span></span><br><span class="line">  <span class="comment">// user-select: none; // 禁止选中文字</span></span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">0.85</span>); <span class="comment">// 饱和度 体现在哪儿？？</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hud</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  &amp;<span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$header-height</span>;</span><br><span class="line">    <span class="attribute">color</span>: black; <span class="comment">// 里面的文字颜色</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$yellow-color</span>; <span class="comment">// header 的背景颜色</span></span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;<span class="variable">$clip-height</span>&#125;),<span class="number">75%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;), <span class="number">72.5%</span> <span class="number">100%</span>, <span class="number">27.5%</span> <span class="number">100%</span>, <span class="number">25%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;),<span class="number">0</span> <span class="built_in">calc</span>(<span class="number">100%</span> - #&#123;$clip-height&#125;),<span class="number">0</span> <span class="number">0</span>); <span class="comment">// 使用calc的时候，里面操作符前后要有空格</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/11/ZL9FgtrxEBW2ame.jpg" alt="27e2baa8c3a79d08953b367291a0195.jpg"></p><p>logo和aside部分的结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;logo-pic&quot; title=&#x27;Cyberpunk 2077&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside left&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;cover&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div className=&quot;info&quot;&gt;</span><br><span class="line">      &lt;p&gt;&lt;b&gt;Cyberpunk&lt;/b&gt; is a subgenre of science fiction in a dystopian futuristic setting that tends to focus on a &quot;combination of lowlife and high tech&quot;, featuring futuristic technological and scientific achievements, such as artificial intelligence and cybernetics, juxtaposed with societal collapse or decay. &lt;/p&gt;</span><br><span class="line">      &lt;button&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside right&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br></pre></td></tr></table></figure><h1 id="button点击后出现故障风"><a href="#button点击后出现故障风" class="headerlink" title="button点击后出现故障风"></a>button点击后出现故障风</h1><p>点击触发函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const handleStartButtonClick = () =&gt; &#123;</span><br><span class="line">    setRenderGlithPass(!renderGlithPass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>动画中更新：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const animate = () =&gt; &#123;</span><br><span class="line"> ......</span><br><span class="line">  renderGlithPass &amp;&amp; composer.render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后处理效果"><a href="#后处理效果" class="headerlink" title="后处理效果"></a>后处理效果</h2><p>导入composer和pass</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EffectComposer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/EffectComposer.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RenderPass</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/RenderPass.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GlitchPass</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/postprocessing/GlitchPass.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>initThree里初始化</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">composer = <span class="keyword">new</span> <span class="title class_">EffectComposer</span>(renderer);</span><br><span class="line">composer.<span class="title function_">addPass</span>(<span class="keyword">new</span> <span class="title class_">RenderPass</span>(scene, camera));</span><br><span class="line">composer.<span class="title function_">addPass</span>(<span class="keyword">new</span> <span class="title class_">GlitchPass</span>());</span><br></pre></td></tr></table></figure><h2 id="btn的样式"><a href="#btn的样式" class="headerlink" title="btn的样式"></a>btn的样式</h2><p>利用linear-gradient，实现了45度方向上，从透明到红色的按钮的突变（5%，5%），这个和《CSS揭秘》里的内容呼应了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.startBtn</span>,</span><br><span class="line"><span class="selector-class">.startBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">5%</span>, <span class="number">#FF013C</span> <span class="number">5%</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">6px</span> <span class="number">0</span> <span class="number">0</span> $blue-color;</span><br><span class="line">  <span class="attribute">outline</span>: transparent;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h1><p><a href="https://echarts.apache.org/handbook/zh/basics/import/">https://echarts.apache.org/handbook/zh/basics/import/</a></p><p>按需引入：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts/core&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入柱状图图表，图表后缀都为 Chart</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BarChart</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/charts&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入标题，提示框，直角坐标系，数据集，内置数据转换器组件，组件后缀都为 Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">TitleComponent</span>,</span><br><span class="line">  <span class="title class_">TooltipComponent</span>,</span><br><span class="line">  <span class="title class_">GridComponent</span>,</span><br><span class="line">  <span class="title class_">DatasetComponent</span>,</span><br><span class="line">  <span class="title class_">TransformComponent</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/components&#x27;</span>;</span><br><span class="line"><span class="comment">// 标签自动布局、全局过渡动画等特性</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LabelLayout</span>, <span class="title class_">UniversalTransition</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/features&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CanvasRenderer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;echarts/renderers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册必须的组件</span></span><br><span class="line">echarts.<span class="title function_">use</span>([</span><br><span class="line">  <span class="title class_">TitleComponent</span>,</span><br><span class="line">  <span class="title class_">TooltipComponent</span>,</span><br><span class="line">  <span class="title class_">GridComponent</span>,</span><br><span class="line">  <span class="title class_">DatasetComponent</span>,</span><br><span class="line">  <span class="title class_">TransformComponent</span>,</span><br><span class="line">  <span class="title class_">BarChart</span>,</span><br><span class="line">  <span class="title class_">LabelLayout</span>,</span><br><span class="line">  <span class="title class_">UniversalTransition</span>,</span><br><span class="line">  <span class="title class_">CanvasRenderer</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>构建数据 constant.js</p><p>导入：<br><code>import &#123; chart_1_option, chart_2_option, chart_3_option, chart_4_option, chart_5_option, weekMap, tips &#125; from &#39;@/containers/EarthDigital/scripts/config&#39;;</code></p><p>初始化chart</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const chart_1 = echarts.init(document.getElementsByClassName(&#x27;chart_1&#x27;)[0], &#x27;dark&#x27;);</span><br><span class="line">   chart_1 &amp;&amp; chart_1.setOption(chart_1_option);</span><br></pre></td></tr></table></figure><p>使用useRef进行简化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let chartsRef = Array.from(&#123; length: 5 &#125;).map(() =&gt; useRef(null));</span><br><span class="line">const initChart = () =&gt; &#123;</span><br><span class="line">  const chartsOption = [chart_1_option, chart_2_option, chart_3_option, chart_4_option, chart_5_option];</span><br><span class="line">  const charts = chartsRef.map(ref =&gt; ref.current &amp;&amp; echarts.init(ref.current, &#x27;dark&#x27;));</span><br><span class="line">  charts.forEach((chart, idx) =&gt; &#123;</span><br><span class="line">    chart &amp;&amp; chart.setOption(chartsOption[idx]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的aside</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aside className=&quot;hud aside left&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box box_0 inverse&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;cover&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div className=&quot;info&quot;&gt;</span><br><span class="line">      &lt;p className=&#x27;text&#x27;&gt;&lt;b&gt;Cyberpunk&lt;/b&gt; is a subgenre of science fiction in a dystopian futuristic setting that tends to focus on a &quot;combination of lowlife and high tech&quot;, featuring futuristic technological and scientific achievements, such as artificial intelligence and cybernetics, juxtaposed with societal collapse or decay. &lt;/p&gt;</span><br><span class="line">      &lt;button className=&quot;startBtn&quot; onClick=&#123;handleStartButtonClick&#125;&gt;START&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[0]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[1]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br><span class="line">&lt;aside className=&quot;hud aside right&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[2]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[3]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div className=&quot;box inverse dotted&quot;&gt;&lt;div className=&quot;chart&quot; ref=&#123;chartsRef[4]&#125;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/aside&gt;</span><br></pre></td></tr></table></figure><p>echarts里的option配置</p><p><img src="https://s2.loli.net/2024/09/26/29DpPhmGLj16kyb.jpg" alt="7d30adb4f9c8155b133b9b7b6a939fa.jpg"></p><p>注意：每一种图表形式的使用，都要按需导入；</p><p>针对areaStyle里的颜色，可以不导入echarts，直接colorStops来实现；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来：</span></span><br><span class="line"><span class="attr">areaStyle</span>: &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.8</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="keyword">new</span> echarts.<span class="property">graphic</span>.<span class="title class_">LinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, [&#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgb(128, 255, 165)&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgb(1, 191, 236)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后：</span></span><br><span class="line"><span class="attr">areaStyle</span>: &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.8</span>,</span><br><span class="line">  <span class="attr">color</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;linear&#x27;</span>, <span class="comment">// 线性渐变</span></span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">x2</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y2</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">colorStops</span>: [</span><br><span class="line">      &#123; <span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">&#x27;rgb(255, 191, 0)&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">offset</span>: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">&#x27;rgb(224, 62, 76)&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h1><p>.。。。。。待更新。。。。。。。</p><h2 id="补充-clip-path属性"><a href="#补充-clip-path属性" class="headerlink" title="补充 | clip-path属性"></a>补充 | clip-path属性</h2><p>CSS 中的 <code>clip-path</code> 属性允许你定义一个元素的可见区域。通过这个属性，你可以指定一个路径，在这个路径内的内容会被显示，而路径外的内容则会被隐藏。这是一个非常强大的工具，因为它可以用来创建各种复杂的形状和动态效果。</p><ol><li><p><strong>创建复杂形状</strong>：使用 <code>clip-path</code>，你可以轻松创建圆形、椭圆、多边形或者自定义路径（使用 SVG 路径语法）等形状。这对于设计先进的用户界面和特殊的图形效果非常有用。</p></li><li><p><strong>交互效果</strong>：你可以结合动画和过渡效果使用 <code>clip-path</code>，以实现视觉上吸引人的交互动画。例如，当用户悬停或点击元素时改变 <code>clip-path</code> 的形状。</p></li><li><p><strong>掩盖和显示内容</strong>：它可以被用来掩盖元素的某部分或只显示某部分，这在创建仪表板、卡片或其他包含隐藏详细信息的界面元素时尤其有用。</p></li></ol><p><strong>基本语法</strong>：<br>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: shape | none;</span><br></pre></td></tr></table></figure><br>  其中 <code>shape</code> 可以是以下几种类型：</p><ul><li><p><strong>圆形</strong>（<code>circle()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50%</span>);</span><br></pre></td></tr></table></figure><p>这会创建一个圆形剪裁区域，其中 <code>50%</code> 是圆的半径。</p></li><li><p><strong>椭圆</strong>（<code>ellipse()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(<span class="number">50%</span> <span class="number">25%</span>);</span><br></pre></td></tr></table></figure><p>这将创建一个椭圆剪裁区域，其中第一个值是水平半径，第二个值是垂直半径。</p></li><li><p><strong>多边形</strong>（<code>polygon()</code>）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">50%</span> <span class="number">100%</span>, <span class="number">0%</span> <span class="number">50%</span>);</span><br></pre></td></tr></table></figure><p>这将创建一个菱形剪裁区域，每个百分比对是多边形一个顶点的坐标。</p></li><li><p><strong>使用 URL</strong>（SVG 剪裁路径）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">url</span>(<span class="string">#clip-shape</span>);</span><br></pre></td></tr></table></figure><p>这里 <code>#clip-shape</code> 是 SVG 内的 <code>&lt;clipPath&gt;</code> 元素的 ID，允许你使用 SVG 的复杂路径定义剪裁形状。</p></li></ul><p>通过使用 <code>clip-path</code>，开发者可以在不需要额外图像或 SVG 文件的情况下，直接在 CSS 中创建视觉上吸引人的形状和效果。这使得页面加载更快，也使得动态效果的实现更为简便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/09/11/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%952/"/>
    <id>https://youxt-njnu.github.io/2024/09/11/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%952/</id>
    <published>2024-09-11T02:02:05.000Z</published>
    <updated>2024-10-05T12:02:34.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><p>🔁 后话2-callback 🍵</p><ul><li>unforms统一存shader里uniform的初始值</li></ul><p>🔁 后话1-callback 🍵</p><ul><li>构造位于半径为5的球面上的冲击点、冲击最大半径、冲击比例、之前的点位置、飞线的比例和长度</li></ul><p>安装dat.gui的库：<code>npm i dat.gui @types/dat.gui</code></p><p>添加进入gui；</p><p>gui设置隐藏，通过键盘H键唤起；</p><h1 id="飞线"><a href="#飞线" class="headerlink" title="飞线"></a>飞线</h1><p>🔁 后话1-callback 🍵</p><ul><li>取消注释</li></ul><p><img src="C:\Users\Xiangting\AppData\Roaming\Typora\typora-user-images\image-20240913170816909.png" alt="image-20240913170816909"></p><h3 id="制作飞线"><a href="#制作飞线" class="headerlink" title="制作飞线"></a>制作飞线</h3><p>初始化100个点，得到一条路径；添加index属性，形成起止正确的路径，加入trails</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeTrail</span> (idx) &#123;</span><br><span class="line">  <span class="keyword">let</span> pts = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100</span>*<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>); </span><br><span class="line">  <span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line">  g.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Float32BufferAttribute</span>(pts,<span class="number">3</span>));</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">LineDashedMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: params.<span class="property">colors</span>.<span class="property">gradOuter</span>,</span><br><span class="line">    <span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">onBeforeCompile</span>: <span class="function"><span class="params">shader</span> =&gt;</span> &#123;</span><br><span class="line">      shader.<span class="property">uniforms</span>.<span class="property">actionRatio</span> = impacts[idx].<span class="property">trailRatio</span>;</span><br><span class="line">      shader.<span class="property">uniforms</span>.<span class="property">lineLength</span> = impacts[idx].<span class="property">trailLength</span>;</span><br><span class="line">      shader.<span class="property">fragmentShader</span> = lineFragmentShader;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> l = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Line</span>(g,m);</span><br><span class="line">  l.<span class="property">userData</span>.<span class="property">idx</span> = idx;</span><br><span class="line">  <span class="title function_">setPath</span>(l,impacts[idx].<span class="property">prevPosition</span>,impacts[idx].<span class="property">impactPosition</span>);</span><br><span class="line">  trails.<span class="title function_">push</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置路径上点的位置和长度：传入当前路径、起点、终点、峰高、出现后经过几次弧度再进入后消失</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setPath</span> = (<span class="params">l, startPoint, endPoint, peakHeight,cycles</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">position</span>; <span class="comment">//预存点的最新位置</span></span><br><span class="line">  <span class="keyword">let</span> division = pos - <span class="number">1</span>; <span class="comment">//l上的分段数目</span></span><br><span class="line">  <span class="keyword">let</span> cycle = cycles || <span class="number">1</span>; <span class="comment">// cycle=4:↷↷↷↷</span></span><br><span class="line">  <span class="keyword">let</span> peak = peakHeight || <span class="number">1</span>; <span class="comment">//峰高</span></span><br><span class="line">  <span class="keyword">let</span> radius = startPoint.<span class="title function_">length</span>(); <span class="comment">// 对应球的半径</span></span><br><span class="line">  <span class="keyword">let</span> angle = startPoint.<span class="title function_">angleTo</span>(endPoint); <span class="comment">//起始点和终点的夹角</span></span><br><span class="line">  <span class="keyword">let</span> arcLength = radius * angle; <span class="comment">//弧长</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> diameterMinor = arcLength / <span class="title class_">Math</span>.<span class="property">PI</span>; <span class="comment">// 新圆的直径</span></span><br><span class="line">  <span class="keyword">let</span> radiusMinor = diameterMinor / <span class="number">2</span> / cycle; <span class="comment">// 考虑cycle下新圆的半径</span></span><br><span class="line">  <span class="keyword">let</span> peakRatio = peak / diameterMinor; <span class="comment">// 峰高比例</span></span><br><span class="line">  <span class="keyword">let</span> radiusMajor = radius + radiusMinor; <span class="comment">// 大圆的半径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> basisMajor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">setLength</span>(radiusMajor); <span class="comment">// trail的点基准1</span></span><br><span class="line">  <span class="keyword">let</span> basisMinor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">negate</span>().<span class="title function_">setLength</span>(radiusMinor); <span class="comment">// trail的点基准2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tri = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Triangle</span>(startPoint, endPoint, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>()); <span class="comment">// 三角形</span></span><br><span class="line">  <span class="keyword">let</span> nrm = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  tri.<span class="title function_">getNormal</span>(nrm); <span class="comment">// 拿到法线</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> v3Major = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">//里面的v3表示vec3 </span></span><br><span class="line">  <span class="keyword">let</span> v3Minor = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  <span class="keyword">let</span> v3Inter = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">  <span class="keyword">let</span> vFinal = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">// 里面v也可理解为varying</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=division;i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> divisionRatio = i / division; <span class="comment">// 分段比例</span></span><br><span class="line">    <span class="keyword">let</span> angleValue = divisionRatio * angle; <span class="comment">// 分段角度</span></span><br><span class="line">    v3Major.<span class="title function_">copy</span>(basisMajor).<span class="title function_">applyAxisAngle</span>(nrm, angleValue); <span class="comment">// 在basisMajor的基础上绕着法线旋转</span></span><br><span class="line">    v3Minor.<span class="title function_">copy</span>(basisMinor).<span class="title function_">applyAxisAngle</span>(nrm, angleValue+<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>*divisionRatio*cycle); <span class="comment">// 在basisMinor的基础上绕着法线旋转</span></span><br><span class="line">    v3Inter.<span class="title function_">addVectors</span>(v3Major, v3Minor); <span class="comment">// 两个向量相加</span></span><br><span class="line">    <span class="keyword">let</span> newLength = (v3Inter.<span class="title function_">length</span>() - radius) * peakRatio + radius; <span class="comment">// 新的长度</span></span><br><span class="line">    vFinal.<span class="title function_">copy</span>(v3Inter).<span class="title function_">setLength</span>(newLength); <span class="comment">// 设置新的长度</span></span><br><span class="line">    pos.<span class="title function_">setXYZ</span>(i,vFinal.<span class="property">x</span>,vFinal.<span class="property">y</span>,vFinal.<span class="property">z</span>); <span class="comment">// 设置新的位置</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新完了点数据后需要加上这句</span></span><br><span class="line">  pos.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  l.<span class="title function_">computeLineDistances</span>();  <span class="comment">// 计算每个顶点到起点的累加距离</span></span><br><span class="line">  l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br><span class="line">  impacts[l.<span class="property">userData</span>.<span class="property">idx</span>].<span class="property">trailLength</span>.<span class="property">value</span> = l.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">array</span>[<span class="number">99</span>];</span><br><span class="line">  l.<span class="property">material</span>.<span class="property">dashSize</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/28/GWszxuwCZIaV1EB.png" alt="202408281104602.png"></p><h4 id="飞线shader"><a href="#飞线shader" class="headerlink" title="飞线shader"></a>飞线shader</h4><p>下面是如何在你的 Vite 配置中添加对 <code>.glsl</code> 文件的支持的步骤：</p><ol><li>安装 <code>vite-plugin-glsl</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vite-plugin-glsl</span><br></pre></td></tr></table></figure></li><li>在你的 Vite 配置文件中（通常是 <code>vite.config.js</code> 或 <code>vite.config.ts</code>）添加插件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#x27;vite&#x27;</span><br><span class="line">import vue from &#x27;@vitejs/plugin-vue&#x27;</span><br><span class="line">import glsl from &#x27;vite-plugin-glsl&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">    glsl()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这样配置后，当你导入 <code>.glsl</code> 文件时，<code>vite-plugin-glsl</code> 将自动处理它们，确保 GLSL 代码被作为字符串正确导入，避免 JavaScript 解析错误。</p><p>确保在你的 Vue 组件或 JavaScript 文件中按照下面的方式导入 <code>.glsl</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import textFragmentShader from &#x27;./Shader/text.frag.glsl&#x27;</span><br><span class="line">import textVertexShader from &#x27;./Shader/text.vert.glsl&#x27;</span><br></pre></td></tr></table></figure><p>这些文件现在应该会被正确地作为字符串导入，可以直接使用在 Three.js 的 <code>ShaderMaterial</code> 中。这应该解决你遇到的关于 GLSL 代码导入的问题。</p><p>页面中导入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lineFragmentShader from &#x27;./line.frag.glsl&#x27;;</span><br></pre></td></tr></table></figure><p>shader内容：</p><p>actionRatio 代码中是0 _ 动画中修改 </p><p>vLineDistance &#x2F;&#x2F; 在使用 Three.js 的 LineDashedMaterial 时，确保顶点着色器正确地计算并传递 vLineDistance 变量到片元着色器是非常关键的，因为这个变量决定了线段的虚线效果。</p><p>totalSize 一整个没用到</p><p>lineLength 到起点的累积距离</p><p>这段代码是一个在 Three.js 中使用的 GLSL shader，具体是用来处理具有虚线效果的线条材料（<code>LineDashedMaterial</code>）。这个 shader 控制着如何根据距离和虚线模式显示线条的片段。</p><ul><li><strong>uniforms</strong> 是从 Three.js 的 JavaScript 代码传递到 shader 的变量。<ul><li><code>mediump float</code>: 精度指示符，表明浮点运算使用中等精度。</li><li><code>actionRatio</code>: 控制线条的动画或进度的参数。</li><li><code>lineLength</code>: 线条的总长度。</li><li><code>diffuse</code>: 线条的颜色。</li><li><code>opacity</code>: 线条的不透明度。</li><li><code>dashSize</code>: 单个虚线的长度。</li><li><code>totalSize</code>: 虚线和间隔的总和长度。</li></ul></li><li><strong>varying</strong><ul><li><code>vLineDistance</code>: 表示当前片段在整个线条中的位置。</li></ul></li></ul><p><strong>虚线计算</strong>:</p><ul><li>首先计算出当前应显示的虚线位置。</li><li>根据 <code>vLineDistance</code> 和虚线参数计算出当前片段是否在虚线中还是在空白间隔中。如果在间隔中，使用 <code>discard</code> 抛弃这个片段，不进行渲染。</li><li>使用渐变 (<code>grad</code>) 来处理虚线的边缘，使得虚线边缘平滑过渡。</li></ul><ol><li>顶点着色器中的计算:</li></ol><p>在顶点着色器中，每个顶点的位置被用来计算它在整条线中的相对位置或距离，这个距离累计到 vLineDistance。例如，如果线条由多个段组成，每个段的长度会被累加到起点距离，直到当前顶点的位置。</p><ol start="2"><li>传递到片段着色器:</li></ol><p>这个计算出的距离 (vLineDistance) 作为一个 varying 变量，被传递到片段着色器。在图形管线中，顶点着色器处理后的结果（如位置、颜色、距离等）会通过插值传递到片段着色器。</p><ol start="3"><li>在片段着色器中，vLineDistance 用来确定每个片段是否应该被渲染为虚线的一部分：</li></ol><blockquote><p>float currPos &#x3D; (lineLength + dashSize) * actionRatio;<br>这里 currPos 表示虚线开始的位置，是通过线条总长度、虚线大小和动画比例 (actionRatio) 计算的。actionRatio 可能用于动态调整虚线的显示，比如滚动效果。<br>确定片段位置:</p></blockquote><blockquote><p>float d &#x3D; (vLineDistance + halfDash) - currPos;<br>这个计算检查当前片段的位置（vLineDistance + halfDash）相对于当前虚线开始位置的偏移量。halfDash 用于调整计算到虚线中心的距离。<br>判断是否在虚线内部:</p></blockquote><blockquote><p>if (abs(d) &gt; halfDash ) discard;如果偏移量大于 halfDash，则表示当前片段不在虚线内部，应该被丢弃（不渲染）。这样，只有在虚线范围内的片段会被渲染，形成断续的线条效果。</p></blockquote><ol start="4"><li>渐变边缘的处理:</li></ol><p>float grad &#x3D; ((vLineDistance + halfDash) - (currPos - halfDash)) &#x2F; halfDash; 这里 grad 用于计算当前片段在虚线边缘的位置，用于实现边缘的渐变效果。这可以让虚线的开始和结束更加平滑，不会突然截断。</p><p><img src="https://s2.loli.net/2024/09/11/yfOMo2NWJZVekbq.jpg" alt="ac03418e3341f086f3b780056121b39.jpg"></p><h4 id="补充-negate"><a href="#补充-negate" class="headerlink" title="补充 | negate"></a>补充 | <code>negate</code></h4><p><code>negate()</code> 是一个 Three.js 中的向量方法，它用来将向量中的每个分量取反，也就是每个分量乘以 -1。这样做的目的是将向量的方向反转。具体到这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> basisMinor = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>().<span class="title function_">copy</span>(startPoint).<span class="title function_">negate</span>().<span class="title function_">setLength</span>(radiusMinor);</span><br></pre></td></tr></table></figure><ul><li><code>new THREE.Vector3()</code> 创建一个新的三维向量，默认为 (0, 0, 0)。</li><li><code>.copy(startPoint)</code> 将 <code>startPoint</code> 的值复制到这个新的向量中。</li><li><code>.negate()</code> 将复制后的向量中的每个分量乘以 -1，实现向量方向的反转。</li><li><code>.setLength(radiusMinor)</code> 将反转后的向量的长度设置为 <code>radiusMinor</code>。</li></ul><p>这样，<code>basisMinor</code> 就变成了一个方向与 <code>startPoint</code> 相反、长度为 <code>radiusMinor</code> 的向量。</p><h4 id="补充-applyAxisAngle"><a href="#补充-applyAxisAngle" class="headerlink" title="补充 | applyAxisAngle"></a>补充 | <code>applyAxisAngle</code></h4><p>在 Three.js 中，<code>applyAxisAngle</code> 方法用于将一个旋转应用到一个向量上。这个方法接受两个参数：一个轴向量和一个角度。它的作用是围绕给定的轴向量旋转原向量指定的角度。</p><ol><li><strong>轴向量</strong> (<code>axis</code>): 这是一个标准化的三维向量，指定了旋转的轴。例如，若轴向量为 <code>(0, 1, 0)</code>，则表示围绕 y 轴进行旋转。</li><li><strong>角度</strong> (<code>angle</code>): 这是旋转的角度，单位是弧度。正值表示逆时针旋转，负值表示顺时针旋转（根据右手规则）。</li></ol><p>当你调用 <code>applyAxisAngle</code> 方法时，它会改变调用它的向量的方向，但保持向量的长度不变。这种旋转是通过右手规则来定义的，即如果你的右手拇指指向轴向量的方向，那么四指的卷曲方向定义了正旋转方向。</p><p>在 Three.js 中使用 <code>applyAxisAngle</code> 方法进行旋转时，向量是绕通过原点 (0, 0, 0) 的轴进行旋转的。轴向量只定义了旋转的方向和轴线，而不是旋转的位置。因此，这种旋转总是认为轴向量通过三维空间的原点。</p><p>旋转的中心点是坐标系统的原点 (0, 0, 0)。向量从它当前的位置开始，绕通过原点的轴旋转。这意味着：</p><ul><li>如果向量的一个端点位于原点，旋转将直接改变向量的方向，而长度保持不变。</li><li>如果向量的一个端点不在原点，向量会在想象中被拉直至原点，然后绕轴旋转，再放回原位置。</li></ul><p>如果你需要绕一个不在原点的点旋转向量，你需要先将系统平移到那个点变成新的原点，执行旋转，然后再平移回去。这可以通过以下步骤完成：</p><ol><li><strong>平移</strong> ：将向量和旋转中心点一同平移到原点附近。</li><li><strong>旋转</strong> ：在新的位置应用旋转。</li><li><strong>逆平移</strong> ：将旋转后的向量移回原始位置。</li></ol><h4 id="补充-needsUpdate"><a href="#补充-needsUpdate" class="headerlink" title="补充 | needsUpdate"></a>补充 | needsUpdate</h4><p>在 Three.js 中，<code>needsUpdate</code> 属性用于告诉引擎某个对象的数据已经改变，需要重新计算或重新上传到 GPU。这个属性常见于与几何体（<code>Geometry</code> 或 <code>BufferGeometry</code>）、材料（<code>Material</code>）、纹理（<code>Texture</code>）等相关的对象。</p><p>当你修改了几何体的顶点数据、纹理的内容、或者材料的参数等，这些改变不会自动反映在渲染的对象上，除非你明确地告诉 Three.js 这些数据已经更新。<code>needsUpdate</code> 属性就是用于这种通知。</p><p>示例 - 几何体顶点数据更新</p><p>假设你更改了一个几何体的顶点位置数据，你需要设置对应属性的 <code>needsUpdate</code> 为 <code>true</code>，以确保这些改变被应用到下一次渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改几何体顶点位置</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span>.<span class="title function_">setXYZ</span>(index, newX, newY, newZ);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记顶点位置数据为需要更新</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span>.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例 - 纹理内容更新</p><p>如果你修改了纹理的图像数据，你同样需要设置 <code>needsUpdate</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载一个新的图像到纹理</span></span><br><span class="line">texture.<span class="property">image</span> = newImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉Three.js纹理已更新</span></span><br><span class="line">texture.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例 - 材料属性更新</p><p>当改变材料的一些属性（如颜色、透明度等）后，如果要立即反映这些变化，同样需要更新 <code>needsUpdate</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改材料的颜色</span></span><br><span class="line">material.<span class="property">color</span>.<span class="title function_">setHex</span>(<span class="number">0xff0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记材料需要更新</span></span><br><span class="line">material.<span class="property">needsUpdate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="补充-computeLineDistances"><a href="#补充-computeLineDistances" class="headerlink" title="补充 | computeLineDistances"></a>补充 | <code>computeLineDistances</code></h4><p>在 Three.js 中，<code>Mesh</code> 对象本身并没有 <code>computeLineDistances()</code> 方法；这个方法是属于 <code>Line</code> 类的。<code>Line</code> 类用于创建和处理线段对象，在 3D 场景中表示由多个点连接而成的直线或折线。</p><p>该方法用于计算线段对象中每个顶点到线起点的累计距离，并将这些距离存储在线段的 <code>lineDistances</code> 属性中。这个功能通常与线性材料（<code>LineDashedMaterial</code>）一起使用，用来创建虚线效果。<code>LineDashedMaterial</code> 需要这些距离来正确地渲染每段虚线。</p><p>在 Three.js 中，当你使用 <code>computeLineDistances()</code> 方法计算线段（由 <code>THREE.Line</code> 或 <code>THREE.LineSegments</code> 类创建的对象）的每个顶点到起点的距离时，这些距离会存储在 <code>geometry.attributes.lineDistance</code> 的 <code>array</code> 属性中。这个数组中的每个元素代表从起点到对应顶点的累积距离。</p><p>数组索引是从 0 开始的。因此，数组中的第一个元素（索引 0）对应第一个顶点（通常是线段的起点），第二个元素（索引 1）对应第二个顶点，依此类推。索引 99 的元素就是数组中的第 100 个元素，对应于你的线段的第 100 个顶点。在 <code>array[99]</code> 中获取的值表示从线段的起点到第 100 个顶点的累积距离。</p><p>注意事项：</p><ul><li>如果你更改了线段的顶点位置，需要重新调用 <code>computeLineDistances()</code> 方法来更新距离数据。</li><li>这个方法仅对 <code>THREE.Line</code> 或 <code>THREE.LineSegments</code> 对象有效，对 <code>Mesh</code> 对象不适用。</li></ul><h4 id="补充-预制shader"><a href="#补充-预制shader" class="headerlink" title="补充 | 预制shader"></a>补充 | 预制shader</h4><p>在Three.js的shader编程中，<code>#include</code> 语句用于插入共用的代码块，这些代码块通常封装了一些常用的函数和变量定义，使得shader的编写更加模块化和可复用。下面是你提到的几个常见的include文件的用途：</p><ol><li><p><strong><code>&lt;common&gt;</code></strong>:</p><ul><li>这个文件包括了一些常用的数学函数和宏定义，比如计算线性插值、饱和度计算等，还有一些常用的常量定义，例如PI的值等。</li></ul></li><li><p><strong><code>&lt;color_pars_fragment&gt;</code></strong>:</p><ul><li>这个文件定义了与颜色处理相关的参数和函数，比如处理顶点颜色、漫反射等。</li></ul></li><li><p><strong><code>&lt;fog_pars_fragment&gt;</code></strong>:</p><ul><li>用于定义和计算雾效果(fog)的参数，使得物体在雾中逐渐消失的效果可以在shader中实现。</li></ul></li><li><p><strong><code>&lt;logdepthbuf_pars_fragment&gt;</code></strong>:</p><ul><li>如果启用了logarithmic depth buffer，这个文件包含了相关的实现，用来改善远距离渲染时的深度精度问题。</li></ul></li><li><p><strong><code>&lt;clipping_planes_pars_fragment&gt;</code></strong>:</p><ul><li>这个文件提供了剪裁平面的支持，使得可以在shader中处理剪裁逻辑，仅渲染剪裁平面允许的部分。</li></ul></li></ol><p>要查找Three.js中可用的所有shader chunks，最好的方法是直接查看Three.js的源代码。在GitHub上的Three.js库中，这些shader chunk文件位于<code>src/renderers/shaders/ShaderChunk/</code>目录下。</p><h3 id="飞线动画"><a href="#飞线动画" class="headerlink" title="飞线动画"></a>飞线动画</h3><p>内容结构：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setTrailAnimation</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tweens = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;maxImpactAmount;i++) &#123;</span><br><span class="line">      tweens.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">runTween</span>: <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    tweens.<span class="title function_">forEach</span>(<span class="function"><span class="params">t</span>=&gt;</span>t.<span class="title function_">runTween</span>());</span><br><span class="line">    <span class="title function_">createPoints</span>(); <span class="comment">// 因为runTween会影响到points的效果</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>for循环里的设置</p><p>更新了impacts，同时也影响到了球体的效果；</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxImpactAmount; i++) &#123;</span><br><span class="line">  tweens.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">runTween</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> path = trails[i]; <span class="comment">// 当前路径</span></span><br><span class="line">      <span class="keyword">let</span> speed = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">let</span> len = path.<span class="property">geometry</span>.<span class="property">attributes</span>.<span class="property">lineDistance</span>.<span class="property">array</span>[<span class="number">99</span>];</span><br><span class="line">      <span class="keyword">let</span> dur = len / speed; <span class="comment">// 持续时间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> tweenTrail = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line">        .<span class="title function_">to</span>(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, dur * <span class="number">1000</span>)</span><br><span class="line">        .<span class="title function_">onUpdate</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          impacts[i].<span class="property">trailRatio</span>.<span class="property">value</span> = val.<span class="property">value</span>; <span class="comment">// 通过Tween来控制trailRatio/actionRatio</span></span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">var</span> tweenImpact = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line">        .<span class="title function_">to</span>(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randInt</span>(<span class="number">2500</span>, <span class="number">5000</span>))</span><br><span class="line">        .<span class="title function_">onUpdate</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          uniformsSettings.<span class="property">impacts</span>.<span class="property">value</span>[i].<span class="property">impactRatio</span> = val.<span class="property">value</span>; <span class="comment">// 通过Tween来控制impactRatio</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">onComplete</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          impacts[i].<span class="property">prevPosition</span>.<span class="title function_">copy</span>(impacts[i].<span class="property">impactPosition</span>);</span><br><span class="line">          impacts[i].<span class="property">impactPosition</span>.<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>);</span><br><span class="line">          <span class="title function_">setPath</span>(path, impacts[i].<span class="property">prevPosition</span>, impacts[i].<span class="property">impactPosition</span>, <span class="number">1</span>);</span><br><span class="line">          uniformsSettings.<span class="property">impacts</span>.<span class="property">value</span>[i].<span class="property">impactMaxRadius</span> = <span class="number">5</span> * <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloat</span>(<span class="number">0.5</span>, <span class="number">0.75</span>);</span><br><span class="line">          tweens[i].<span class="title function_">runTween</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      tweenTrail.<span class="title function_">chain</span>(tweenImpact);</span><br><span class="line">      tweenTrail.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅴ</title>
    <link href="https://youxt-njnu.github.io/2024/09/04/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/"/>
    <id>https://youxt-njnu.github.io/2024/09/04/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</id>
    <published>2024-09-04T01:40:26.000Z</published>
    <updated>2024-09-04T14:03:37.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-patterns"><a href="#记录-patterns" class="headerlink" title="记录-patterns"></a>记录-patterns</h1><p>fract(),取小数部分；</p><p>实现pattern的绘制：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circle(<span class="keyword">in</span> <span class="type">vec2</span> _st, <span class="keyword">in</span> <span class="type">float</span> _radius)&#123;</span><br><span class="line">    <span class="type">vec2</span> l = _st-<span class="type">vec2</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>-<span class="built_in">smoothstep</span>(_radius-(_radius*<span class="number">0.01</span>),</span><br><span class="line">                        _radius+(_radius*<span class="number">0.01</span>),</span><br><span class="line">                         <span class="built_in">dot</span>(l,l)*<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> pattern2d(<span class="keyword">in</span> <span class="type">float</span> x, <span class="keyword">in</span> <span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    st.x *= x;   </span><br><span class="line">    st.y *= y; <span class="comment">// Scale up the space by 3</span></span><br><span class="line">    st = <span class="built_in">fract</span>(st); <span class="comment">// Wrap around 1.0</span></span><br><span class="line">    </span><br><span class="line">    color = <span class="type">vec3</span>(st,<span class="number">0.0</span>);</span><br><span class="line">    color = <span class="type">vec3</span>(circle(st,<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec3</span> color = pattern2d(<span class="number">2.1</span>,<span class="number">5.</span>);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在pattern上，结合旋转、平移、缩放，来丰富pattern</p><p>判断奇偶行，可以通过mod取余，加上三元运算符或step，来形成0和1的判断；</p><p>Truchet Tiles的绘制，通过给不同的区间设置index，根据index来判断旋转多少度；</p><h1 id="记录-random"><a href="#记录-random" class="headerlink" title="记录-random"></a>记录-random</h1><p>rand()得到的类似于fract(sin(…))，在一片随机内，部分地方存在着较大波动；</p><p>利用fract, sin, dot来实现2D下的随机；</p><p>可以构建grid形态下的随机灰度填充；</p><h1 id="记录-noise"><a href="#记录-noise" class="headerlink" title="记录-noise"></a>记录-noise</h1><p>mix()进行线性插值；</p><p>在一些 noise 的应用中你会发现程序员喜欢用他们自己的三次多项式函数（func），而不是用 smoothstep()。</p><p>mix(rand(i),rand(i+1.0),func);</p><p>二维插值；</p><p>value noise和gradient noise的区别； simplex noise</p><p>结合distance field来绘制；</p><p>三维插值；</p><h1 id="记录-Cellular-Noise"><a href="#记录-Cellular-Noise" class="headerlink" title="记录-Cellular Noise"></a>记录-Cellular Noise</h1><p>求纹理空间下的坐标，到指定坐标的最小距离，加到颜色上，进行呈现；</p><p>类似于Voronoi图；</p><p>通过遍历周边8个格网，进行综合；</p><p>Voronoi算法；</p><p>voro-nose;</p><h1 id="记录-Fractal-Brownian-Motion-x2F-Fractal-Noise"><a href="#记录-Fractal-Brownian-Motion-x2F-Fractal-Noise" class="headerlink" title="记录-Fractal Brownian Motion&#x2F;Fractal Noise"></a>记录-Fractal Brownian Motion&#x2F;Fractal Noise</h1><p>利用sin函数，修改frequency和amplitude</p><blockquote><p>通过在循环（循环次数为 octaves，一次循环为一个八度）中叠加噪声，并以一定的倍数（lacunarity，间隙度）连续升高频率，同时以一定的比例（gain，增益）降低 噪声 的振幅，最终的结果会有更好的细节。这项技术叫“分形布朗运动（fractal Brownian Motion）”（fBM），或者“分形噪声（fractal noise）”</p></blockquote><blockquote><p>这项技术被广泛地应用于构造程序化风景。fBm 的自相似性能够很完美地模拟山脉，因为山脉形成过程中的腐蚀形成了这种不同尺度上的自相似性</p></blockquote><p>fbm构造山谷和山脊 —— turbulence效果</p><p>使用fbm模拟fbm —— 云的效果</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>图像处理</p><ul><li>纹理</li><li>图像处理</li><li>卷积核</li><li>滤镜</li><li>其他效果</li></ul><p>模拟</p><ul><li>乒乓</li><li>Conway生命游戏</li><li>水波</li><li>水彩</li><li>反应扩散</li></ul><p>3D 图形</p><ul><li>灯光</li><li>法线贴图</li><li>凹凸贴图</li><li>Ray marching</li><li>环境贴图 (spherical and cube)</li><li>折射和反射</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>three+react|加自己模型</title>
    <link href="https://youxt-njnu.github.io/2024/09/02/three-%E5%8A%A0%E8%87%AA%E5%B7%B1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://youxt-njnu.github.io/2024/09/02/three-%E5%8A%A0%E8%87%AA%E5%B7%B1%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-09-02T12:37:05.000Z</published>
    <updated>2024-09-03T01:21:02.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加自己的模型"><a href="#添加自己的模型" class="headerlink" title="添加自己的模型"></a>添加自己的模型</h1><p>前言，在<a href="https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%981/">该项目</a>中加自己的模型，及问题解决；</p><p>先sketchfab上下载模型，在unity里调整位置、贴图、材质、动画，形成prefab；</p><p>利用<a href="https://github.com/Plattar/gltf-exporter?tab=readme-ov-file">插件</a>，导出为gltf；”E:\PersonalCV\models\v1.142.0-unity.unitypackage”</p><p>在vite.config.ts里加入<code>assetsInclude: [&#39;**/*.glb&#39;,&#39;**/*.gltf&#39;],</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useGLTF &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/drei&quot;</span></span><br><span class="line"><span class="keyword">import</span> word2D <span class="keyword">from</span> <span class="string">&#x27;../assets/3d/world_2d/world_2d.gltf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Map2D</span> = (<span class="params">&#123; ...props &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> gltf = <span class="title function_">useGLTF</span>(word2D);</span><br><span class="line">  <span class="keyword">const</span> scene = gltf.<span class="property">scene</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">mesh</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">primitive</span> <span class="attr">object</span>=<span class="string">&#123;scene&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">mesh</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Map2D</span></span><br></pre></td></tr></table></figure><p>法线模型里的顶点，x的坐标都是正确数值的相反数，例如这个<a href="https://sketchfab.com/3d-models/cartoon-low-poly-world-map-e87fa1e143f84348a915b7fe1376d957">模型</a>下下来就这样问题：</p><ol><li>blender里，右上角切换object Mode为Edit Mode</li><li>A全选所有物体</li><li>Mesh -&gt;Mirror-&gt;X Global</li><li>按 <code>Ctrl + A</code> 并选择 <code>All Transforms</code>，应用变换</li></ol><p><img src="https://s2.loli.net/2024/09/02/mZD8AeFVyHXajiz.png" alt="image.png"></p><p>补充，针对法线反了的，1.2.4不变，3 mesh-&gt;Normals-&gt;Flip</p><p>针对贴图反了的，例如这个作者的很多<a href="https://skfb.ly/orJVW">模型</a>，PS里 图像-&gt;图像旋转-&gt;垂直旋转画布&#x2F;水平翻转画布</p><p>此外，在项目中打包的时候，只会打包gltf这一个文件，其附属的bin和png文件会落单；<br>这个时候我采用的是把gltf相关的都放在gltfModels文件夹，将gltfModels文件夹放到了public目录下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;添加自己的模型&quot;&gt;&lt;a href=&quot;#添加自己的模型&quot; class=&quot;headerlink&quot; title=&quot;添加自己的模型&quot;&gt;&lt;/a&gt;添加自己的模型&lt;/h1&gt;&lt;p&gt;前言，在&lt;a href=&quot;https://youxt-njnu.github.io/2024/02/</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅳ</title>
    <link href="https://youxt-njnu.github.io/2024/08/28/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/"/>
    <id>https://youxt-njnu.github.io/2024/08/28/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</id>
    <published>2024-08-28T07:55:26.000Z</published>
    <updated>2024-09-04T01:40:33.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-2D-Matrics"><a href="#记录-2D-Matrics" class="headerlink" title="记录-2D Matrics"></a>记录-2D Matrics</h1><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>利用u_time, sin, cos构造移动，加到st；通过cross把这种移动突出出来；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">// _size=vec2(width,height)</span><br><span class="line">float box(in vec2 _st, in vec2 _size)&#123;</span><br><span class="line">    _size = vec2(0.5) - _size*0.5;</span><br><span class="line">    vec2 uv = smoothstep(_size,</span><br><span class="line">                        _size+vec2(0.01),</span><br><span class="line">                        _st);</span><br><span class="line">    uv *= smoothstep(_size,</span><br><span class="line">                    _size+vec2(0.001),</span><br><span class="line">                    vec2(1.0)-_st);</span><br><span class="line">    return uv.x*uv.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// input: st, crossSize</span><br><span class="line">float cross(in vec2 _st, float _size)&#123;</span><br><span class="line">    return  box(_st, vec2(_size,_size/4.)) +</span><br><span class="line">            box(_st, vec2(_size/4.,_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // To move the cross we move the space</span><br><span class="line">    vec2 translate = vec2(cos(u_time),sin(u_time));</span><br><span class="line">    st += translate*0.3;</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.154)); // 突出translate中心点的移动</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*GfW3IgV8F9bvbg7OijESlA.gif" alt="img"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define PI 3.14159265359</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">mat2 rotate2d(float _angle)&#123;</span><br><span class="line">    return mat2(cos(_angle),-sin(_angle),</span><br><span class="line">                sin(_angle),cos(_angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float box(in vec2 _st, in vec2 _size)&#123;</span><br><span class="line">    _size = vec2(0.5) - _size*0.5;</span><br><span class="line">    vec2 uv = smoothstep(_size,</span><br><span class="line">                        _size+vec2(0.001),</span><br><span class="line">                        _st);</span><br><span class="line">    uv *= smoothstep(_size,</span><br><span class="line">                    _size+vec2(0.001),</span><br><span class="line">                    vec2(1.0)-_st);</span><br><span class="line">    return uv.x*uv.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float cross(in vec2 _st, float _size)&#123;</span><br><span class="line">    return  box(_st, vec2(_size,_size/4.)) +</span><br><span class="line">            box(_st, vec2(_size/4.,_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // move space from the center to the vec2(0.0)</span><br><span class="line">    // st从0~1变成-0.5~0.5</span><br><span class="line">    st -= vec2(0.5);</span><br><span class="line">    // rotate the space,左乘，传入角度</span><br><span class="line">    st = rotate2d( sin(u_time)*1.*PI ) * st;</span><br><span class="line">    // move it back to the original place</span><br><span class="line">    st += vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.4));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*JaawntaOxPEcTdTQAVGs7A.gif" alt="img"></p><p>组合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // To move the cross we move the space</span><br><span class="line">    vec2 translate = vec2(cos(u_time),sin(u_time));</span><br><span class="line">    st += translate*0.35;</span><br><span class="line">  </span><br><span class="line">    st-=vec2(0.5);</span><br><span class="line">    st = rotate2d(u_time*PI)* st;</span><br><span class="line">    st+=vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.25));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*oGGqsWHMYC5C5PXEk6NUcg.gif" alt="img"></p><p>缩放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    st -= vec2(0.5);</span><br><span class="line">    st = scale( vec2(sin(u_time)+1.704) ) * st;</span><br><span class="line">    st += vec2(0.5);</span><br><span class="line"></span><br><span class="line">    // Show the coordinates of the space on the background</span><br><span class="line">    color = vec3(st.x,st.y,0.0);</span><br><span class="line"></span><br><span class="line">    // Add the shape on the foreground</span><br><span class="line">    color += vec3(cross(st,0.2));</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于数字 <code>1.704</code> 的影响：</p><ol><li><strong>缩放调整</strong> ：</li></ol><ul><li><code>sin(u_time) + 1.704</code>：这个表达式通过添加 <code>1.704</code> 来确保 <code>sin</code> 函数的结果（范围在 [-1, 1]）永远是正的，因此 <code>sin(u_time) + 1.704</code> 的结果范围大约在 [0.704, 2.704]。</li><li>这个范围决定了 <code>scale</code> 函数的缩放系数，影响了 <code>st</code> 坐标的伸缩。当你增大 <code>1.704</code>，实际上是在增加最小缩放系数的基线，使动画变得不那么剧烈。</li></ul><ol><li><strong>视觉效果</strong> ：</li></ol><ul><li>当 <code>1.704</code> 增大时，缩放变化的幅度减少，<strong>因为 <code>sin(u_time)</code> 的变动被一个较大的常数稳定了。这导致视觉效果的动态变化较少，从而效果不那么明显</strong>。</li></ul><ol><li><strong>周期性变化</strong> ：</li></ol><ul><li><code>sin</code> 函数是周期性的，其变化对整个场景的动态变化至关重要。增大 <code>1.704</code> 的值降低了 <code>sin</code> 函数变化对整体缩放的影响，从而使得效果变化不那么显著。</li></ul><p>st &#x3D; scale( vec2(-0.1) ) * st;和st &#x3D; scale( vec2(0.1) ) * st;的十字效果是一样的，背景效果翻转了(左正右负)；st &#x3D; scale( vec2(0.) ) * st; 这个时候页面全白；</p><p>所以缩放调整数字大于1或小于-1之下，都是小幅度的缩放；</p></blockquote><p><img src="https://s2.loli.net/2024/08/28/dw31YJQyHomFI8A.png" alt="image.png"></p><p>颜色空间RGB和YUV</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">// YUV to RGB matrix</span><br><span class="line">mat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,</span><br><span class="line">                    1.0, -0.39465, -0.58060,</span><br><span class="line">                    1.0, 2.03211, 0.0);</span><br><span class="line"></span><br><span class="line">// RGB to YUV matrix</span><br><span class="line">mat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722,</span><br><span class="line">                    -0.09991, -0.33609, 0.43600,</span><br><span class="line">                    0.615, -0.5586, -0.05639);</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // UV values goes from -1 to 1</span><br><span class="line">    // So we need to remap st (0.0 to 1.0)</span><br><span class="line">    st -= 0.5;  // becomes -0.5 to 0.5</span><br><span class="line">    st *= 2.0;  // becomes -1.0 to 1.0</span><br><span class="line"></span><br><span class="line">    // we pass st as the y &amp; z values of</span><br><span class="line">    // a three dimensional vector to be</span><br><span class="line">    // properly multiply by a 3x3 matrix</span><br><span class="line">    color = yuv2rgb * vec3(0., st.x, st.y);</span><br><span class="line">    //color = rgb2yuv * vec3(0., st.x, st.y);</span><br><span class="line">  </span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/28/gLFMGhyQDfzAo2k.png" alt="image.png"></p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p><a href="https://www.pinterest.com/patriciogonzv/hud-fui/">790 HUD &amp; FUI ideas | head up display, user interface, interface design (pinterest.com)</a></p><p><a href="https://www.shadertoy.com/view/4s2SRt">Oblivion radar (shadertoy.com)</a></p><p><a href="https://lygia.xyz/space">LYGIA Shader Library</a></p><p><a href="https://patriciogonzalezvivo.com/">Patricio Gonzalez Vivo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>three案例实操|赛博风大屏Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/08/28/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%951/"/>
    <id>https://youxt-njnu.github.io/2024/08/28/three-%E8%B5%9B%E5%8D%9A%E9%A3%8E%E5%A4%A7%E5%B1%8F%E8%AE%B0%E5%BD%951/</id>
    <published>2024-08-28T03:12:05.000Z</published>
    <updated>2024-10-05T12:02:36.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考案例：<a href="https://dragonir.github.io/3d/#/earthDigital">https://dragonir.github.io/3d/#/earthDigital</a></p><h1 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h1><p>react+vite+three.js+scss</p><p>目录：</p><p>EarthDigital</p><p>–images</p><p>—-earth.jpg</p><p>–index.jsx</p><p>–index.scss</p><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><p>先导入些基本的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Three</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">OrbitControls</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/controls/OrbitControls&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mergeGeometries &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/utils/BufferGeometryUtils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> earthImg <span class="keyword">from</span> <span class="string">&#x27;/src/assets/3d/EarthDigital/images/earth.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure><p>把项目架子搭起来：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">index</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;earth-digital&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">&#123;canvasRef&#125;</span> <span class="attr">className</span>=<span class="string">&quot;webgl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&quot;hud-header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">aside</span> <span class="attr">className</span>=<span class="string">&quot;hud-aside-left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">aside</span> <span class="attr">className</span>=<span class="string">&quot;hud-aside-right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">footer</span> <span class="attr">className</span>=<span class="string">&quot;hud-footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;background&quot;</span>&gt;</span>section<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> index</span><br></pre></td></tr></table></figure><p>一些前置变量和常规函数：—— initThree(), animate(), handleResize()</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scene = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> camera = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> renderer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> orbitControls = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> earth = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> canvasRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">initThree</span>();</span><br><span class="line">  <span class="title function_">animate</span>();</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>场景初始化：—— scene, camera, renderer, orbitControls</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initThree</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  scene = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Scene</span>();</span><br><span class="line">  camera = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">45</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">50</span>);</span><br><span class="line">  camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15.5</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(camera);</span><br><span class="line"></span><br><span class="line">  renderer = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">WebGLRenderer</span>(&#123;</span><br><span class="line">    <span class="attr">canvas</span>: canvasRef.<span class="property">current</span>,</span><br><span class="line">    <span class="attr">antialias</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">alpha</span>: <span class="literal">true</span> <span class="comment">// transparent background</span></span><br><span class="line">  &#125;);</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  renderer.<span class="title function_">setPixelRatio</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>, <span class="number">2</span>));</span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line"></span><br><span class="line">  orbitControls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, renderer.<span class="property">domElement</span>);</span><br><span class="line">  orbitControls.<span class="property">enableDamping</span> = <span class="literal">true</span>;</span><br><span class="line">  orbitControls.<span class="property">enablePan</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上动画：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 更新tween</span></span><br><span class="line">  <span class="comment">// TWEEN.update();</span></span><br><span class="line">  <span class="comment">// 模型动画</span></span><br><span class="line">  <span class="comment">// earth.rotation.y += 0.001;</span></span><br><span class="line">  renderer &amp;&amp; scene &amp;&amp; camera &amp;&amp; renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上窗体适应：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>();</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大地球模型"><a href="#大地球模型" class="headerlink" title="大地球模型"></a>大地球模型</h1><p>加入个函数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">initThree</span>();</span><br><span class="line">  <span class="title function_">createPoints</span>();</span><br><span class="line">  <span class="title function_">animate</span>();</span><br><span class="line"> ......</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="球体上的点"><a href="#球体上的点" class="headerlink" title="球体上的点"></a>球体上的点</h2><p>添加前置变量：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="title function_">createPoints</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> rad = <span class="number">5</span>; <span class="comment">// 球体半径</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">75000</span>; <span class="comment">// 球体上的点数量</span></span><br><span class="line">    <span class="keyword">let</span> dlong = <span class="title class_">Math</span>.<span class="property">PI</span> * (<span class="number">3</span> - <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">5</span>)); <span class="comment">// 经度的增量</span></span><br><span class="line">    <span class="keyword">let</span> dz = <span class="number">2</span> / counter; <span class="comment">// 纬度的增量，也就是z轴的增量</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="number">1</span>- dz / <span class="number">2</span>; <span class="comment">// 初始z值</span></span><br><span class="line">    <span class="keyword">let</span> long = <span class="number">0</span>; <span class="comment">// 初始经度</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span>; <span class="comment">// xy平面上的径向半径，类似于x^2+y^2=r^2(勾股三角),r^2+z^2=1(球半径，先1，后缩放至rad)</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>(); <span class="comment">// 用于存xyz的坐标</span></span><br><span class="line">    <span class="keyword">let</span> sph = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Spherical</span>(); <span class="comment">// 构建把上面的转换成球体坐标</span></span><br><span class="line">    <span class="keyword">let</span> dummyObj = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Object3D</span>(); <span class="comment">// 用于调整后续球面上plane的位置和朝向</span></span><br><span class="line">    <span class="keyword">let</span> geoms = []; <span class="comment">// 存储所有的plane</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> earthTexture = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(earthImg);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>为啥设置经度增量为上式子？</p><blockquote><p>经度增量设置为 <code>Math.PI * (3 - Math.sqrt(5))</code> 实际上是基于黄金角，这种方法常用于在球面上分布点以达到尽可能均匀的覆盖。这个值与黄金分割有关，具体如下：</p><ul><li><strong>黄金分割数</strong> (φ) 约为 1.618033988749895。</li><li>但在这里使用的是 <code>3 - Math.sqrt(5)</code>，计算结果大约为 0.7639320225002102，它是黄金分割数的一种数学转换，更具体地说，这个值实际上等于 ( 2 - \phi )。</li><li>当你将这个值乘以 (\pi) （圆周率），得到的角度是通过黄金分割原理计算得来的。这个角度有助于在球面上均匀地分布点，因为它避免了经纬线的对齐，从而在视觉上看起来更为均匀。</li></ul><p>黄金角是黄金分割数在圆上的应用。在自然界中，例如向日葵的种子排列、松果的鳞片布局等，都可以见到黄金角的应用。它能够优化空间利用率并减少重叠，因此在算法生成均匀分布的点时也经常使用这一角度。</p><p>在球面分布点时使用黄金角可以避免聚类并尽可能覆盖整个球面。这样的排列减少了任何给定区域内点过多聚集的情况，从而使点的分布更加均匀，这对于很多涉及到空间分布优化的领域，如计算机图形学、地理信息系统等是非常有用的。</p></blockquote><p>为什么z的初始值设置为这个let z &#x3D; 1 - dz &#x2F; 2;，而不是从0开始</p><blockquote><p>在构建球面分布时，将 <code>z</code> 的初始值设置为 <code>1 - dz / 2</code> 而不是从 0 开始的原因是为了确保点均匀覆盖整个球体，包括顶部和底部。具体原因包括：</p><p>避免极点的聚集</p><ul><li>球体的顶部和底部（即极点）是特殊的位置，如果从 z &#x3D; 0 或 z &#x3D; 1 开始，可能会在这些极点处导致点过度聚集或分布不均。</li><li>通过将 <code>z</code> 的初始值设置为 <code>1 - dz / 2</code>，相当于在 z 轴上对点的位置进行了微小的偏移，使得第一个点和最后一个点都不会精确地位于球体的极点上，而是稍微偏离中心。这有助于改善球面上点的分布均匀性。</li></ul><p>确保覆盖全球</p><ul><li>由于 <code>dz = 2 / counter</code>，这意味着 z 值将从 1 开始，逐渐递减至 -1，覆盖整个球体。</li><li>初始值 <code>1 - dz / 2</code> 实际上将第一个点的 z 值设置为接近 1，但略低于 1，确保点从球体的顶部开始，同时不会与球顶重合。</li></ul><p>均匀分布</p><ul><li>此方法确保了点在垂直方向上也是均匀分布的。通过从 <code>1 - dz / 2</code> 开始，每个点的 z 值都是均匀地在 z 轴上偏移的，从而避免了在接近极点区域的不均匀密度。</li></ul></blockquote><p>➡️ 后话1 ☕️</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxImpactAmount = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> impacts = [];</span><br><span class="line"><span class="comment">// let trails = [];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxImpactAmount; i++) &#123;</span><br><span class="line">  impacts.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">impactPosition</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>),</span><br><span class="line">    <span class="attr">impactMaxRadius</span>: <span class="number">5</span> * <span class="title class_">Three</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloat</span>(<span class="number">0.5</span>, <span class="number">0.75</span>), <span class="comment">// Three.Math.randFloat会报错</span></span><br><span class="line">    <span class="attr">impactRatio</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">prevPosition</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Vector3</span>().<span class="title function_">random</span>().<span class="title function_">subScalar</span>(<span class="number">0.5</span>).<span class="title function_">setLength</span>(<span class="number">5</span>),</span><br><span class="line">    <span class="attr">trailRatio</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    <span class="attr">trailLength</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// makeTrail(i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➡️ 后话2 ☕️</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> params = &#123;</span><br><span class="line">  <span class="attr">colors</span>: &#123;<span class="attr">base</span>: <span class="string">&#x27;#f9f002&#x27;</span>, <span class="attr">gradInner</span>: <span class="string">&#x27;#8ae66e&#x27;</span>, <span class="attr">gradOuter</span>: <span class="string">&#x27;#03c03c&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">reset</span>: <span class="function">()=&gt;</span> &#123; orbitControls.<span class="title function_">reset</span>() &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> uniforms = &#123;</span><br><span class="line">  <span class="attr">impacts</span>: &#123;<span class="attr">value</span>: impacts&#125;,</span><br><span class="line">  <span class="attr">maxSize</span>: &#123;<span class="attr">value</span>: <span class="number">.04</span>&#125;, <span class="comment">// 陆地色块大小</span></span><br><span class="line">  <span class="attr">minSize</span>: &#123; <span class="attr">value</span>: <span class="number">.025</span>&#125;, <span class="comment">// 海洋色块大小</span></span><br><span class="line">  <span class="attr">waveHeight</span>: &#123;<span class="attr">value</span>: <span class="number">.1</span>&#125;, <span class="comment">// 冲击波高度</span></span><br><span class="line">  <span class="attr">scaling</span>: &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, <span class="comment">// 冲击波范围</span></span><br><span class="line">  <span class="attr">gradInner</span>: &#123; <span class="attr">value</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">gradInner</span>)&#125;, <span class="comment">// 冲击波径向渐变内侧颜色</span></span><br><span class="line">  <span class="attr">gradOuter</span>: &#123; <span class="attr">value</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">gradOuter</span>)&#125;, <span class="comment">// 冲击波径向渐变外侧颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造点：</p><ol><li>根据z的不同，得到r，再求得three坐标系下（）的三维坐标p，转成球体phi和theta的坐标sph;</li><li>修改long和z，保存p的朝向和模型矩阵；</li><li>利用plane构造球面上的点，通过新建、变换、设置中心点和uv坐标实现</li><li>plane里传入了两个属性：center(每个点对应的位置), uv(这个点的球面坐标，缩放到0-1范围内)</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;counter;i++) &#123;</span><br><span class="line">  r = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">  p.<span class="title function_">set</span>(r * <span class="title class_">Math</span>.<span class="title function_">cos</span>(long), z, -r * <span class="title class_">Math</span>.<span class="title function_">sin</span>(long)).<span class="title function_">multiplyScalar</span>(rad);</span><br><span class="line">  sph.<span class="title function_">setFromVector3</span>(p);</span><br><span class="line">  long = long + dlong;</span><br><span class="line">  z = z - dz;</span><br><span class="line">  dummyObj.<span class="title function_">lookAt</span>(p);</span><br><span class="line">  dummyObj.<span class="title function_">updateMatrix</span>();</span><br><span class="line">  <span class="comment">// 构建球面上的plane，同时设置uv坐标</span></span><br><span class="line">  <span class="keyword">let</span> plane = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  plane.<span class="title function_">applyMatrix4</span>(dummyObj.<span class="property">matrix</span>);</span><br><span class="line">  plane.<span class="title function_">translate</span>(p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>);</span><br><span class="line">  <span class="keyword">let</span> centers = [p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>,p.<span class="property">x</span>,p.<span class="property">y</span>,p.<span class="property">z</span>];</span><br><span class="line">  plane.<span class="title function_">setAttribute</span>(<span class="string">&#x27;center&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferAttribute</span>(<span class="keyword">new</span> <span class="title class_">Float32Array</span>(centers), <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">let</span> uv = [(sph+<span class="title class_">Math</span>.<span class="property">PI</span>)/(<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>),<span class="number">1</span>-(sph.<span class="property">theta</span>/<span class="title class_">Math</span>.<span class="property">PI</span>)];</span><br><span class="line">  <span class="keyword">let</span> uvs = [uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>,uv.<span class="property">x</span>,uv.<span class="property">y</span>];</span><br><span class="line">  plane.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baseUv&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">BufferAttribute</span>(<span class="keyword">new</span> <span class="title class_">Float32Array</span>(uvs), <span class="number">2</span>));</span><br><span class="line">  geoms.<span class="title function_">push</span>(plane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="球材质和构造"><a href="#球材质和构造" class="headerlink" title="球材质和构造"></a>球材质和构造</h2><p>构造Mesh</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> g = <span class="title function_">mergeGeometries</span>(geoms);</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Color</span>(params.<span class="property">colors</span>.<span class="property">base</span>),</span><br><span class="line">    <span class="attr">onBeforeCompile</span>: <span class="function"><span class="params">shader</span> =&gt;</span> &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  m.<span class="property">defines</span> = &#123;<span class="string">&#x27;USE_UV&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">  earth = <span class="keyword">new</span> <span class="title class_">Three</span>.<span class="title class_">Mesh</span>(g, m);</span><br><span class="line">  earth.<span class="property">rotation</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">  <span class="comment">// trails.forEach( t =&gt; earth.add(t));</span></span><br><span class="line">  earth.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, -<span class="number">0.4</span>, <span class="number">0</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(earth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>球体材质</p><p>基本量</p><ul><li><strong><code>struct impact</code></strong>: 定义了一个包含冲击点数据的结构，包括冲击的位置(<code>impactPosition</code>)、冲击的最大半径(<code>impactMaxRadius</code>)和冲击比例(<code>impactRatio</code>)。</li><li><strong><code>uniform impact impacts[]</code></strong>: 一个包含多个冲击点的数组。</li><li><strong><code>uniform sampler2D tex</code></strong>: 一个二维纹理，通常用于存储和检索数据（比如图像或者根据纹理生成的数据）。</li><li><strong><code>uniform float maxSize, minSize</code></strong>: 最大和最小尺寸。</li><li><strong><code>uniform float waveHeight</code></strong>: 波高。</li><li><strong><code>uniform float scaling</code></strong>: 缩放系数。</li><li><strong><code>attribute vec3 center</code></strong>: 顶点的中心位置。</li><li><strong><code>attribute vec2 baseUv</code></strong>: 顶点的基本UV坐标。</li><li><strong><code>varying float vFinalStep</code></strong> 和 <strong><code>varying float vMap</code></strong>: 这些是从顶点着色器传递到片段着色器的变量，用于进一步的渲染计算。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">uniforms</span>.<span class="property">impacts</span> = uniforms.<span class="property">impacts</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">maxSize</span> = uniforms.<span class="property">maxSize</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">minSize</span> = uniforms.<span class="property">minSize</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">waveHeight</span> = uniforms.<span class="property">waveHeight</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">scaling</span> = uniforms.<span class="property">scaling</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">gradInner</span> = uniforms.<span class="property">gradInner</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">gradOuter</span> = uniforms.<span class="property">gradOuter</span>;</span><br><span class="line">       shader.<span class="property">uniforms</span>.<span class="property">tex</span> = &#123; <span class="attr">value</span>: earthTexture &#125;;</span><br></pre></td></tr></table></figure><p>顶点着色器逻辑</p><ul><li><strong>循环遍历每个冲击点</strong>：计算每个顶点与每个冲击点的距离，根据距离和冲击点的影响范围计算一个平滑的步进(<code>sstep</code>)。这个步进是基于 <code>smoothstep</code> 函数，用于创建冲击波的边界更加平滑的过渡效果。</li><li><strong><code>finalStep</code>的计算</strong>：累加所有冲击点对当前顶点的影响，使用 <code>clamp</code> 函数确保值在0到1之间。</li><li><strong><code>map</code>变量的计算</strong>：从纹理中获取当前顶点的green值，用于决定顶点的尺寸是 <code>maxSize</code> 还是 <code>minSize</code>，区分了陆地和海洋。</li><li><strong>顶点位置(<code>transformed</code>)的更新</strong>：根据 <code>map</code> 的结果和计算出的 <code>finalStep</code> 调整顶点位置，以实现位置的缩放和波纹效果。使用 <code>mix</code> 函数根据冲击波影响程度在原始尺寸和放大后的尺寸之间进行插值。波高(<code>waveHeight</code>)和 <code>finalStep</code> 的乘积决定了顶点沿法线方向的位移量。</li><li>这段代码通过计算每个顶点与一组冲击波的相对位置和影响，动态调整顶点位置和大小，从而在渲染过程中创建出动态的波纹效果。这种类型的着色器编程允许开发者创建复杂和动态的视觉效果，用于游戏开发、视觉艺术和模拟等领域。</li><li>补充：<code>baseUv</code> 在 Three.js 中是作为每个顶点的二维纹理坐标（<code>vec2</code>）被处理的。这些坐标是作为顶点属性上传到 GPU 的，后续在 GLSL 着色器中可以直接访问。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">vertexShader</span> = <span class="string">`</span></span><br><span class="line"><span class="string">    struct impact &#123;</span></span><br><span class="line"><span class="string">      vec3 impactPosition;</span></span><br><span class="line"><span class="string">      float impactMaxRadius;</span></span><br><span class="line"><span class="string">      float impactRatio;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    uniform impact impacts[<span class="subst">$&#123;maxImpactAmount&#125;</span>];</span></span><br><span class="line"><span class="string">    uniform sampler2D tex;</span></span><br><span class="line"><span class="string">    uniform float maxSize;</span></span><br><span class="line"><span class="string">    uniform float minSize;</span></span><br><span class="line"><span class="string">    uniform float waveHeight;</span></span><br><span class="line"><span class="string">    uniform float scaling;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    attribute vec3 center;</span></span><br><span class="line"><span class="string">    attribute vec2 baseUv;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    varying float vFinalStep;</span></span><br><span class="line"><span class="string">    varying float vMap;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;shader.vertexShader&#125;</span></span></span><br><span class="line"><span class="string">  `</span>.<span class="title function_">replace</span>(</span><br><span class="line">    <span class="string">`#include &lt;begin_vertex&gt;`</span>,</span><br><span class="line">    <span class="string">`#include &lt;begin_vertex&gt;</span></span><br><span class="line"><span class="string">    float finalStep = 0.0;</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; <span class="subst">$&#123;maxImpactAmount&#125;</span>;i++)&#123;</span></span><br><span class="line"><span class="string">      float dist = distance(center, impacts[i].impactPosition);</span></span><br><span class="line"><span class="string">      float curRadius = impacts[i].impactMaxRadius * impacts[i].impactRatio;</span></span><br><span class="line"><span class="string">      float sstep = smoothstep(0., curRadius, dist) - smoothstep(curRadius - ( 0.25 * impacts[i].impactRatio ), curRadius, dist);</span></span><br><span class="line"><span class="string">      sstep *= 1. - impacts[i].impactRatio;</span></span><br><span class="line"><span class="string">      finalStep += sstep;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    finalStep = clamp(finalStep, 0., 1.);</span></span><br><span class="line"><span class="string">    vFinalStep = finalStep;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    float map = texture(tex, baseUv).g;</span></span><br><span class="line"><span class="string">    vMap = map;</span></span><br><span class="line"><span class="string">    float pSize = map &lt; 0.5 ? maxSize : minSize;</span></span><br><span class="line"><span class="string">    float scale = scaling;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    transformed = (position - center) * pSize * mix(1., scale * 1.25, finalStep) + center; // scale on wave</span></span><br><span class="line"><span class="string">    transformed += normal * finalStep * waveHeight; // lift on wave</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>片元着色器逻辑</p><ul><li>传入对逐个点起作用的冲击强度和顶点纹理的g值；</li><li><strong>形状处理</strong> :</li><li>计算以屏幕中心为原点的 UV 坐标 <code>hUv</code>。（vUv是一个从0到1的二维向量，表示纹理坐标或顶点着色器传递给片段着色器的顶点位置）</li><li>N&#x3D;8常用于表示某种图形或模式中重复元素的数量</li><li><code>a</code> 是计算得到的向量 <code>hUv</code>的角度（相对于原点），使用的是反正切函数 <code>atan</code>，它返回从x轴到向量的角度。</li><li><code>r</code> 是每个扇区的角度范围，计算为 <code>2π</code> 除以扇区数量 <code>N</code>。</li><li><code>d</code> 是当前点到最近扇区边界的距离。</li><li><code>f</code> 是扇区中心到边界的距离。</li><li>如果 <code>d</code> 大于 <code>f</code>，则丢弃该片元（<code>discard</code>），只有距离扇区中心非常近的像素才能通过测试，这样可以创建更加锐利和明显的边界；</li><li>这有助于创建具有 N 边形形状的效果。</li><li><strong>颜色和渐变处理</strong>:</li><li><code>grad</code> 是内外渐变颜色的混合，基于 <code>d / f</code> 的值进行插值。</li><li><code>diffuseMap</code> 是根据 <code>vMap</code> 调整的漫反射颜色。 区分了陆地和海洋</li><li><code>col</code> 是漫反射颜色和渐变颜色的最终混合，其中使用了 <code>vFinalStep</code> 进行插值。</li><li>使用最终计算出的颜色 <code>col</code> 和原始的不透明度 <code>opacity</code> 创建新的 <code>vec4 diffuseColor</code>。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">shader.<span class="property">fragmentShader</span> = <span class="string">`</span></span><br><span class="line"><span class="string">            uniform vec3 gradInner;</span></span><br><span class="line"><span class="string">            uniform vec3 gradOuter;</span></span><br><span class="line"><span class="string">            varying float vFinalStep;</span></span><br><span class="line"><span class="string">            varying float vMap;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;shader.fragmentShader&#125;</span></span></span><br><span class="line"><span class="string">            `</span>.<span class="title function_">replace</span>(</span><br><span class="line">            <span class="string">`vec4 diffuseColor = vec4( diffuse, opacity );`</span>,</span><br><span class="line">            <span class="string">`</span></span><br><span class="line"><span class="string">            // shaping the point, pretty much from The Book of Shaders</span></span><br><span class="line"><span class="string">            vec2 hUv = (vUv - 0.5);</span></span><br><span class="line"><span class="string">            int N = 8;</span></span><br><span class="line"><span class="string">            float a = atan(hUv.x,hUv.y);</span></span><br><span class="line"><span class="string">            float r = PI2/float(N);</span></span><br><span class="line"><span class="string">            float d = cos(floor(.5+a/r)*r-a)*length(hUv);</span></span><br><span class="line"><span class="string">            float f = cos(PI / float(N)) * 0.5;</span></span><br><span class="line"><span class="string">            if (d &gt; f) discard;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            vec3 grad = mix(gradInner, gradOuter, clamp( d / f, 0., 1.)); // gradient</span></span><br><span class="line"><span class="string">            vec3 diffuseMap = diffuse * ((vMap &gt; 0.5) ? 0.5 : 1.);</span></span><br><span class="line"><span class="string">            vec3 col = mix(diffuseMap, grad, vFinalStep); // color on wave</span></span><br><span class="line"><span class="string">            //if (!gl_FrontFacing) col *= 0.25; // moderate the color on backside</span></span><br><span class="line"><span class="string">            vec4 diffuseColor = vec4( col , opacity );</span></span><br><span class="line"><span class="string">            `</span>);</span><br></pre></td></tr></table></figure><h3 id="补充-replace方法"><a href="#补充-replace方法" class="headerlink" title="补充 | replace方法"></a>补充 | replace方法</h3><p>上述vertex shader代码replace前：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shader.vertexShader:  #include &lt;common&gt;</span><br><span class="line">#include &lt;batching_pars_vertex&gt;</span><br><span class="line">#include &lt;uv_pars_vertex&gt;</span><br><span class="line">#include &lt;envmap_pars_vertex&gt;</span><br><span class="line">#include &lt;color_pars_vertex&gt;</span><br><span class="line">#include &lt;fog_pars_vertex&gt;</span><br><span class="line">#include &lt;morphtarget_pars_vertex&gt;</span><br><span class="line">#include &lt;skinning_pars_vertex&gt;</span><br><span class="line">#include &lt;logdepthbuf_pars_vertex&gt;</span><br><span class="line">#include &lt;clipping_planes_pars_vertex&gt;</span><br><span class="line">void main() &#123;</span><br><span class="line">#include &lt;uv_vertex&gt;</span><br><span class="line">#include &lt;color_vertex&gt;</span><br><span class="line">#include &lt;morphinstance_vertex&gt;</span><br><span class="line">#include &lt;morphcolor_vertex&gt;</span><br><span class="line">#include &lt;batching_vertex&gt;</span><br><span class="line">#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )</span><br><span class="line">#include &lt;beginnormal_vertex&gt;</span><br><span class="line">#include &lt;morphnormal_vertex&gt;</span><br><span class="line">#include &lt;skinbase_vertex&gt;</span><br><span class="line">#include &lt;skinnormal_vertex&gt;</span><br><span class="line">#include &lt;defaultnormal_vertex&gt;</span><br><span class="line">#endif</span><br><span class="line">#include &lt;begin_vertex&gt;</span><br><span class="line">#include &lt;morphtarget_vertex&gt;</span><br><span class="line">#include &lt;skinning_vertex&gt;</span><br><span class="line">#include &lt;project_vertex&gt;</span><br><span class="line">#include &lt;logdepthbuf_vertex&gt;</span><br><span class="line">#include &lt;clipping_planes_vertex&gt;</span><br><span class="line">#include &lt;worldpos_vertex&gt;</span><br><span class="line">#include &lt;envmap_vertex&gt;</span><br><span class="line">#include &lt;fog_vertex&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述fragment shader代码replace前：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">shader.fragmentShader:  <span class="keyword">uniform</span> <span class="type">vec3</span> diffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> opacity;</span><br><span class="line"><span class="meta">#ifndef FLAT_SHADED</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#include &lt;common&gt;</span></span><br><span class="line"><span class="meta">#include &lt;dithering_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;color_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;uv_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;map_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphamap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphatest_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphahash_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;aomap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;lightmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;envmap_common_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;envmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;fog_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;specularmap_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;logdepthbuf_pars_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;clipping_planes_pars_fragment&gt;</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> diffuseColor = <span class="type">vec4</span>( diffuse, opacity );</span><br><span class="line"><span class="meta">#include &lt;clipping_planes_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;logdepthbuf_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;map_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;color_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphamap_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphatest_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;alphahash_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;specularmap_fragment&gt;</span></span><br><span class="line">ReflectedLight reflectedLight = ReflectedLight( <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ), <span class="type">vec3</span>( <span class="number">0.0</span> ) );</span><br><span class="line"><span class="meta">#ifdef USE_LIGHTMAP</span></span><br><span class="line"><span class="type">vec4</span> lightMapTexel = <span class="built_in">texture2D</span>( lightMap, vLightMapUv );</span><br><span class="line">reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">reflectedLight.indirectDiffuse += <span class="type">vec3</span>( <span class="number">1.0</span> );</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#include &lt;aomap_fragment&gt;</span></span><br><span class="line">reflectedLight.indirectDiffuse *= diffuseColor.rgb;</span><br><span class="line"><span class="type">vec3</span> outgoingLight = reflectedLight.indirectDiffuse;</span><br><span class="line"><span class="meta">#include &lt;envmap_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;opaque_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;tonemapping_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;colorspace_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;fog_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;premultiplied_alpha_fragment&gt;</span></span><br><span class="line"><span class="meta">#include &lt;dithering_fragment&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 WebGL 或 OpenGL 的着色器编程中，使用 <code>.replace</code> 方法来修改着色器代码是一种常见的技术，尤其是在处理复杂的、可配置的着色器系统时。这种方法提供了灵活性和动态生成或调整着色器代码的能力。这里的 <code>.replace</code> 方法的使用具体有以下几个目的和优点：</p><ol><li><strong>动态内容注入</strong></li></ol><p>通过 <code>.replace</code>，可以根据程序的需求或配置动态地插入特定的代码片段。在着色器中，这种能力特别有用，因为它允许在不改变原始着色器代码文件的基础上，根据不同的渲染需求修改着色器行为。</p><ol start="2"><li><strong>条件编译</strong></li></ol><p>在多个不同的渲染场景下，可能需要着色器表现出不同的行为。使用 <code>.replace</code> 可以根据运行时条件选择性地添加或修改着色器代码，从而实现条件编译的效果。比如，根据对象是否受到特定影响，决定是否启用某些计算。</p><ol start="3"><li><strong>避免硬编码</strong></li></ol><p>硬编码在着色器中是不灵活的，特别是在涉及到循环次数或数组大小等参数时。通过 <code>.replace</code> 方法，开发者可以在着色器代码运行前插入这些值，使着色器代码更加通用和可配置。例如，通过插入 <code>$&#123;maxImpactAmount&#125;</code> 来确定循环的次数，这使得同一份着色器代码可以适应不同数量的冲击点。</p><ol start="4"><li><strong>模块化和代码复用</strong></li></ol><p>在大型项目中，可能需要在多个着色器之间共享或重用代码片段。通过使用 <code>.replace</code> 方法，可以从外部插入共享的代码片段或在多个着色器之间复用代码，提高维护性和一致性。</p><p>在你的示例中，<code>.replace</code> 方法被用来注入计算顶点最终位置的逻辑到一个基本的顶点着色器模板中。这种方式可以使主着色器代码保持相对不变，而特定的计算和行为可以根据需要动态地注入，如处理不同数量的冲击点或应用不同的动态效果。</p><h3 id="补充-define的作用"><a href="#补充-define的作用" class="headerlink" title="补充 | define的作用"></a>补充 | define的作用</h3><p>在 Three.js 中，<code>defines</code> 属性用于自定义着色器的预处理宏。这些宏是着色器代码中的条件编译指令，可以在编译着色器之前进行设置。通过设置这些宏，你可以启用或修改着色器的某些部分，从而调整其行为或性能，而无需改动着色器的主体代码。这为灵活性和重用提供了很好的支持。</p><p>使用场景</p><ol><li><strong>条件编译</strong>：<code>defines</code> 允许你根据需求启用或禁用着色器代码中的特定部分。例如，如果某个特性（如纹理映射）只在特定条件下使用，你可以通过 <code>defines</code> 来控制这一部分代码的编译。</li><li><strong>性能优化</strong>：通过禁用不需要的特性，可以减少着色器的复杂性，从而提高执行效率。例如，如果你知道你的材质不需要处理UV坐标，可以通过设置相应的宏来阻止编译这部分代码。</li></ol><p>在代码中，<code>m.defines = &#123;&#39;USE_UV&#39;: &#39;&#39;&#125;;</code>  这行代码设置了一个名为 <code>USE_UV</code> 的宏，虽然后面紧跟着的是一个空字符串，但它的存在足以让着色器编译器在预处理时认为 <code>USE_UV</code> 被定义了。在着色器代码中，可以使用预处理指令来检查这个宏：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef USE_UV</span></span><br><span class="line">  <span class="comment">// 执行使用 UV 坐标的代码</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="comment">// 执行不使用 UV 坐标的代码</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>通过这种方式，如果 <code>m.defines</code> 包含 <code>USE_UV</code>，则着色器中依赖 UV 坐标的部分会被编译和执行；如果没有定义 <code>USE_UV</code>，则相关代码块不会被执行，从而可能减少计算负担。这种技术非常适合在运行时根据不同的材质属性或图形设置调整着色器行为，是图形编程中一种常见且强大的优化手段。</p><h3 id="补充-内部代码定义的变量"><a href="#补充-内部代码定义的变量" class="headerlink" title="补充 | 内部代码定义的变量"></a>补充 | 内部代码定义的变量</h3><p>在上述提供的 Three.js 的默认着色器代码中，<code>vUv</code> 变量的定义和使用确实存在，但它是通过 Three.js 的标准着色器系统内部的代码片段进行的。这里是具体的分析：</p><p>在顶点着色器代码中，有如下几行代码是关键：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;uv_pars_vertex&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#include &lt;uv_vertex&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>&lt;uv_pars_vertex&gt;</code></strong>: 这个代码片段通常包含了与 UV 相关的参数定义，包括对 <code>vUv</code> 的声明。这个片段的作用是准备所有必要的 UV 相关数据，以便在顶点着色器中使用。</li><li><strong><code>&lt;uv_vertex&gt;</code></strong>: 这个代码片段负责将 UV 数据从顶点属性传递到 <code>vUv</code> 变量中。这通常包括从顶点数据中读取 UV 坐标，并将其赋值给 <code>vUv</code>。</li></ul><p>在片元着色器中，相关的代码片段包括：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;uv_pars_fragment&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><strong><code>&lt;uv_pars_fragment&gt;</code></strong>: 这个代码片段包括对 <code>vUv</code> 的使用，它从顶点着色器传递的数据中接收 UV 坐标。这在处理纹理映射和其他基于 UV 的操作时非常关键。</li></ul><p>在你的代码中，<code>vUv</code> 的处理是通过标准的 Three.js 着色器代码片段间接实现的。这种方法的优点是你无需直接在你的着色器代码中声明和定义 <code>vUv</code>，Three.js 已经在其着色器库中处理了所有这些操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;参考案例：&lt;a href=&quot;https://dragonir.github.io/3d/#/earthDigital&quot;&gt;https://dr</summary>
      
    
    
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/08/23/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/"/>
    <id>https://youxt-njnu.github.io/2024/08/23/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</id>
    <published>2024-08-23T06:33:26.000Z</published>
    <updated>2024-08-27T06:07:37.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-shapes"><a href="#记录-shapes" class="headerlink" title="记录-shapes"></a>记录-shapes</h1><p>step(float edge, float x)类似于if</p><p>vec3(float * float) 相当于把两个进行and</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniform vec2 u_resolution;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // Each result will return 1.0 (white) or 0.0 (black).</span><br><span class="line">    float left = step(0.1,st.x);   // Similar to ( X greater than 0.1 )</span><br><span class="line">    float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )</span><br><span class="line"></span><br><span class="line">    // The multiplication of left*bottom will be similar to the logical AND.</span><br><span class="line">    color = vec3( left * bottom );</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把使用这两个left, bottom，简化为使用1个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec2 bl = step(vec2(0.1),st)</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // bottom-left</span><br><span class="line">    vec2 bl = step(vec2(0.1),st);</span><br><span class="line">    float pct = bl.x * bl.y;</span><br><span class="line"></span><br><span class="line">    // top-right</span><br><span class="line">    // vec2 tr = step(vec2(0.1),1.0-st);</span><br><span class="line">    // pct *= tr.x * tr.y;</span><br><span class="line"></span><br><span class="line">    color = vec3(pct);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/1IsKBDcLtamyz4v.png" alt="image.png"></p><p>smoothstep()的形状效果：边缘更平缓</p><p>floor()的形状效果：阶梯式</p><p><img src="https://s2.loli.net/2024/08/23/lWRELpChy643jBM.png" alt="image.png"></p><p>绘制圆：</p><ul><li>参考圆规的思路，以st中心点为圆心，判断st范围内的每个点，是否在圆的范围内；—— distance(), sqrt(), length()</li><li>通过step切出来</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line"> <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">float</span> pct = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. The DISTANCE from the pixel to the center</span></span><br><span class="line">    pct = <span class="built_in">distance</span>(st,<span class="type">vec2</span>(<span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. The LENGTH of the vector</span></span><br><span class="line">    <span class="comment">//    from the pixel to the center</span></span><br><span class="line">    <span class="comment">// vec2 toCenter = vec2(0.5)-st;</span></span><br><span class="line">    <span class="comment">// pct = length(toCenter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. The SQUARE ROOT of the vector</span></span><br><span class="line">    <span class="comment">//    from the pixel to the center</span></span><br><span class="line">    <span class="comment">// vec2 tC = vec2(0.5)-st;</span></span><br><span class="line">    <span class="comment">// pct = sqrt(tC.x*tC.x+tC.y*tC.y);</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">float</span> clipRes = <span class="number">1.</span>-<span class="built_in">step</span>(<span class="number">0.5</span>,pct);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(pct);</span><br><span class="line">    <span class="comment">// color = vec3(1.-clipRes*pct);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>( color, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左边是三种方法求距离后的color，右边是加入了step和1.-的使用；</p><p><img src="https://s2.loli.net/2024/08/26/jvztG13xlTeMI7W.png" alt="image.png"></p><p>“distance field”，类似缓冲区；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">  // st.x *= u_resolution.x/u_resolution.y;</span><br><span class="line">  vec3 color = vec3(0.0);</span><br><span class="line">  float d = 0.0;</span><br><span class="line"></span><br><span class="line">  // Remap the space to -1. to 1.</span><br><span class="line">  st = st *2.-1.;</span><br><span class="line"></span><br><span class="line">  // Make the distance field</span><br><span class="line">  d = length( abs(st)-.3 );</span><br><span class="line">  //d = length( min(abs(st)-.3,0.) );</span><br><span class="line">  //d = length( max(abs(st)-.3,0.) );</span><br><span class="line"></span><br><span class="line">  // Visualize the distance field</span><br><span class="line">  gl_FragColor = vec4(vec3(d),1.0);</span><br><span class="line">  // gl_FragColor = vec4(vec3(fract(d*12.216)),1.0); // *的数值越大，d略微变化下呈现的小数部分就更多样</span><br><span class="line"></span><br><span class="line">  // Drawing with the distance field</span><br><span class="line">  gl_FragColor = vec4(vec3( step(.3,d) ),1.0);</span><br><span class="line">  gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);</span><br><span class="line">  gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/27/CZM4AR9LVQlF3e2.png" alt="img"></p><p>不同曲线设置下的形状表现，可以用来做花朵、雪花、齿轮这些。。。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform vec2 u_mouse;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution.xy;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    vec2 pos = vec2(0.5)-st; // -0.5~0.5</span><br><span class="line"></span><br><span class="line">    float r = length(pos)*2.0;</span><br><span class="line">    float a = atan(pos.y,pos.x);</span><br><span class="line"></span><br><span class="line">    float f = cos(a*3.);</span><br><span class="line">    f = abs(cos(a*3.));</span><br><span class="line">   f = abs(cos(a*2.5))*0.236+0.116;</span><br><span class="line">   f = abs(cos(a*12.)*sin(a*3.))*.8+.1;</span><br><span class="line">    f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;</span><br><span class="line"></span><br><span class="line">    //color = vec3(smoothstep(f,f+.01,r));</span><br><span class="line">    color = vec3(1.-smoothstep(f,f+0.01,r) );</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/27/LoCVqmx6WvzeMKh.png" alt="image.png"></p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p>实现下面的效果：</p><p><img src="https://thebookofshaders.com/07/mondrian.jpg" alt="img"></p><p><a href="https://thndl.com/square-shaped-shaders.html">Square shaped shaders | thndl</a></p><p><a href="https://mstdn.thndl.com/@baldand">https://mstdn.thndl.com/@baldand</a></p><p><a href="https://www.mattdesl.com/">https://www.mattdesl.com/</a></p><p>lygia: <a href="https://lygia.xyz/draw">LYGIA Shader Library</a>, <a href="https://lygia.xyz/draw">LYGIA Shader Library sdf函数</a></p><p><a href="https://pixelspiritdeck.com/">像素精神 (pixelspiritdeck.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
    <id>https://youxt-njnu.github.io/2024/08/19/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</id>
    <published>2024-08-19T03:55:26.000Z</published>
    <updated>2024-08-21T06:18:49.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><h1 id="记录-color部分"><a href="#记录-color部分" class="headerlink" title="记录-color部分"></a>记录-color部分</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec4 vector;</span><br><span class="line">vector[0] = vector.r = vector.x = vector.s;</span><br><span class="line">vector[1] = vector.g = vector.y = vector.t;</span><br><span class="line">vector[2] = vector.b = vector.z = vector.p;</span><br><span class="line">vector[3] = vector.a = vector.w = vector.q;</span><br></pre></td></tr></table></figure><p>支持swizzle(搅动)：vec3 yellow&#x3D;vec3(1.,1.,0.); yellow.rgb, yellow.rgr, yellow.bgr ……</p><p>利用mix()进行color混合：mix(color1,color2,value) ，value从0到1，value越小color1值越多</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>); <span class="comment">// blue</span></span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>); <span class="comment">// yellow</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct = <span class="built_in">abs</span>(<span class="built_in">sin</span>(u_time)); <span class="comment">// 从0到1，sin(x)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mix uses pct (a value from 0-1) to</span></span><br><span class="line">    <span class="comment">// mix the two colors</span></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="easing-function"><a href="#easing-function" class="headerlink" title="easing function"></a>easing function</h2><p>用于计算动画的缓动函数<a href="https://easings.net/">easing function</a></p><ul><li>下面的式子有些作者进行了sin&#x2F;cos之间的变换，以及命名的风格是sineIn就是上面链接里的easeInSine</li><li>上面网页里，每个函数都有对应的css用法，postcss用法，在元素变换动画里的效果，在颜色渐变混合里的效果，使用该函数进行变换的样例（缩放、移动、透明度变化）,也可以调整参数点击go进行对比</li><li>最后一排：css的实现是通过@keyframes，设置不同的条件；函数里面是通过一系列的判断来赋值；</li><li>前四排的都是<a href="https://cubic-bezier.com/#.25,.1,.25,1">cube-bezier</a>函数设置不同的参数得到的效果</li></ul><blockquote><p>在 CSS 中，<code>cubic-bezier</code> 函数用于定义一个三次贝塞尔曲线，广泛应用于动画和过渡效果的时间函数（timing function）。这个函数的四个参数控制曲线的形状，从而影响动画的速度变化。</p><p>具体来说，<code>cubic-bezier(.12, 0, .33, 0)</code> 中的四个参数表示的是两个控制点的坐标：</p><ul><li>第一个控制点的坐标为 (0.12, 0)</li><li>第二个控制点的坐标为 (0.33, 0)</li></ul><p>这四个参数可以这样解释：</p><ol><li>**第一个参数 (0.12)**：这是第一个控制点的横坐标，它影响动画开始阶段的加速度。值为 0.12 表示在动画开始阶段，速度从零开始缓慢增加。</li><li>**第二个参数 (0)**：这是第一个控制点的纵坐标，它在这里设为 0，意味着控制点位于起始线上，因此动画起始时会比较平缓，没有立即加速。</li><li>**第三个参数 (0.33)**：这是第二个控制点的横坐标，影响动画结束前的减速过程。值较小（0.33）表明动画在结束前不久开始减速。</li><li>**第四个参数 (0)**：这是第二个控制点的纵坐标，同样为 0，意味着结束时速度减到 0，动画结束的过程也是比较平缓的。</li></ol><p>通过调整这些参数，开发者可以精确控制动画的速度曲线，从而创造出各种动画效果。在这个具体例子中，由于两个控制点的纵坐标都是 0，这种曲线通常用于创建某些具有明显起始和结束阶段的动画效果。</p></blockquote><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.141592653589793</span></span><br><span class="line"><span class="meta">#define HALF_PI 1.5707963267948966</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Robert Penner&#x27;s easing functions in GLSL</span></span><br><span class="line"><span class="comment">// https://github.com/stackgl/glsl-easings</span></span><br><span class="line"><span class="type">float</span> linear(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> ? t : <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">1.0</span> ? t : <span class="number">1.0</span> - <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> exponentialInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t == <span class="number">0.0</span> || t == <span class="number">1.0</span></span><br><span class="line">    ? t</span><br><span class="line">    : t &lt; <span class="number">0.5</span></span><br><span class="line">      ? +<span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, (<span class="number">20.0</span> * t) - <span class="number">10.0</span>)</span><br><span class="line">      : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> - (t * <span class="number">20.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>((t - <span class="number">1.0</span>) * HALF_PI) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(t * HALF_PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sineInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-0.5</span> * (<span class="built_in">cos</span>(PI * t) - <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">5.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> qinticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">16.0</span> * <span class="built_in">pow</span>(t, <span class="number">5.0</span>)</span><br><span class="line">    : <span class="number">-0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">5.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">3.0</span>) * (<span class="number">1.0</span> - t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quarticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? +<span class="number">8.0</span> * <span class="built_in">pow</span>(t, <span class="number">4.0</span>)</span><br><span class="line">    : <span class="number">-8.0</span> * <span class="built_in">pow</span>(t - <span class="number">1.0</span>, <span class="number">4.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> p = <span class="number">2.0</span> * t * t;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span> ? p : -p + (<span class="number">4.0</span> * t) - <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> quadraticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> -t * (t - <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t * t * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t - <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">return</span> f * f * f + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cubicInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">4.0</span> * t * t * t</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">pow</span>(<span class="number">2.0</span> * t - <span class="number">2.0</span>, <span class="number">3.0</span>) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">13.0</span> * t * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (t - <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sin</span>(<span class="number">-13.0</span> * (t + <span class="number">1.0</span>) * HALF_PI) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * t) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> elasticInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * <span class="built_in">sin</span>(+<span class="number">13.0</span> * HALF_PI * <span class="number">2.0</span> * t) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * <span class="built_in">sin</span>(<span class="number">-13.0</span> * HALF_PI * ((<span class="number">2.0</span> * t - <span class="number">1.0</span>) + <span class="number">1.0</span>)) * <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">-10.0</span> * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - t * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="number">2.0</span> - t) * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> circularInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - <span class="built_in">sqrt</span>(<span class="number">1.0</span> - <span class="number">4.0</span> * t * t))</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="built_in">sqrt</span>((<span class="number">3.0</span> - <span class="number">2.0</span> * t) * (<span class="number">2.0</span> * t - <span class="number">1.0</span>)) + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> a = <span class="number">4.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> b = <span class="number">8.0</span> / <span class="number">11.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> c = <span class="number">9.0</span> / <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> ca = <span class="number">4356.0</span> / <span class="number">361.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cb = <span class="number">35442.0</span> / <span class="number">1805.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> cc = <span class="number">16061.0</span> / <span class="number">1805.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> t2 = t * t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; a</span><br><span class="line">    ? <span class="number">7.5625</span> * t2</span><br><span class="line">    : t &lt; b</span><br><span class="line">      ? <span class="number">9.075</span> * t2 - <span class="number">9.9</span> * t + <span class="number">3.4</span></span><br><span class="line">      : t &lt; c</span><br><span class="line">        ? ca * t2 - cb * t + cc</span><br><span class="line">        : <span class="number">10.8</span> * t * t - <span class="number">20.52</span> * t + <span class="number">10.72</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> bounceInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * (<span class="number">1.0</span> - bounceOut(<span class="number">1.0</span> - t * <span class="number">2.0</span>))</span><br><span class="line">    : <span class="number">0.5</span> * bounceOut(t * <span class="number">2.0</span> - <span class="number">1.0</span>) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backIn(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pow</span>(t, <span class="number">3.0</span>) - t * <span class="built_in">sin</span>(t * PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">1.0</span> - t;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - (<span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> backInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">  <span class="type">float</span> f = t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">2.0</span> * t</span><br><span class="line">    : <span class="number">1.0</span> - (<span class="number">2.0</span> * t - <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> g = <span class="built_in">pow</span>(f, <span class="number">3.0</span>) - f * <span class="built_in">sin</span>(f * PI);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="number">0.5</span> * g</span><br><span class="line">    : <span class="number">0.5</span> * (<span class="number">1.0</span> - g) + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充说明：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> t = u_time * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) * <span class="number">2.0</span> - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间缩放 (<code>t = u_time * 0.5</code>)**：这里 <code>u_time</code> 被乘以 0.5，意味着 <code>t</code> 的变化速度是 <code>u_time</code> 的一半。如果 <code>u_time</code> 是一个随时间增加的变量，那么 <code>t</code> 的增长速度更慢。</li><li>**计算 <code>pct</code>**：<code>fract(t)</code> 获取 <code>t</code> 的小数部分，这样即使 <code>t</code> 增长到 1 以上，<code>fract(t)</code> 也会重新从 0 开始，实现周期性重置。乘以 2.0 然后减 1.0 是为了将周期变化从 <code>[0,1]</code> 调整到 <code>[-1,1]</code>，这样 <code>abs(...)</code> 后的值将在 <code>[0,1]</code> 之间振荡，实现了先增加到 1 然后减少到 0 的周期性变化。</li><li><strong><code>cubicInOut</code> 动画曲线</strong>：这个函数通常定义了一个缓入缓出的三次曲线，意味着动画开始和结束时速度较慢，中间速度较快。</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">t = u_time;</span><br><span class="line">pct = cubicInOut(<span class="built_in">abs</span>(<span class="built_in">fract</span>(t) - <span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><ol><li>**时间设置 (<code>t = u_time</code>)**：这里没有对 <code>u_time</code> 进行缩放，因此 <code>t</code> 以原始速度增加。</li><li>**计算 <code>pct</code>**：这里仅使用了 <code>fract(t)</code> 减去 1.0，与上面的代码相比，这样处理会产生从 <code>-1</code> 到 0 的周期性变化（因为 <code>fract(t)</code> 产生 <code>[0,1)</code>，减 1 后变为 <code>[-1,0)</code>）。应用 <code>abs(...)</code> 后，变化将在 <code>[0,1)</code> 间发生，实现了周期性的从 0 增加到 1。</li></ol><p>效果差异：</p><ul><li><strong>变化速率</strong>：上面的代码中 <code>t</code> 的变化速度为原始时间的一半，这导致整体动画速度更慢。</li><li><strong>振荡方式</strong>：上面的代码使得振荡从 0 增加到 1 然后减少到 0，形成一个完整的循环，而下面的代码只从 0 增加到 1。</li></ul><p>结合这些分析，上面的代码提供了一个更平滑和对称的振荡模式，适用于需要循环动画效果的场景，如呼吸灯效果。下面的代码则更适合于单向的渐进或渐出效果，如日出效果。</p><h2 id="颜色的渐变"><a href="#颜色的渐变" class="headerlink" title="颜色的渐变"></a>颜色的渐变</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">void main() &#123;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"> vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    float pct = cubicInOut(st.y); </span><br><span class="line">    pct = circularInOut(st.y); // 因为InOut那边的曲线是在很小范围内的自变量下发生了较大的因变量变化，所以分界线会明显，相对上面的来说</span><br><span class="line">    // Mix uses pct (a value from 0-1) to</span><br><span class="line">    // mix the two colors</span><br><span class="line">    color = mix(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/OmhPTZGRKIo1rfN.png"></p><h2 id="mix对RGB三个通道的控制"><a href="#mix对RGB三个通道的控制" class="headerlink" title="mix对RGB三个通道的控制"></a>mix对RGB三个通道的控制</h2><p>可以分别设置RGB三通道的混合方式</p><p><img src="https://thebookofshaders.com/06/mix-vec.jpg" alt="img"></p><p>示例</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> colorA = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line"><span class="type">vec3</span> colorB = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> plot (<span class="type">vec2</span> st, <span class="type">float</span> pct)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">smoothstep</span>( pct<span class="number">-0.01</span>, pct, st.y) -</span><br><span class="line">          <span class="built_in">smoothstep</span>( pct, pct+<span class="number">0.01</span>, st.y); <span class="comment">// smoothstep(a-极小值,a,纹理坐标)-smoothstep(a,a+极小值,纹理坐标)，可以画出a的曲线（也就是代码里的pct）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> pct = <span class="type">vec3</span>(st.x);</span><br><span class="line"></span><br><span class="line">    pct.r = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,<span class="number">1.0</span>, st.x);</span><br><span class="line">    pct.g = <span class="built_in">sin</span>(st.x*PI);</span><br><span class="line">    pct.b = <span class="built_in">pow</span>(st.x,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    color = <span class="built_in">mix</span>(colorA, colorB, pct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Plot transition lines for each channel</span></span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.r));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.g));</span><br><span class="line">    color = <span class="built_in">mix</span>(color,<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>),plot(st,pct.b));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/NtLrd5aD4mFjuSX.png"></p><p>混合加变换的组合</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">0.149</span>,<span class="number">0.141</span>,<span class="number">0.912</span>);</span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">1.000</span>,<span class="number">0.833</span>,<span class="number">0.224</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec3</span> colorA = <span class="built_in">mix</span>(color1,color2,st.y);</span><br><span class="line">    <span class="type">vec3</span> colorB = <span class="built_in">mix</span>(color1,color2,<span class="number">1.</span>-st.y*st.x);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = u_time*<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> pct = cubicInOut( <span class="built_in">abs</span>(<span class="built_in">fract</span>(t)*<span class="number">2.0</span><span class="number">-1.</span>) );</span><br><span class="line">   <span class="comment">// t = u_time;</span></span><br><span class="line">   <span class="comment">// pct = cubicInOut( abs(fract(t)-1.) );</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">mix</span>(colorA, colorB, pct)),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*2WK3NdpR_Oxt0QKN8r6Rgg.gif" alt="img"></p><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><blockquote><p>shadertoy代码：</p><p><a href="https://www.shadertoy.com/view/MsS3Wc">Smooth HSV (shadertoy.com)</a></p><p><a href="https://blog.csdn.net/ColdWindHA/article/details/82080176">OpenCV学习笔记——HSV颜色空间超极详解&amp;inRange函数用法及实战_hsv值是什么-CSDN博客</a></p><p><a href="https://www.cnblogs.com/dablyo/p/6854947.html">HSV色彩空间和颜色分量范围 - 友善的狗W - 博客园 (cnblogs.com)</a></p></blockquote><p><img src="https://s2.loli.net/2024/08/21/AleHoLjbR9I67Su.png" alt="image.png"></p><p>RGB和HSV的互转</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> rgb2hsb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> p = <span class="built_in">mix</span>(<span class="type">vec4</span>(c.bg, K.wz),</span><br><span class="line">                 <span class="type">vec4</span>(c.gb, K.xy),</span><br><span class="line">                 <span class="built_in">step</span>(c.b, c.g));</span><br><span class="line">    <span class="type">vec4</span> q = <span class="built_in">mix</span>(<span class="type">vec4</span>(p.xyw, c.r),</span><br><span class="line">                 <span class="type">vec4</span>(c.r, p.yzx),</span><br><span class="line">                 <span class="built_in">step</span>(p.x, c.r));</span><br><span class="line">    <span class="type">float</span> d = q.x - <span class="built_in">min</span>(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)),</span><br><span class="line">                d / (q.x + e),</span><br><span class="line">                q.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Function from Iñigo Quiles</span></span><br><span class="line"><span class="comment">//  https://www.shadertoy.com/view/MsS3Wc</span></span><br><span class="line"><span class="type">vec3</span> hsb2rgb( <span class="keyword">in</span> <span class="type">vec3</span> c )&#123;</span><br><span class="line">    <span class="type">vec3</span> rgb = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(c.x*<span class="number">6.0</span>+<span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">4.0</span>,<span class="number">2.0</span>),</span><br><span class="line">                             <span class="number">6.0</span>)<span class="number">-3.0</span>)<span class="number">-1.0</span>,</span><br><span class="line">                     <span class="number">0.0</span>,</span><br><span class="line">                     <span class="number">1.0</span> );</span><br><span class="line">    rgb = rgb*rgb*(<span class="number">3.0</span><span class="number">-2.0</span>*rgb);</span><br><span class="line">    <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">1.0</span>), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We map x (0.0 - 1.0) to the hue (0.0 - 1.0)</span></span><br><span class="line">    <span class="comment">// And the y (0.0 - 1.0) to the brightness</span></span><br><span class="line">    color = hsb2rgb(<span class="type">vec3</span>(st.x,<span class="number">1.0</span>,st.y)); <span class="comment">// 传入的体现了h,s,b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/8ZdlghIPOemGJwt.png" alt="image.png"></p><p>HSB从笛卡尔坐标映射到极坐标：</p><ul><li>获取角度和到屏幕中心点的距离</li><li>使用length()和atan(y,x)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define TWO_PI 6.28318530718</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line">uniform float u_time;</span><br><span class="line"></span><br><span class="line">//  Function from Iñigo Quiles</span><br><span class="line">//  https://www.shadertoy.com/view/MsS3Wc</span><br><span class="line">vec3 hsb2rgb( in vec3 c )&#123;</span><br><span class="line">    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),</span><br><span class="line">                             6.0)-3.0)-1.0,</span><br><span class="line">                     0.0,</span><br><span class="line">                     1.0 );</span><br><span class="line">    rgb = rgb*rgb*(3.0-2.0*rgb);</span><br><span class="line">    return c.z * mix( vec3(1.0), rgb, c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    vec2 st = gl_FragCoord.xy/u_resolution;</span><br><span class="line">    vec3 color = vec3(0.0);</span><br><span class="line"></span><br><span class="line">    // Use polar coordinates instead of cartesian</span><br><span class="line">    vec2 toCenter = vec2(0.5)-st; // 把纹理坐标空间移到-.5到.5</span><br><span class="line">    float angle = atan(toCenter.y,toCenter.x); // 求每个点相对于中心点的角度</span><br><span class="line">    float radius = length(toCenter)*2.0; // 长度的范围是0~1</span><br><span class="line"></span><br><span class="line">    // Map the angle (-PI to PI) to the Hue (from 0 to 1)</span><br><span class="line">    // and the Saturation to the radius</span><br><span class="line">    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0)); // 第一个表示h，根据相对于中心点的角度来赋予颜色，同时缩放到了0-1，然后传入；radius: 离中心点越远，radius越大，s值越大;</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/21/fTMw6RpQmVY3JWH.png" alt="image.png"></p><p><code>var toCenter = st - vec2(0.5);</code></p><p>这样子，把上述的图旋转180度的效果；</p><h1 id="推荐待更新。。。"><a href="#推荐待更新。。。" class="headerlink" title="推荐待更新。。。"></a>推荐待更新。。。</h1><p>结合shaping function，呈现不同的颜色过渡；</p><p><img src="https://thebookofshaders.com/06/spectrums.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>shader-学习记录Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>https://youxt-njnu.github.io/2024/08/16/shader-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</id>
    <published>2024-08-16T07:52:26.000Z</published>
    <updated>2024-08-19T05:51:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习资料：<a href="https://thebookofshaders.com/05/">The Book of Shaders: Shaping functions</a></p><p><a href="https://thebookofshaders.com/edit.php">GLSL Editor (thebookofshaders.com)</a> 在线的shader编辑调试</p><p><a href="https://github.com/patriciogonzalezvivo/glslGallery">patriciogonzalezvivo&#x2F;glslGallery (github.com)</a> 看着不错，但是提交自己的上去后，提交不到对应的服务器（直白些就是俺试完了用不了。。。。。</p><p><a href="https://patriciogonzalezvivo.github.io/glslGallery/">GLSL Gallery (patriciogonzalezvivo.github.io)</a> 作者的一些shader，可以借鉴学习</p><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><h2 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h2><p>GPU特点：blind（不知道其他的pipe&#x2F;thread在干啥），memoryless（不知道以前干了啥）</p><p>片元着色器：</p><ul><li>void main() {} 主函数</li><li>内置全局变量，如gl_FragColor</li><li>默认输出：gl_fragColor</li><li>默认输入：gl_fragCoord  (是varing)     &#x2F;&#x2F;    x,y都从0到1</li><li>数据类型，vec4，精度如float</li><li>标准化normalized, 映射map</li><li>宏，#defines, #ifdef, #endif, #ifndef</li><li>注意，对于浮点的数字最好养成加上.的习惯</li></ul><p>uniform:</p><ul><li>cpu给gpu的</li><li>一些所有thread都一样的，不会变的值</li></ul><p>支持内置数学函数，如sin()</p><h2 id="shaping-functions"><a href="#shaping-functions" class="headerlink" title="shaping functions"></a>shaping functions</h2><h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p>The <a href="https://thebookofshaders.com/glossary/?search=step"><code>step()</code></a> interpolation receives two parameters.</p><p>The first one is the limit or threshold, while the second one is the value we want to check or pass.</p><p>Any value under the limit will return <code>0.0</code> while everything above the limit will return <code>1.0</code>.</p><h3 id="smoothstep"><a href="#smoothstep" class="headerlink" title="smoothstep"></a>smoothstep</h3><p><a href="https://blog.csdn.net/weixin_61427881/article/details/127839417">【Shader Graph】SmoothStep节点详解及其应用-CSDN博客</a></p><h3 id="sin-x2F-cos"><a href="#sin-x2F-cos" class="headerlink" title="sin&#x2F;cos"></a>sin&#x2F;cos</h3><p>加上u_time: 实现沿x轴的移动</p><p>乘上PI类似的：实现曲线的收缩</p><p>加上值：实现曲线上下移动</p><p>外面乘上值：实现曲线拉伸</p><p>取绝对值abs()：弹跳球轨迹</p><p>取小数部分fract()</p><p>取上下整数ceil(), floor()</p><p>y &#x3D; mod(x,0.5); &#x2F;&#x2F; return x modulo of 0.5<br>y &#x3D; fract(x); &#x2F;&#x2F; return only the fraction part of a number<br>y &#x3D; ceil(x);  &#x2F;&#x2F; nearest integer that is greater than or equal to x<br>y &#x3D; floor(x); &#x2F;&#x2F; nearest integer less than or equal to x<br>y &#x3D; sign(x);  &#x2F;&#x2F; extract the sign of x<br>y &#x3D; abs(x);   &#x2F;&#x2F; return the absolute value of x<br>y &#x3D; clamp(x,0.0,1.0); &#x2F;&#x2F; constrain x to lie between 0.0 and 1.0<br>y &#x3D; min(0.0,x);   &#x2F;&#x2F; return the lesser of x and 0.0<br>y &#x3D; max(0.0,x);   &#x2F;&#x2F; return the greater of x and 0.0</p><p>搜索关键词：generative art</p><blockquote><p><a href="https://aiartists.org/generative-art-design">Generative Art: 50 Best Examples, Tools &amp; Artists (2021 GUIDE) — AIArtists.org</a></p></blockquote><h1 id="几个shader"><a href="#几个shader" class="headerlink" title="几个shader"></a>几个shader</h1><h2 id="鼠标坐标"><a href="#鼠标坐标" class="headerlink" title="鼠标坐标"></a><strong>鼠标坐标</strong></h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03 code2</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution; <span class="comment">// 屏幕 宽，高</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">   <span class="type">vec2</span> mousePos;</span><br><span class="line"><span class="comment">// vec2 st = gl_FragCoord.xy/u_resolution; // 把输入纹理坐标缩放到0~1</span></span><br><span class="line"><span class="comment">// gl_FragColor = vec4(st.x,st.y,0.0,1.0);</span></span><br><span class="line"><span class="type">vec2</span> center = u_resolution/<span class="number">2.</span>; <span class="comment">// 获取中心点的屏幕坐标</span></span><br><span class="line">   mousePos = (u_mouse.xy-center)/center; <span class="comment">// 把鼠标位置缩放到-1~1</span></span><br><span class="line">   mousePos = mousePos*<span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// 把鼠标位置缩放到0~1</span></span><br><span class="line">   <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(mousePos.x,mousePos.y,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷油漆"><a href="#刷油漆" class="headerlink" title="刷油漆"></a><strong>刷油漆</strong></h2><ul><li>获取从0到1空间坐标</li><li>做出0到1渐变灰</li><li>制造函数和对应区间</li><li>把函数涂上颜色</li></ul><p><img src="https://s2.loli.net/2024/08/16/p9GByiLT3MqlPCS.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05 code1</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值区间：</span></span><br><span class="line"><span class="comment">// abs(y-x)===0, return 1</span></span><br><span class="line"><span class="comment">// abs(y-x) 0~0.02, return abs(y-x)</span></span><br><span class="line"><span class="comment">// abs(y-x) &gt;0.02, return 0</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.02</span>,<span class="number">0.0</span>,<span class="built_in">abs</span>(st.y-st.x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"> <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line">    <span class="type">float</span> y = st.x;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line">    <span class="comment">// 每个点只有x起作用，所以x一样的，显示的颜色是一样的；</span></span><br><span class="line">    <span class="comment">// color由三个x组成，所以是灰度，而且渐变大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> line = plot(st);</span><br><span class="line">    <span class="comment">// color = line*vec3(.0,1.,.0); // 绘制出了绿色的线</span></span><br><span class="line">    <span class="comment">// color = (1.-line)*color; // 把线的地方扣成黑色，方便后续加色</span></span><br><span class="line">    <span class="comment">// 分割出线，加上背景</span></span><br><span class="line">    color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"> <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><p>st: 基于屏幕的纹理坐标</p><p>y: 和st有关系的函数</p><p>color: 展示y的灰度颜色</p><p>line: 通过st和y绘制的样条函数。。</p><p>color: 给line函数进行叠加显示</p><p><img src="https://s2.loli.net/2024/08/16/Qoudz1HApWlqJUK.png" alt="image.png"></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_mouse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较st的x^5, 0, y的关系</span></span><br><span class="line"><span class="comment">// y&lt;x^5的，都0</span></span><br><span class="line"><span class="comment">// y在0~x^5，都原值</span></span><br><span class="line"><span class="comment">// y=0的，都1</span></span><br><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y,<span class="number">0.0</span>,st.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy/u_resolution;</span><br><span class="line"><span class="type">float</span> y = <span class="built_in">pow</span>(st.x,<span class="number">5.</span>);</span><br><span class="line"><span class="type">vec3</span> color = <span class="type">vec3</span>(y);</span><br><span class="line"><span class="type">float</span> line = plot(st,y);</span><br><span class="line">color = (<span class="number">1.</span>-line)*color + line*<span class="type">vec3</span>(<span class="number">.0</span>,<span class="number">1.</span>,<span class="number">.0</span>);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取个反再锐化下</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.02</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/z6xAHaYDJFeQ7ct.png" alt="image.png"></p><p>求个交集</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> plot(<span class="type">vec2</span> st,<span class="type">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(y<span class="number">-0.03</span>,y,st.y)-<span class="built_in">smoothstep</span>(y<span class="number">-0.01</span>,y,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/O4LcxMDmrB2toTP.png" alt="image.png"></p><p>更自然些的交集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float plot(vec2 st,float y) &#123;</span><br><span class="line">    return smoothstep(y-0.03,y,st.y)-smoothstep(y,y+0.03,st.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/Ze68o1mKhicjrbW.png" alt="image.png"></p><p>step需要分片来看：</p><ul><li>step(): 左片(&lt;0.5), 右片(&gt;0.5) -&gt;y,也就是传进polt的pct</li><li>smoothstep: 左片，所有纹理点都是1</li><li>smoothstep: 右片，纹理点的分割按照(1-0.02, 1, st.y)进行，下0，中原值，上1</li></ul><p><img src="https://s2.loli.net/2024/08/17/sel5gGTcNRP2iJq.png" alt="image.png"></p><h1 id="可能的bug"><a href="#可能的bug" class="headerlink" title="可能的bug"></a>可能的bug</h1><p><strong>没定义精度</strong> <code>No precision specified for (float)</code></p><blockquote><p>presion mediump floa<strong>t;</strong></p></blockquote><p><strong>fragment shader做完了不显示颜色：</strong></p><blockquote><p>没给gl_FragColor赋值</p></blockquote><p><strong>没找到函数</strong> <code>&#39;setColor&#39; : no matching overloaded function found</code></p><blockquote><p>C里面把函数写在void main()前面，或者需提前声明</p></blockquote><h1 id="推荐待更新"><a href="#推荐待更新" class="headerlink" title="推荐待更新"></a>推荐待更新</h1><blockquote><p>准备先过一遍教程再说….</p></blockquote><p><a href="https://www.flong.com/">Flong.com • Golan Levin &amp; Collaborators 的作品</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_poly/">Polynomial Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_exp/">Exponential Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_circ/index.html">Circular &amp; Elliptical Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><p><a href="https://www.flong.com/archive/texts/code/shapers_bez/">Bezier and Other Parametric Shaping Functions - Golan Levin and Collaborators (flong.com)</a></p><hr><p><a href="https://iquilezles.org/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><p><a href="https://iquilezles.org/articles/functions/">Inigo Quilez :: computer graphics, mathematics, shaders, fractals, demoscene and more (iquilezles.org)</a></p><hr><p><img src="https://thebookofshaders.com/05/kynd.png" alt="img"></p><hr><p><a href="https://www.shadertoy.com/view/XsXXDn">Creation by Silexars (shadertoy.com)</a></p><hr><p><a href="https://lygia.xyz/">LYGIA Shader Library</a></p><p><a href="https://graphtoy.com/">Graphtoy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习资料：&lt;a href=&quot;https://thebookofshaders.com/05/&quot;&gt;The Book of Shaders: S</summary>
      
    
    
    
    <category term="图形学" scheme="https://youxt-njnu.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="shader" scheme="https://youxt-njnu.github.io/tags/shader/"/>
    
    <category term="webgl" scheme="https://youxt-njnu.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>Cesium API学习 Ⅰ</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/Cesium%E4%B8%8A/</id>
    <published>2024-06-13T03:06:05.000Z</published>
    <updated>2024-06-13T02:41:45.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h1><p><strong>Cesium官网</strong> <a href="https://cesium.com/">Cesium: The Platform for 3D Geospatial</a></p><p><strong>CesiumJS:</strong><a href="https://cesium.com/learn/cesiumjs-learn/cesiumjs-quickstart/">CesiumJS Quickstart – Cesium</a></p><p><strong>Cesium for Unity:</strong><a href="https://cesium.com/learn/unity/">Cesium for Unity – Cesium</a></p><p><a href="https://zhuanlan.zhihu.com/p/452345666">Hello React Cesium - 知乎 (zhihu.com)</a></p><p><a href="https://cuifeng.blog.csdn.net/article/details/122828984?spm=1001.2014.3001.5502">React集成Cesium+ThreeJs流程汇总_react cesium-CSDN博客</a></p><h1 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h1><p><a href="https://www.cnblogs.com/tiandi/p/16580238.html">Cesium学习资源汇总</a></p><p><a href="https://sandcastle.cesium.com/">cesium官方案例</a></p><p><a href="https://github.com/vtxf/Cesium-Tutorials-Index">Cesium相关资料汇总</a>、<a href="https://zhuanlan.zhihu.com/p/557296232">汇总2</a></p><p><a href="https://pasu.github.io/ExamplesforCesium/examples/examples.html#Primer">cesium项目</a></p><p><a href="https://github.com/hujiulin/CesiumJS-tutorial/tree/master?tab=readme-ov-file">Cesium中文教程-github</a>, <a href="http://cesium.xin/wordpress/archives/16.html">cesium中文网</a></p><hr><p><strong>Cesium源码文件夹</strong><a href="https://sandcastle.cesium.com/">cesium官方案例</a>，<a href="https://cesium.com/learn/cesiumjs/ref-doc/">官方API文档</a></p><h1 id="Cesium基础知识"><a href="#Cesium基础知识" class="headerlink" title="Cesium基础知识"></a>Cesium基础知识</h1><p><a href="https://www.zhihu.com/column/c_1317874447190585344">学习链接</a></p><p><strong>Cesium的项目定位：B&#x2F;S架构下的客户端应用层面的三维开发框架</strong></p><p><img src="https://pic1.zhimg.com/v2-d566ed3f3b0bb0f8be5d099fb2393b10_r.jpg" alt="img"></p><p><strong>Cesium的学习路线：</strong></p><p><img src="https://pic4.zhimg.com/v2-7a32e7833314deff496ff31b5f48809f_r.jpg" alt="img"></p><p><strong>Cesium进阶之路：</strong></p><ul><li><strong>Web前端方向：</strong> Cesium与webpack（裁剪以及压缩），Cesium 与vue（框架设计， 嵌入复杂业务系统），Cesium的UI（UI 设计，定制可复用的Cesium交互界面）</li><li><strong>计算机图形学方向：</strong> WebGL深入，基于Cesium 的可视化定制（视阈、水淹、水面、热力图，流场图、飞线图、扫描图）</li><li><strong>数据预处理方向：</strong> 投影变换，空间索引，LOD ，3dtile 生成，数据存储，数据分发服务，解决超大空间数据如何在 Cesium上流畅可视化的问题。</li></ul><h2 id="Viewer"><a href="#Viewer" class="headerlink" title="Viewer"></a>Viewer</h2><p><img src="https://i.loli.net/2018/08/13/5b70f7cbf3693.jpg" alt="img"></p><p><strong>Cesium ion是一个提供瓦片图和3D地理空间数据的平台，Cesium ion支持把数据添加到用户自己的CesiumJS应用中。下面我们将使用Sentinal-2二维贴图和Cesium世界地形，二者都需要ion的支持。</strong></p><p><strong>备注</strong> 在我们使用Cesium的过程中，如果没有申请ion，同时没有自己的数据源用的cesium提供的数据源，viewer的底部常常会提示一行小的英文字母。大意就是需要申请access token.</p><ol><li><strong>打开</strong><a href="https://cesium.com/ion/">https://cesium.com/ion/</a> 然后注册一个新的账户。</li><li><strong>点击”Access Token”,</strong> 选择<em>Default</em>默认的access token拷贝到contents中。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Ion.defaultAccessToken =</span><br><span class="line">        &#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2NDk3OTUzYy01N2RjLTQyNDMtYTE1Zi0yYjgwNTJlZmYwOTAiLCJpZCI6MTk3MzM4LCJpYXQiOjE3MDg2NTc1NTh9.b8_XHsKZtIQVkUyk95dNvHHB4OE5nmebm5e_JFEIIbM&#x27;</span><br><span class="line">const viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;)</span><br></pre></td></tr></table></figure><p><strong>Viewer的类组织</strong></p><p><img src="https://img2022.cnblogs.com/blog/237138/202208/237138-20220812154924431-1555328076.png" alt="img"></p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul><li><strong>infoBox, 点击后弹出的右上方信息</strong></li><li><strong>selectionIndicator: 点击后在原地出现的绿色指示框</strong></li><li><strong>trackedEntity: Gets or sets the Entity instance currently being tracked by the camera.</strong></li><li><strong>orderIndependentTranslucency:</strong></li></ul><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li><strong>屏幕坐标，即二维笛卡尔平面坐标系</strong></li><li><strong>笛卡尔空间直角坐标&#x2F;世界坐标</strong>（红X，绿Z，蓝Y；X向前，Y向右，Z向上；</li><li><strong>地理坐标（弧度制），Cesium.Cartographic(lon, lat, height)，其中经纬度都是用弧度表示的</strong></li><li><strong>经纬度坐标，默认WGS84坐标系，</strong></li></ul><p><strong>坐标变换：</strong></p><ul><li>经纬度坐标转世界坐标：Cesium.Cartesian3.fromDegrees(lng, lat, height)</li><li>世界坐标转经纬度坐标：Cesium.Cartographic.fromCartesian(cartesian3)</li><li>地理坐标（弧度制）转经纬度坐标：lng&#x3D;Cesium.Math.toDegrees(cartographic.longitude), lat&#x3D;Cesium.Math.toDegrees(cartographic.latitude), height&#x3D;cartographic.height;</li><li>弧度转经纬度：Cesium.Math.toDegrees(radians)</li><li>经纬度转弧度：Cesium.Math.toRadians(degrees)</li><li>屏幕坐标转世界坐标：scene.globe.pick(viewer.camera.getPickRay(windowPosition), scene) —— 一定要保证屏幕坐标在球上，不然得到的就是undefined</li><li>世界坐标转屏幕坐标：Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene,cartesian3)</li></ul><p><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"><img src="https://s2.loli.net/2024/04/07/QRdUelrvqxNkWHO.png"></p><p><strong>空间变换：</strong></p><p><code>只有转换到笛卡尔坐标系后才能运用计算机图形学中的仿射变换知识进行空间位置变换如平移旋转缩放。Cesium为我们提供了如下几种很有用的变换工具类：</code></p><ul><li>Cesium.Cartesian3（相当于Point3D）</li><li>Cesium.Matrix3（3x3矩阵，用于描述旋转变换）</li><li>Cesium.Matrix4（4x4矩阵，用于描述旋转加平移变换）</li><li>Cesium.Quaternion（四元数，用于描述围绕某个向量*旋转一定角度的变换）</li><li>Cesium.Transforms(包含将位置转换为各种参考系的功能)</li></ul><p><strong>Cesium目前支持的坐标系：</strong></p><ul><li><strong>WGS1984， Terrain的TileSceme默认是这个</strong></li><li><strong>墨卡托投影，Imagery的TileSceme默认是这个</strong></li></ul><p><code>viewer.canvas.clientHeight - movement.endPosition.y</code> :</p><p><strong>在 Cesium 和其他 WebGL 应用中，</strong><code>viewer.canvas</code> 元素的坐标系通常遵循 HTML Canvas 元素的常见布局：</p><ol><li><strong>坐标系起点</strong> ：Canvas 坐标系的原点 (0, 0) 位于 Canvas 的左上角。</li><li><strong>X轴方向</strong> ：X轴从左向右增长，即坐标值从 0 增加到 <code>canvas.width</code>。</li><li><strong>Y轴方向</strong> ：Y轴从上向下增长，即坐标值从 0 增加到 <code>canvas.clientHeight</code>。</li></ol><p>针对代码行 <code>viewer.canvas.clientHeight - movement.endPosition.y</code>，这里所表达的含义和坐标参考如下：</p><ul><li><strong><code>viewer.canvas.clientHeight</code></strong> ：这是 Canvas 元素的高度，也就是 Y 轴的最大值。</li><li><strong><code>movement.endPosition.y</code></strong> ：这通常是鼠标事件（如点击或拖动事件）结束时的 Y 坐标位置。在 Cesium 中，这个坐标也遵循 Canvas 的坐标系，即 Y 坐标从上到下增大。</li></ul><h2 id="ImageryProvider"><a href="#ImageryProvider" class="headerlink" title="ImageryProvider"></a>ImageryProvider</h2><p>加载影像底图API: <code>CesiumImagery.vue, ImageryLoading.vue</code></p><blockquote><p><strong>Cesium.: ImageryLayer, IonWorldImageryStyle, SingleTileImageryProvider, GridImageryProvider, TileCoordinateImagery</strong></p><p><strong>viewer:</strong></p><ul><li><strong>.scene.imageryLayers: scene里的，更明确</strong></li><li><strong>.imageryLayers: Gets the collection of image layers that will be rendered on the globe. 更简洁，两者功能一样</strong></li></ul></blockquote><p><strong>两者对比</strong></p><p><strong>Imagery Provider使用特定的服务请求Tiles，而Layer表示来自Imagery Provider的displayed tiles。比如说,</strong></p><p><code>const layer = layers.addImageryProvider(imageryProvider);</code></p><p><strong>是</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const layer = new Cesium.ImageryLayer(imageryProvider);</span><br><span class="line">layers.add(layer);</span><br></pre></td></tr></table></figure><p>我们通常构建一个imagery provider只是为了创建一个layer; 然后我们使用layer的属性(如show、 alpha、brightness和contrast)操作该图层以改变其视觉外观。解耦decoupling imagery provider和layer使得编写新的imagery provider变得更加容易。</p><p>与上面示例中的Layer一样，imagery layer collection决定了图层绘制的顺序。layer是根据添加的顺序从底部到顶部绘制的。像Cesium中的任何其他集合一样，使用add, remove and get等函数操作imagery layer collection。此外，layer可以使用 raise、 raiseToTop、 lower 和 lowerTobottom 来重新排序。</p><p>Mapbox影像加载：</p><p>mapbox:&#x2F;&#x2F;styles&#x2F;foxziluliu1121&#x2F;clrzymvix009g01r67bowdcez</p><p><a href="https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></p><ul><li><strong>ImageryLayer, ImageryProvider,</strong></li><li>**Vector Tiles API:  **<a href="https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg">https://c.tiles.mapbox.com/v4/foxziluliu1121.66qkqrxn/2/3/0.png?access_token&#x3D;pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</a></li><li>**static tiles API:  **<code>https://api.mapbox.com/styles/v1/foxziluliu1121/clrzymvix009g01r67bowdcez/wmts?access_token=pk.eyJ1IjoiZm94emlsdWxpdTExMjEiLCJhIjoiY2xyYnJ5MXQ3MHN5ZjJrcHFxcXdwemN3bSJ9.zc_BQ5U2vldx1wROrYM4tg</code></li><li><strong>Mapbox的数据格式：</strong><ul><li><strong>mapbox.mapbox-streets-v8</strong></li><li><code>foxziluliu1121.9mqo2ps2</code></li></ul></li></ul><h2 id="terrainProvider"><a href="#terrainProvider" class="headerlink" title="terrainProvider"></a>terrainProvider</h2><p>地形图层只能有一个；</p><p>地形类型：</p><ul><li>STK World Terrain</li><li>Small Terrain</li></ul><p>terrainProvider:</p><ul><li>EllipsoidTerrainProvider</li><li>CustomHeightmapTerrainProvider</li></ul><p>Ceisum案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cesium.Terrain.fromWorldTerrain(&#123;</span><br><span class="line">    requestWaterMask: true,</span><br><span class="line">    requestVertexNormals: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="加载矢量数据"><a href="#加载矢量数据" class="headerlink" title="加载矢量数据"></a>加载矢量数据</h2><ul><li>CustomDataSource</li><li>CzmlDataSource</li><li>GeoJsonDataSource, GeoJson, TopoJson</li><li>KmlDataSource</li><li></li></ul><h2 id="空间数据可视化"><a href="#空间数据可视化" class="headerlink" title="空间数据可视化"></a>空间数据可视化</h2><h3 id="Entity-API"><a href="#Entity-API" class="headerlink" title="Entity API"></a>Entity API</h3><p>以Graphics结尾：</p><ul><li>billboard, box, corridor, cylinder, ellipse, ellipsoid, label</li><li>model, tileset, path, plane,</li><li>point, polygon, polyline, polylineVolume, rectangle, wall,</li></ul><p><strong>使用注意点：</strong></p><p>在Cesium中，<code>Cesium.BoxGraphics</code>是用来定义一个实体（Entity）的盒状几何体的可视化属性的类。这个类本身并不负责将几何体添加到场景中；相反，它被用作描述实体的视觉外观的一部分。为了在Cesium的3D场景中显示一个盒状几何体，你需要将这个几何体与一个实体（Entity）关联，并将该实体添加到Cesium的实体集合中。这就是为什么在实践中，你看到的示例代码通常会使用 <code>viewer.entities.add()</code>来创建和添加带有盒状几何体的实体。</p><p>这里是一个简化的示例，说明如何使用 **<code>Cesium.BoxGraphics</code>通过 <code>viewer.entities.add()</code>添加一个盒状几何体到场景中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;);</span><br><span class="line"></span><br><span class="line">var box = viewer.entities.add(&#123;</span><br><span class="line">    position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 200000.0),</span><br><span class="line">    box: &#123;</span><br><span class="line">        dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),</span><br><span class="line">        material: Cesium.Color.BLUE.withAlpha(0.5),</span><br><span class="line">        outline: true,</span><br><span class="line">        outlineColor: Cesium.Color.BLACK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">viewer.zoomTo(viewer.entities);</span><br></pre></td></tr></table></figure><p><strong>在这个示例中：</strong></p><ul><li><code>viewer</code>是 <code>Cesium.Viewer</code>的一个实例，它是Cesium应用的主要界面。</li><li><code>viewer.entities.add(&#123;...&#125;)</code>是添加新实体到场景的方法。这个方法的参数是一个对象，描述了实体的各种属性，包括位置（<code>position</code>）、形状（在这个例子中是一个盒子，通过 <code>box</code>属性定义）等。</li><li><code>box</code>属性使用 <code>Cesium.BoxGraphics</code>的一个实例来定义盒状几何体的外观，包括尺寸（<code>dimensions</code>）、材质（<code>material</code>）、轮廓线是否可见（<code>outline</code>）以及轮廓线的颜色（<code>outlineColor</code>）。</li></ul><p><strong>总之，</strong><code>Cesium.BoxGraphics</code>提供了定义盒状几何体视觉外观的方式，而 <code>viewer.entities.add()</code>则是将这样定义的盒状几何体实体添加到Cesium场景中的方法。这种设计允许开发者以灵活的方式创建和管理场景中的对象，同时提供了丰富的API来定义这些对象的视觉外观。</p><p>EntityCluster类+PinBuilder类：实现billboards, points, labels的聚合</p><p>Entity管理：viewer.entities的类型是EntityCollection，包括了EntityCollection类里面的所有属性和方法，如.add(), .contains(), .getById(), .remove(), .removeAll(), .removeById()</p><p>Entity拾取：viewer.scene.pick(), viewer.scene.drillPick()</p><p>Entity固定：heightReference属性值，</p><h3 id="Primitive-API"><a href="#Primitive-API" class="headerlink" title="Primitive API"></a>Primitive API</h3><p>加载数据的性能更好，可以更好的加载3D Tiles数据。</p><p>Cesium.GeometryInstance()</p><p>Cesium.EllipsoidSurfaceAppearance</p><p>Cesium.Primitive()</p><p>scene.primitives.add()</p><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p><img src="https://s2.loli.net/2024/04/04/9bVKQRSEtL6Dnw4.png"></p><p><strong>MaterialProperty:</strong></p><ul><li>Cesium.ColorMaterialProperty</li><li>Cesium.ImageMaterialProperty</li><li></li></ul><h2 id="GLTF格式"><a href="#GLTF格式" class="headerlink" title="GLTF格式"></a>GLTF格式</h2><p><img src="https://pic2.zhimg.com/80/v2-a26039ef8457742c7121e9532289da51_1440w.webp" alt="img"></p><p><strong>Cesium加载gltf:</strong></p><ul><li>viewer.entities.add()</li><li>viewer.scene.primitives.add(), Cesium.Model.fromGltf()</li></ul><h2 id="3D-Tiles格式"><a href="#3D-Tiles格式" class="headerlink" title="3D Tiles格式"></a>3D Tiles格式</h2><p>3D Tiles可以理解为带有LOD的glTF,为流式传输和渲染海量3D数据而设计，例如倾斜摄影、3D建筑、BIM&#x2F;CAD，实例化要素集和点云。3D Tiles定义了一种数据分层结构和一组切片方式。</p><p><strong>组成：</strong></p><ul><li>描述瓦片集Tileset的JSON文件 —— tileset.json</li><li>一组瓦片Tile<ul><li>瓦片对象的格式可以：b3dm, i3dm, pnts, cmpt</li></ul></li></ul><p><strong>常用类：</strong></p><ul><li>Cesium3Dtileset：用于流式传输大量的异构3D地理空间数据集；</li><li>Cesium3DTileStyle：瓦片集样式；</li><li>Cesium3DTile：数据集中的一个瓦片;</li><li>Cesium3DTileContent：瓦片内容；</li><li>Cesium3DTileFeature：瓦片集要素，用于访问Tile中批量表中的属性数据，可通过scene.pick方法来获取一个 BATCH，即三维要素。Cesium3DTileFeature.getPropertyNames() 方法获取批量表中所有属性名，Cesium3DTileFeature.getProperty(string Name) 来获取对应属性名的属性值。</li></ul><p><strong>操作：</strong></p><ol><li>加载：viewer.scene.primitives.add(new Cesium.Cesium3DTileset())</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="Cesium3DTileset"><a href="#Cesium3DTileset" class="headerlink" title="Cesium3DTileset"></a>Cesium3DTileset</h4><p><a href="https://cesium.com/learn/cesiumjs/ref-doc/Cesium3DTileset.html?classFilter=Cesium3DTileset">官网链接</a></p><p><code>featureIdLabel</code> 属性在 Cesium 的 <code>Cesium3DTileset</code> 对象中用于指定用于拾取（picking）和样式化（styling）的特征 ID 集合。以下是对这段文档的详细解释和它的作用：</p><ol><li><strong>选择特征 ID 集合</strong>：<ul><li>在 <code>Cesium3DTileset</code> 中，<code>featureIdLabel</code> 用来标识和选择特定的特征 ID 集合。这对于执行拾取操作和应用样式至关重要，尤其是当模型包含多个特征 ID 集合时。</li></ul></li><li><strong>EXT_mesh_features 和 EXT_feature_metadata</strong>：<ul><li>对于遵循 <code>EXT_mesh_features</code> 扩展的数据，<code>featureIdLabel</code> 可以是特征 ID 的 <code>label</code> 属性，如果未指定，则默认为 <code>&quot;featureId_N&quot;</code>（N 是 featureIds 数组中的索引）。</li><li>对于旧的 <code>EXT_feature_metadata</code> 扩展，没有 <code>label</code> 字段，所以特征 ID 集总是以 <code>&quot;featureId_N&quot;</code> 标识，其中 N 是所有特征 ID 列表中的索引，特征 ID 属性在特征 ID 纹理之前列出。</li></ul></li><li><strong>特征 ID 标签的自动转换</strong>：<ul><li>如果 <code>featureIdLabel</code> 被设置为一个整数 N，它将自动转换为字符串 <code>&quot;featureId_N&quot;</code>。这意味着你可以简单地指定一个索引，Cesium 会自动解析为正确的特征 ID 标签。</li></ul></li><li><strong>优先级</strong>：<ul><li>如果同时存在每个基元（per-primitive）和每个实例（per-instance）的特征 IDs，实例特征 IDs 有优先权。这对于决定在冲突时哪组特征 ID 应该被使用是重要的。</li></ul></li></ol><p><strong>作用</strong></p><ul><li><strong>拾取和样式化</strong>：<ul><li>通过指定 <code>featureIdLabel</code>，开发者可以精确控制哪一组特征 ID 被用于交互（如鼠标拾取）和视觉样式化。这在处理包含复杂数据集的大型 3D Tiles 模型时尤其有用。</li></ul></li><li><strong>灵活性和控制</strong>：<ul><li>提供了对模型特征的更精细的控制，允许开发者基于具体的特征 ID 集来应用样式和执行拾取，特别是在模型中嵌入了多种数据层（如不同的物理部分或不同类型的数据标注）时。</li></ul></li><li><strong>实验性特性</strong>：<ul><li><strong>重要的是要注意，</strong><code>featureIdLabel</code> 是一个实验性特性，属于 3D Tiles 规范的一部分，该规范尚未最终确定。因此，使用这个特性时需要谨慎，因为它可能会在没有标准弃用政策的情况下改变。</li></ul></li></ul><p><code>featureIdLabel</code> 是一个强大的工具，用于在复杂的 3D Tiles 数据集中进行精确的交互和视觉表示。它使得开发者可以根据特定的特征 ID 集来定制模型的表现和行为，增强了模型与用户交互的能力和灵活性。但是，由于它的实验性质，使用时需要关注 Cesium 更新和变更。</p><h2 id="Cesium的Property"><a href="#Cesium的Property" class="headerlink" title="Cesium的Property"></a>Cesium的Property</h2><p><strong>基本property</strong></p><ul><li>CompositeProperty</li><li>ConstantProperty</li><li>SampledProperty</li><li>TimeIntervalCollectionProperty</li></ul><p><strong>Material的property</strong></p><p><strong>PositionProperty</strong></p><p><strong>其他</strong></p><p><img src="https://pic4.zhimg.com/80/v2-9cb0b7aa0c14747709a9dc455c7dccf7_720w.webp" alt="img"></p><h2 id="组件重写"><a href="#组件重写" class="headerlink" title="组件重写"></a>组件重写</h2><p>homeButton回到主要页面；</p><p>Geocoder组件通过OSM服务实现；</p><p>自定义BaseLayerPicker:</p><ul><li>viewer.baseLayerPicker.viewModel.imageryProviderViewModels</li><li>viewer.baseLayerPicker.viewModel.terrainProviderViewModels</li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>let handler &#x3D; new Cesium.ScreenSpaceEventHandler(viewer.canvas)</p><p>let eventType &#x3D; Cesium.ScreenSpaceEventType.LEFT_CLICK</p><p>handler.setInputAction((event) &#x3D;&gt; {}, eventType)</p><p>Keyboard: camera.moveForward, .moveBackward, .moveUp, .moveDown, .moveLeft, .moveRight</p><p>场景渲染: scene.preUpdate, .postUpdate, .preRender, .postRender</p><h2 id="相机控制"><a href="#相机控制" class="headerlink" title="相机控制"></a>相机控制</h2><p>viewer.flyTo(target, options)</p><p>viewer.zoomTo(target, offset)</p><p>viewer.camera.flyTo(options)</p><p>viewer.camera.flyToBoundingSphere(boundingSphere, options)</p><p>viewer.camera.lookAt(target, offset)</p><p>viewer.camera.lookAtTransform(transform, offset)</p><p>viewer.camera.setView(options)</p><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>距离</p><p>面积</p><p>handler.setInputAction(func(), Cesium.ScreenSpacEventType.RIGHT_CLICK)</p><h2 id="调试面板"><a href="#调试面板" class="headerlink" title="调试面板"></a>调试面板</h2><p>CesiumInspector</p><blockquote><p>了解Cesium渲染效果以及性能调优</p><p>viewer.extend(Cesium.viewerCesiumInspectorMixin)</p></blockquote><p>Cesium3DTilesInspector</p><blockquote><p>用于监视3D Tiles数据的监视器</p><p>viewer.extend(Cesium.viewerCesium3DTilesInspector)</p></blockquote><h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><p>new Cesium.ParticleSystem()</p><h2 id="场景后处理"><a href="#场景后处理" class="headerlink" title="场景后处理"></a>场景后处理</h2><p>postProgress类</p><p>postProgressStage</p><p>postProgressStageLibrary</p><p>postProgressStageCollection</p><h2 id="与第三方库集成"><a href="#与第三方库集成" class="headerlink" title="与第三方库集成"></a>与第三方库集成</h2><p>ThreeJS</p><ol><li>初始化两个容器，和各自的渲染器</li><li>调整各自的渲染频率和相机一致</li><li>加入要展示的内容</li></ol><p>ECharts</p><p>Heatmap</p><p>Turf</p><h2 id="源码打包"><a href="#源码打包" class="headerlink" title="源码打包"></a>源码打包</h2><p>gulp, webpack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初步了解&quot;&gt;&lt;a href=&quot;#初步了解&quot; class=&quot;headerlink&quot; title=&quot;初步了解&quot;&gt;&lt;/a&gt;初步了解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Cesium官网&lt;/strong&gt; &lt;a href=&quot;https://cesium.com/&quot;&gt;Cesium</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="Cesium" scheme="https://youxt-njnu.github.io/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>WebAPIs 知识点梳理</title>
    <link href="https://youxt-njnu.github.io/2024/06/13/WebAPIs/"/>
    <id>https://youxt-njnu.github.io/2024/06/13/WebAPIs/</id>
    <published>2024-06-13T01:33:26.000Z</published>
    <updated>2024-06-13T02:42:39.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ol><li><strong>API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现</strong></li><li><strong>Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。</strong></li><li><strong>Web API 一般都有输入和输出（ 函数的传参和返回值），Web API 很多都是方法（函数）</strong></li><li><strong>学习 Web API 可以结合前面学习内置对象方法的思路学习</strong></li></ol><h2 id="1-2-DOM-介绍"><a href="#1-2-DOM-介绍" class="headerlink" title="1.2. DOM 介绍"></a>1.2. DOM 介绍</h2><h3 id="1-2-1-什么是DOM"><a href="#1-2-1-什么是DOM" class="headerlink" title="1.2.1 什么是DOM"></a>1.2.1 什么是DOM</h3><p>**文档对象模型（Document Object Model，简称DOM），是 **<a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p><p><strong>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</strong></p><blockquote><p><strong>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</strong></p></blockquote><h3 id="1-2-2-DOM树"><a href="#1-2-2-DOM树" class="headerlink" title="1.2.2. DOM树"></a>1.2.2. DOM树</h3><p><img src="https://s2.loli.net/2024/06/13/bIQ3ek6qtW9CFBm.png"></p><p><strong>DOM树又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。</strong></p><ul><li><strong>文档：一个页面就是一个文档，DOM中使用document表示</strong></li><li><strong>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</strong></li><li><strong>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</strong></li></ul><p><strong>DOM把以上内容都看成对象；</strong></p><h2 id="1-3-获取元素"><a href="#1-3-获取元素" class="headerlink" title="1.3. 获取元素"></a>1.3. 获取元素</h2><p><strong>为什么要获取页面元素？</strong></p><p><strong>例如：我们想要操作页面上的某部分(显示&#x2F;隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。</strong></p><h3 id="1-3-1-根据ID获取"><a href="#1-3-1-根据ID获取" class="headerlink" title="1.3.1. 根据ID获取"></a>1.3.1. 根据ID获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementById(id)</span><br><span class="line">作用：根据ID获取元素对象</span><br><span class="line">参数：id值，区分大小写的字符串</span><br><span class="line">返回值：元素对象 或 null</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面</span><br><span class="line">        var timer = document.getElementById(&#x27;time&#x27;);</span><br><span class="line">        console.log(timer);</span><br><span class="line">        console.log(typeof timer);</span><br><span class="line">        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法</span><br><span class="line">        console.dir(timer);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/13/srPCptxVckEZMWQ.png"></p><h3 id="1-3-2-根据标签名获取元素"><a href="#1-3-2-根据标签名获取元素" class="headerlink" title="1.3.2. 根据标签名获取元素"></a>1.3.2. 根据标签名获取元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：document.getElementsByTagName(&#x27;标签名&#x27;) 或者 element.getElementsByTagName(&#x27;标签名&#x27;) </span><br><span class="line">作用：根据标签名获取元素对象</span><br><span class="line">参数：标签名</span><br><span class="line">返回值：元素对象集合（伪数组，数组元素是元素对象）</span><br></pre></td></tr></table></figure><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的</span><br><span class="line">        var lis = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">        console.log(lis[0]);</span><br><span class="line">        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式</span><br><span class="line">        for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">            console.log(lis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签</span><br><span class="line">        var nav = document.getElementById(&#x27;nav&#x27;); // 这个获得nav 元素</span><br><span class="line">        var navLis = nav.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">        console.log(navLis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br><strong>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历</strong><br><strong>2.得到元素对象是动态的</strong></p><p><strong>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</strong></p><h3 id="1-3-3-H5新增获取元素方式"><a href="#1-3-3-H5新增获取元素方式" class="headerlink" title="1.3.3. H5新增获取元素方式"></a>1.3.3. H5新增获取元素方式</h3><p><strong>1.document.getElementsByclassName(‘类名’);&#x2F;&#x2F;根据类名返回元素对象集合</strong><br><strong>2.document.uerySelector(‘选择器)；&#x2F;&#x2F;根据指定选择器返回第一个元素对象</strong><br><strong>3.document.querySelectorAll(‘选择器’); &#x2F;&#x2F;根据指定选择器返回</strong><br><strong>注意：</strong><br><strong>querySelector和querySelectorAll里面的选择器需要加符号，比如：document.querySelector(‘#nav’);</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. getElementsByClassName 根据类名获得某些元素集合</span><br><span class="line">        var boxs = document.getElementsByClassName(&#x27;box&#x27;);</span><br><span class="line">        console.log(boxs);</span><br><span class="line">        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav</span><br><span class="line">        var firstBox = document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">        console.log(firstBox);</span><br><span class="line">        var nav = document.querySelector(&#x27;#nav&#x27;);</span><br><span class="line">        console.log(nav);</span><br><span class="line">        var li = document.querySelector(&#x27;li&#x27;);</span><br><span class="line">        console.log(li);</span><br><span class="line">        // 3. querySelectorAll()返回指定选择器的所有元素对象集合</span><br><span class="line">        var allBox = document.querySelectorAll(&#x27;.box&#x27;);</span><br><span class="line">        console.log(allBox);</span><br><span class="line">        var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">        console.log(lis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-获取特殊元素（body，html）"><a href="#1-3-4-获取特殊元素（body，html）" class="headerlink" title="1.3.4 获取特殊元素（body，html）"></a>1.3.4 获取特殊元素（body，html）</h3><p><strong>获取body元素 1.doucumnet.body&#x2F;&#x2F;返回body元素对象</strong><br><strong>获取html元素 1.document.documentElement&#x2F;&#x2F;返回html元素对象</strong></p><h2 id="1-4-事件基础"><a href="#1-4-事件基础" class="headerlink" title="1.4. 事件基础"></a>1.4. 事件基础</h2><h3 id="1-4-1-事件概述"><a href="#1-4-1-事件概述" class="headerlink" title="1.4.1. 事件概述"></a>1.4.1. 事件概述</h3><p><strong>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</strong></p><p>**简单理解： **<strong>触发 — 响应机制</strong>。</p><p><strong>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</strong></p><h3 id="1-4-2-事件三要素"><a href="#1-4-2-事件三要素" class="headerlink" title="1.4.2. 事件三要素"></a>1.4.2. 事件三要素</h3><ul><li><strong>事件源（谁）：触发事件的元素</strong></li><li><strong>事件类型（什么事件）： 例如 click 点击事件</strong></li><li><strong>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</strong></li></ul><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 点击一个按钮，弹出对话框</span><br><span class="line">        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span><br><span class="line">        //(1) 事件源 事件被触发的对象   谁  按钮</span><br><span class="line">        var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span><br><span class="line">        //(3) 事件处理程序  通过一个函数赋值的方式 完成</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            alert(&#x27;点秋香&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-执行事件的步骤"><a href="#1-4-3-执行事件的步骤" class="headerlink" title="1.4.3. 执行事件的步骤"></a>1.4.3. 执行事件的步骤</h3><p><strong>1.获取事件源</strong><br><strong>2.注册事件（绑定事件）</strong><br><strong>3.添加事件处理程序（采取函数赋值形式）</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 执行事件步骤</span><br><span class="line">        // 点击div 控制台输出 我被选中了</span><br><span class="line">        // 1. 获取事件源</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.绑定事件 注册事件</span><br><span class="line">        // div.onclick </span><br><span class="line">        // 3.添加事件处理程序 </span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            console.log(&#x27;我被选中了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-常见的鼠标事件"><a href="#1-4-4-常见的鼠标事件" class="headerlink" title="1.4.4. 常见的鼠标事件"></a>1.4.4. 常见的鼠标事件</h3><p><img src="https://s2.loli.net/2024/06/13/DPX2E1hGYSAmIjo.png"></p><h3 id="1-4-5-分析事件三要素（见实操案例）"><a href="#1-4-5-分析事件三要素（见实操案例）" class="headerlink" title="1.4.5. 分析事件三要素（见实操案例）"></a>1.4.5. 分析事件三要素（见实操案例）</h3><ul><li><strong>下拉菜单三要素</strong></li><li><strong>关闭广告三要素</strong></li></ul><h2 id="1-5-操作元素"><a href="#1-5-操作元素" class="headerlink" title="1.5. 操作元素"></a>1.5. 操作元素</h2><p>**    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）**</p><h3 id="1-5-1-改变元素内容（获取或设置）"><a href="#1-5-1-改变元素内容（获取或设置）" class="headerlink" title="1.5.1. 改变元素内容（获取或设置）"></a>1.5.1. 改变元素内容（获取或设置）</h3><p><strong>element.innerText</strong><br><strong>从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</strong><br><strong>element.innerHTML</strong><br><strong>起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</strong></p><p><strong>innerText改变元素内容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;显示当前系统时间&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;某个时间&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;1123&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 当我们点击了按钮，  div里面的文字会发生变化</span><br><span class="line">        // 1. 获取元素 </span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2.注册事件</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // div.innerText = &#x27;2019-6-6&#x27;;</span><br><span class="line">            div.innerHTML = getDate();</span><br><span class="line">        &#125;</span><br><span class="line">        function getDate() &#123;</span><br><span class="line">            var date = new Date();</span><br><span class="line">            // 我们写一个 2019年 5月 1日 星期三</span><br><span class="line">            var year = date.getFullYear();</span><br><span class="line">            var month = date.getMonth() + 1;</span><br><span class="line">            var dates = date.getDate();</span><br><span class="line">            var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">            var day = date.getDay();</span><br><span class="line">            return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day];</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>innerText和innerHTML的区别</strong></p><ul><li><strong>获取内容时的区别：</strong></li></ul><p>**    innerText会去除空格和换行，而innerHTML会保留空格和换行    **</p><ul><li><strong>设置内容时的区别：</strong></li></ul><p>**    innerText不会识别html，而innerHTML会识别**</p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        我是文字</span><br><span class="line">        &lt;span&gt;123&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // innerText 和 innerHTML的区别 </span><br><span class="line">        // 1. innerText 不识别html标签 非标准  去除空格和换行</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span><br><span class="line">        div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br><span class="line">        // 这两个属性是可读写的  可以获取元素里面的内容</span><br><span class="line">        var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">        console.log(p.innerText);</span><br><span class="line">        console.log(p.innerHTML);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-常用元素的属性操作"><a href="#1-5-2-常用元素的属性操作" class="headerlink" title="1.5.2. 常用元素的属性操作"></a>1.5.2. 常用元素的属性操作</h3><p><strong>1.innerText,innerHTML 改变元素内容</strong><br><strong>2.src、href</strong><br><strong>3.id、alt、title</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;</span><br><span class="line">    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 修改元素属性  src</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var ldh = document.getElementById(&#x27;ldh&#x27;);</span><br><span class="line">        var zxy = document.getElementById(&#x27;zxy&#x27;);</span><br><span class="line">        var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line">        // 2. 注册事件  处理程序</span><br><span class="line">        zxy.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/zxy.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;张学友思密达&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        ldh.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/ldh.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;刘德华&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-案例：分时问候"><a href="#1-5-3-案例：分时问候" class="headerlink" title="1.5.3. 案例：分时问候"></a>1.5.3. 案例：分时问候</h3><p><img src="https://s2.loli.net/2024/06/13/ki3jF4NTnWQKRpL.png"></p><h3 id="1-5-4-表单元素的属性操作"><a href="#1-5-4-表单元素的属性操作" class="headerlink" title="1.5.4. 表单元素的属性操作"></a>1.5.4. 表单元素的属性操作</h3><p><strong>利用DOM可以操作如下表单元素的属性：</strong><br><strong>type、value、checked、selected、disabled</strong></p><p><strong>获取属性的值</strong></p><blockquote><p><strong>元素对象.属性名</strong></p></blockquote><p><strong>设置属性的值</strong></p><blockquote><p><strong>元素对象.属性名 &#x3D; 值</strong></p><p><strong>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</strong></p></blockquote><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var input = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // 表单里面的值 文字内容是通过 value 来修改的</span><br><span class="line">            input.value = &#x27;被点击了&#x27;;</span><br><span class="line">            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span><br><span class="line">            // btn.disabled = true;</span><br><span class="line">            this.disabled = true;</span><br><span class="line">            // this 指向的是事件函数的调用者 btn</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-案例：仿京东显示密码"><a href="#1-5-5-案例：仿京东显示密码" class="headerlink" title="1.5.5. 案例：仿京东显示密码"></a>1.5.5. 案例：仿京东显示密码</h3><p><img src="https://s2.loli.net/2024/06/13/G9BXQyrReOTxI65.png"></p><h3 id="1-5-6-样式属性操作"><a href="#1-5-6-样式属性操作" class="headerlink" title="1.5.6. 样式属性操作"></a>1.5.6. 样式属性操作</h3><p><strong>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</strong></p><p><strong>常用方式</strong></p><p><strong>1.element.style  行内样式操作</strong><br><strong>2.element.className  类名样式操作</strong></p><h4 id="方式1：通过操作style属性"><a href="#方式1：通过操作style属性" class="headerlink" title="方式1：通过操作style属性"></a>方式1：通过操作style属性</h4><blockquote><p><strong>元素对象的style属性也是一个对象！</strong></p><p><strong>元素对象.style.样式属性 &#x3D; 值;</strong></p></blockquote><p><strong>注意：</strong><br><strong>1.JS 里面的样式采取小驼峰命名法比如fontsize、backgroundColor</strong><br><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            // div.style里面的属性 采取驼峰命名法 </span><br><span class="line">            this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            this.style.width = &#x27;250px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：淘宝点击关闭二维码"><a href="#案例：淘宝点击关闭二维码" class="headerlink" title="案例：淘宝点击关闭二维码"></a>案例：淘宝点击关闭二维码</h4><p><img src="https://s2.loli.net/2024/06/13/M17o26KwY4Tx9yR.png"></p><h4 id="案例：循环精灵图背景"><a href="#案例：循环精灵图背景" class="headerlink" title="案例：循环精灵图背景"></a>案例：循环精灵图背景</h4><p><img src="https://s2.loli.net/2024/06/13/RHjG1g8Dzhw4kuB.png"></p><h4 id="案例：显示隐藏文本框内容"><a href="#案例：显示隐藏文本框内容" class="headerlink" title="案例：显示隐藏文本框内容"></a>案例：显示隐藏文本框内容</h4><p><img src="https://s2.loli.net/2024/06/13/yQxe7VT3YXpkrU5.png"></p><h4 id="方式2：通过操作className属性"><a href="#方式2：通过操作className属性" class="headerlink" title="方式2：通过操作className属性"></a>方式2：通过操作className属性</h4><blockquote><p><strong>元素对象.className &#x3D; 值;</strong></p><p><strong>因为class是关键字，所有使用className。</strong></p></blockquote><p><strong>注意：</strong><br><strong>1,如果样式修改较多，可以采取操作类名方式更改元素样式。</strong><br><strong>2.class因为是个保留字，因此使用className来操作元素类名属性</strong><br><strong>3.className 会直接更改元素的类名，会覆盖原先的类名。</strong></p><p><strong>案例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br><span class="line">        var test = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        test.onclick = function() &#123;</span><br><span class="line">            // this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            // this.style.color = &#x27;#fff&#x27;;</span><br><span class="line">            // this.style.fontSize = &#x27;25px&#x27;;</span><br><span class="line">            // this.style.marginTop = &#x27;100px&#x27;;</span><br><span class="line"></span><br><span class="line">            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br><span class="line">            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br><span class="line">            // this.className = &#x27;change&#x27;;</span><br><span class="line">            this.className = &#x27;first change&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="案例：密码框格式提示错误信息"><a href="#案例：密码框格式提示错误信息" class="headerlink" title="案例：密码框格式提示错误信息"></a>案例：密码框格式提示错误信息</h4><p><img src="https://s2.loli.net/2024/06/13/6OkmXxy9sSY3bv7.png"></p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2024/06/13/5KReAgoXG1VIpdZ.png"></p><h2 id="1-6-H5自定义属性"><a href="#1-6-H5自定义属性" class="headerlink" title="1.6. H5自定义属性"></a>1.6. H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</strong></p><p><strong>自定义属性获取是通过getAttribute(‘属性’) 获取。</strong></p><p><strong>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</strong></p><p><strong>H5给我们新增了自定义属性：</strong></p><p><strong>1.设置H5自定义属性</strong><br><strong>H5规定自定义属性data-开头做为属性名并目赋值。</strong><br><strong>比如</strong> <code>&lt;div data-index=&quot;1&quot;&gt;</code><strong><code>&lt;/div&gt;</code></strong><br><strong>或者使用JS设置</strong><br><strong>element.setAttribute(‘data-index’,2)</strong></p><p><strong>2.获取H5自定义属性</strong><br><strong>1.兼容性获取element.getAttribute(‘data-index’):</strong><br><strong>2.H5新增element.dataset.index或者element.dataset[‘index’]   ie11才开始支持</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // console.log(div.getTime);</span><br><span class="line">        console.log(div.getAttribute(&#x27;getTime&#x27;));</span><br><span class="line">        div.setAttribute(&#x27;data-time&#x27;, 20);</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-index&#x27;));</span><br><span class="line">        console.log(div.getAttribute(&#x27;data-list-name&#x27;));</span><br><span class="line">        // h5新增的获取自定义属性的方法 它只能获取data-开头的</span><br><span class="line">        // dataset 是一个集合里面存放了所有以data开头的自定义属性</span><br><span class="line">        console.log(div.dataset);</span><br><span class="line">        console.log(div.dataset.index);</span><br><span class="line">        console.log(div.dataset[&#x27;index&#x27;]);</span><br><span class="line">        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span><br><span class="line">        console.log(div.dataset.listName);</span><br><span class="line">        console.log(div.dataset[&#x27;listName&#x27;]);//data-list-name</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="1-7-节点操作"><a href="#1-7-节点操作" class="headerlink" title="1.7. 节点操作"></a>1.7. 节点操作</h2><p><strong>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</strong></p><ul><li><strong>元素节点nodeType为1</strong></li><li><strong>属性节点nodeType为2</strong></li><li><strong>文本节点nodeType为3(文本节点包含文字、空格、换行等)</strong></li></ul><p><strong>我们在实际开发中，节点操作主要操作的是元素节点</strong></p><h3 id="1-7-1-节点层级"><a href="#1-7-1-节点层级" class="headerlink" title="1.7.1. 节点层级"></a>1.7.1. 节点层级</h3><p>**    利用 DOM 树可以把节点划分为不同的层级关系，常见的是**<strong>父子兄层级关系</strong>。</p><p><img src="https://s2.loli.net/2024/06/13/Ogtv9nHuEMZqyhA.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.parentNode</span><br><span class="line">parentNode.childNodes</span><br><span class="line">parentNode.children</span><br><span class="line">parentNode.firstChild</span><br><span class="line">parentNode.lastChild</span><br><span class="line">parentNode.firstElementChild</span><br><span class="line">parentNode.lastElementChild</span><br><span class="line">parentNode.children[0]</span><br><span class="line">parentNode.children[parentNode.children.length-1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.nextSibling</span><br><span class="line">node.previousSibling</span><br><span class="line">node.nextElementSibling</span><br><span class="line">node.previousElementSibling</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   function getNextElementSibling(element) &#123;</span><br><span class="line">      var el = element;</span><br><span class="line">      while (el = el.nextSibling) &#123;</span><br><span class="line">        if (el.nodeType === 1) &#123;</span><br><span class="line">            return el;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;//是元素节点，就返回</span><br><span class="line">      return null;//不是元素节点，返回null</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><h3 id="1-7-2-节点操作"><a href="#1-7-2-节点操作" class="headerlink" title="1.7.2. 节点操作"></a>1.7.2. 节点操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createElement(&#x27;tagName&#x27;)</span><br><span class="line">node.appendChild(child)</span><br><span class="line">node.insertBefore(child,指定元素)</span><br><span class="line">node.removeChild(child)</span><br><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GIS集成案例汇报</title>
    <link href="https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/"/>
    <id>https://youxt-njnu.github.io/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%8A%A5-GIS/</id>
    <published>2024-05-31T01:33:26.000Z</published>
    <updated>2024-06-13T01:51:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>地理信息集成课程汇报（与TLQ合作，感谢！）</p><p><img src="https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png" alt="1.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ogFZUMn2bLBsxHP.png" alt="2.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/2FgX7cUQiRzIfJd.png" alt="3.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/dLPKfYwCpylSWih.png" alt="4.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8fx5bjDVnpERuOd.png" alt="5.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=341481481&bvid=BV1CR4y1A78S&cid=717991642&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/M4D6bAowy8iZ7Yv.png" alt="7.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/imL2PkUsGajWxbF.png" alt="8.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/ColDRx4TSG5Amh6.png" alt="9.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/8cQWF73tgzKTjCn.png" alt="10.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/5JTNYdMo6naiU3O.png" alt="11.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/rdKkcylwaPmAG8i.png" alt="幻灯片12.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/kgHosDmy3AGECqT.png" alt="幻灯片13.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/GWtdX9sfi8VUIx1.png" alt="幻灯片14.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/1KMZYlqzh2Wy5s4.png" alt="幻灯片15.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/1KJnBzQ7edx4SYV.png" alt="幻灯片16.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/jo2gOWszI619Y7v.png" alt="幻灯片17.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/hnAwgIOZo3TtSs6.png" alt="幻灯片18.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/o76d5WrFwU4b8Gf.png" alt="幻灯片19.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/O9aCgdNFh4GmoyL.png" alt="幻灯片20.PNG"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=1555426770&bvid=BV1h1421y7nD&cid=1566027972&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p><img src="https://s2.loli.net/2024/05/31/4SUDLPcJXMGzops.png" alt="幻灯片21.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/eVAFpTj6o1LwKv3.png" alt="幻灯片22.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/cfq8XexUyz16S5k.png" alt="幻灯片23.PNG"></p><p><img src="https://s2.loli.net/2024/05/31/oN3VCuPRYZwMB8z.png" alt="幻灯片24.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地理信息集成课程汇报（与TLQ合作，感谢！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/31/3d8OD9FK1LaHZYx.png&quot; alt=&quot;1.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli</summary>
      
    
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/categories/AR/"/>
    
    
    <category term="AR" scheme="https://youxt-njnu.github.io/tags/AR/"/>
    
    <category term="汇报PPT" scheme="https://youxt-njnu.github.io/tags/%E6%B1%87%E6%8A%A5PPT/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A2/</id>
    <published>2024-03-17T01:33:26.000Z</published>
    <updated>2024-03-17T01:42:27.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="11-对象"><a href="#11-对象" class="headerlink" title="11. 对象"></a>11. 对象</h2><ul><li><p><strong>利用字面量创建对象</strong></p><h5 id="使用对象字面量创建对象："><a href="#使用对象字面量创建对象：" class="headerlink" title="使用对象字面量创建对象："></a><strong>使用对象字面量创建对象</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就是花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法；&#123; &#125; 里面采取键值对的形式表示 </span><br></pre></td></tr></table></figure><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var star = &#123;</span><br><span class="line">    name : &#x27;pink&#x27;,</span><br><span class="line">    age : 18,</span><br><span class="line">    sex : &#x27;男&#x27;,</span><br><span class="line">    sayHi : function()&#123;</span><br><span class="line">        alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中 star即是创建的对象。</p></li></ul></li><li><p>对象的使用</p><ul><li><p>对象的属性</p><ul><li>对象中存储具体数据的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储函数的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”</li><li>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号<br><strong>示例代码如下：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(star.name)     // 调用名字属性</span><br><span class="line">console.log(star[&#x27;name&#x27;])  // 调用名字属性</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>调用对象的方法</strong></p><ul><li>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号<br>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>变量、属性、函数、方法总结</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</span><br></pre></td></tr></table></figure><ul><li>变量：单独声明赋值，单独存在</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征<br>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器</li><li>函数：单独存在的，通过“函数名()”的方式就可以调用</li><li>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能</li></ul></li></ul></li><li><p><strong>利用 new Object 创建对象</strong></p><ul><li><p>创建空对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var andy = new Obect();</span><br></pre></td></tr></table></figure><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li>通过对象操作属性和方法的方式，来为对象增加属性和方法<br>示例代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">andy.name = &#x27;pink&#x27;;</span><br><span class="line">andy.age = 18;</span><br><span class="line">andy.sex = &#x27;男&#x27;;</span><br><span class="line">andy.sayHi = function()&#123;</span><br><span class="line">    alert(&#x27;大家好啊~&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Object() ：第一个字母大写</li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 &#x3D;  值;</li></ul></li></ul></li><li><p><strong>利用构造函数创建对象</strong></p><ul><li>构造函数<ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 构造函数名(形参1,形参2,形参3) &#123;</span><br><span class="line">     this.属性名1 = 参数1;</span><br><span class="line">     this.属性名2 = 参数2;</span><br><span class="line">     this.属性名3 = 参数3;</span><br><span class="line">     this.方法名 = 函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数的调用格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new 构造函数名(实参1，实参2，实参3)</span><br></pre></td></tr></table></figure><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>构造函数约定首字母大写。</li><li>函数内的属性和方法前面需要添加<strong>this</strong> ，表示当前对象的属性和方法。</li><li><strong>构造函数中不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ol></li><li><p><strong>其他</strong><br>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul></li></ul></li><li><p><strong>new关键字的作用</strong></p><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h3 id="5-3-遍历对象"><a href="#5-3-遍历对象" class="headerlink" title="5.3 遍历对象"></a>5.3 遍历对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for...in 语句用于对数组或者对象的属性进行循环操作。</span><br><span class="line"></span><br><span class="line">其语法如下：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (变量 in 对象名字) &#123;</span><br><span class="line">    // 在此执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var k in obj) &#123;</span><br><span class="line">    console.log(k);      // 这里的 k 是属性名</span><br><span class="line">    console.log(obj[k]); // 这里的 obj[k] 是属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-内置对象"><a href="#1-1-内置对象" class="headerlink" title="1.1 内置对象"></a>1.1 内置对象</h3><p>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象<br><strong>前面两种对象是JS 基础内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是</strong>最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发</p><p>**JavaScript 提供了多个内置对象：Math、 Date 、Array、String等    **</p><h3 id="1-2-查文档"><a href="#1-2-查文档" class="headerlink" title="1.2 查文档"></a>1.2 查文档</h3><p>查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN&#x2F;W3C来查询。<br>Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。<br>MDN:<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h3 id="1-3-Math对象"><a href="#1-3-Math对象" class="headerlink" title="1.3 Math对象"></a>1.3 Math对象</h3><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()&#x2F;Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p><strong>注意：上面的方法使用时必须带括号</strong></p><p>获取指定范围内的随机整数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用对象封装自己的数学对象  里面有 PI 最大值和最小值</span><br><span class="line">        var myMath = &#123;</span><br><span class="line">            PI: 3.141592653,</span><br><span class="line">            max: function() &#123;</span><br><span class="line">                var max = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &gt; max) &#123;</span><br><span class="line">                        max = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return max;</span><br><span class="line">            &#125;,</span><br><span class="line">            min: function() &#123;</span><br><span class="line">                var min = arguments[0];</span><br><span class="line">                for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    if (arguments[i] &lt; min) &#123;</span><br><span class="line">                        min = arguments[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(myMath.PI);</span><br><span class="line">        console.log(myMath.max(1, 5, 9));</span><br><span class="line">        console.log(myMath.min(1, 5, 9));</span><br></pre></td></tr></table></figure><h3 id="1-4-日期对象"><a href="#1-4-日期对象" class="headerlink" title="1.4 日期对象"></a>1.4 日期对象</h3><p>Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var now = new Date();</span><br></pre></td></tr></table></figure><ul><li>获取指定时间的日期对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var future = new Date(&#x27;2019/5/1&#x27;);</span><br></pre></td></tr></table></figure><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p><strong>使用Date实例的方法和属性</strong><br><img src="https://s2.loli.net/2024/03/17/Bt7q6c4fYMbLpgr.png" alt="图片1"></p></li><li><p>通过Date实例获取总毫米数</p><ul><li>总毫秒数的含义<br>基于1970年1月1日（世界标准时间）起的毫秒数</li><li>获取总毫秒数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实例化Date对象</span><br><span class="line">var now = new Date();</span><br><span class="line">// 1. 用于获取对象的原始值</span><br><span class="line">console.log(date.valueOf())    </span><br><span class="line">console.log(date.getTime())    </span><br><span class="line">// 2. 简单写可以这么做</span><br><span class="line">var now = + new Date();            </span><br><span class="line">// 3. HTML5中提供的方法，有兼容性问题</span><br><span class="line">var now = Date.now();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-数组对象"><a href="#1-5-数组对象" class="headerlink" title="1.5 数组对象"></a>1.5 数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li>字面量方式<ul><li>示例代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1,&quot;test&quot;,true];</span><br></pre></td></tr></table></figure></li></ul></li><li>new Array()<ul><li><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li>如果只传入一个参数，则参数规定了数组的长度</li><li>如果传入了多个参数，则参数称为数组的元素</li></ul></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li>instanceof 运算符<ul><li>instanceof 可以判断一个对象是否是某个构造函数的实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line">console.log(obj instanceof Array); // false</span><br></pre></td></tr></table></figure></li></ul></li><li>Array.isArray()<ul><li>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 23];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(Array.isArray(arr));   // true</span><br><span class="line">console.log(Array.isArray(obj));   // false</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><ul><li>数组中有进行增加、删除元素的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/uebmUwin5S3j91r.png" alt="pushpop"><br>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</li></ul><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li><strong>数组中有对数组本身排序的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/DOPv2ZCqMBnpmsN.png"><br>注意：sort方法需要传入参数来设置升序、降序排序<ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul></li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><ul><li>数组中有获取数组指定元素索引值的方法，部分方法如下表<br><img src="https://s2.loli.net/2024/03/17/IFPG26TQdrbw1NK.png"></li></ul><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><ul><li><strong>数组中有把数组转化为字符串的方法，部分方法如下表</strong><br><img src="https://s2.loli.net/2024/03/17/fGBnsd1I65ZK7tz.png"><br><strong>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</strong></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>数组中还有其他操作方法，同学们可以在课下自行查阅学习<br><img src="https://s2.loli.net/2024/03/17/3iDC7uAtBHdKRGr.png"></li></ul><h3 id="1-6-字符串对象"><a href="#1-6-字符串对象" class="headerlink" title="1.6 字符串对象"></a>1.6 字符串对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 下面代码有什么问题？</span><br><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure><p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="line">var temp = new String(&#x27;andy&#x27;);</span><br><span class="line">// 2. 赋值给我们声明的字符变量</span><br><span class="line">str = temp;</span><br><span class="line">// 3. 销毁临时变量</span><br><span class="line">temp = null;</span><br></pre></td></tr></table></figure><h4 id="字符串的不可变"><a href="#字符串的不可变" class="headerlink" title="字符串的不可变"></a>字符串的不可变</h4><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><p>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>由于字符串的不可变，在****大量拼接字符串的时候会有效率问题</p><h4 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p><p><img src="https://s2.loli.net/2024/03/17/7QdYZoglVsuOrxw.png"></p><p><strong>案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;oabcoefoxyozzopp&quot;;</span><br><span class="line">var index = str.indexOf(&#x27;o&#x27;);</span><br><span class="line">var num = 0;</span><br><span class="line">// console.log(index);</span><br><span class="line">while (index !== -1) &#123;</span><br><span class="line">      console.log(index);</span><br><span class="line">      num++;</span><br><span class="line">      index = str.indexOf(&#x27;o&#x27;, index + 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;o出现的次数是: &#x27; + num);</span><br></pre></td></tr></table></figure><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p><p><img src="https://s2.loli.net/2024/03/17/6S5Z3Ezf4BYJH9T.png"></p><p>案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      var o = &#123;&#125;;</span><br><span class="line">      var str = &quot;abcoefoxyozzopp&quot;;</span><br><span class="line">      //   for (var k in str) &#123;</span><br><span class="line">      //     if (o[str[k]]) &#123;</span><br><span class="line">      //       o[str[k]]++;</span><br><span class="line">      //     &#125; else &#123;</span><br><span class="line">      //       o[str[k]] = 1;</span><br><span class="line">      //     &#125;</span><br><span class="line">      //   &#125;</span><br><span class="line">      for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        var chars = str.charAt(i);</span><br><span class="line">        if (o[chars]) &#123;</span><br><span class="line">          o[chars]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          o[chars] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(o);</span><br><span class="line">      var max = 0;</span><br><span class="line">      var ch = &quot;&quot;;</span><br><span class="line">      for (var k in o) &#123;</span><br><span class="line">        if (o[k] &gt; max) &#123;</span><br><span class="line">          max = o[k];</span><br><span class="line">          ch = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(max);</span><br><span class="line">      console.log(ch);</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p><strong>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</strong></p><p><img src="https://s2.loli.net/2024/03/17/zO5PavVILoNGh9l.png"></p><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p><strong>replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.replace(被替换的字符串， 要替换为的字符串)；</span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p><strong>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.split(&quot;分割字符&quot;)</span><br></pre></td></tr></table></figure><h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><p><strong>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;//构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function f1(x) &#123; // x = p</span><br><span class="line">    console.log(x.name); // 2.刘德华   </span><br><span class="line">    x.name = &quot;张学友&quot;;</span><br><span class="line">    console.log(x.name); // 3. 张学友  </span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;刘德华&quot;); //实例</span><br><span class="line">console.log(p.name);    // 1.刘德华</span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name);    // 4. 张学友</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/"/>
    <id>https://youxt-njnu.github.io/2024/03/17/JS%E5%9F%BA%E7%A1%80%E2%85%A1/</id>
    <published>2024-03-17T01:27:26.000Z</published>
    <updated>2024-03-17T01:32:58.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><blockquote><p>整理自黑马Pink前端的课程资料；<br>算是入门第一步；<br>后续有时间的话，再看看书，多了解了解</p></blockquote><h2 id="7-运算符（操作符）"><a href="#7-运算符（操作符）" class="headerlink" title="7. 运算符（操作符）"></a>7. 运算符（操作符）</h2><p><strong>浮点数的精度问题</strong></p><p><strong>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;    <span class="comment">// 结果不是 0.3，而是：0.30000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.07</span> * <span class="number">100</span>);   <span class="comment">// 结果不是 7，  而是：7.000000000000001</span></span><br></pre></td></tr></table></figure><p><strong>所以：不要直接判断两个浮点数是否相等 !</strong></p><h2 id="8-断点调试"><a href="#8-断点调试" class="headerlink" title="8. 断点调试"></a>8. 断点调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">断点调试的流程：</span><br><span class="line">1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点</span><br><span class="line">2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。</span><br><span class="line">3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</span><br></pre></td></tr></table></figure><p><strong>标识符命名规范</strong></p><ul><li><strong>变量、函数的命名必须要有意义</strong></li><li><strong>变量的名称一般用名词</strong></li><li><strong>函数的名称一般用动词</strong></li></ul><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><p><strong>JS 中创建数组有两种方式：</strong></p><ul><li><p><strong>利用  new 创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>() ；</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// 创建一个新的空数组</span></span><br></pre></td></tr></table></figure><p><strong>注意 Array () ，A 要大写</strong></p></li><li><p><strong>利用数组字面量创建数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []；</span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>**数组的字面量是方括号 [ ] **</li><li><strong>声明数组并赋值称为数组的初始化</strong></li><li><strong>这种字面量方式也是我们以后最多使用的方式</strong></li></ul></li><li><p><strong>数组元素的类型</strong><br><strong>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrStus = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">12</span>,<span class="literal">true</span>,<span class="number">28.9</span>];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 获取数组中的第2个元素</span></span><br><span class="line"><span class="title function_">alert</span>(arrStus[<span class="number">1</span>]);    </span><br></pre></td></tr></table></figure><p><strong>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</strong></p><ul><li><p><strong>数组的长度</strong><br><strong>数组的长度：默认情况下表示数组中元素的个数</strong><br><strong>使用“数组名.length”可以访问数组元素的数量（数组长度）。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrStus = [1,2,3];</span><br><span class="line">alert(arrStus.length);  // 3</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p></li><li><p><strong>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</strong></p></li><li><p><strong>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</strong></p></li><li><p><strong>数组的length属性可以被修改：</strong></p></li><li><p><strong>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</strong></p></li><li><p><strong>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</strong></p></li></ul><h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明函数</span><br><span class="line">function 函数名() &#123;</span><br><span class="line">    //函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>function 是声明函数的关键字,必须小写</strong></p></li><li><p><strong>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</strong></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用函数</span><br><span class="line">函数名();  // 通过调用函数名来执行函数体代码</span><br></pre></td></tr></table></figure><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p><strong>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</strong></p></li><li><p><strong>具有 length 属性</strong></p></li><li><p><strong>按索引方式储存数据</strong></p></li><li><p><strong>不具有数组的 push , pop 等方法</strong><br><strong>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</strong></p></li></ul><h3 id="函数案例"><a href="#函数案例" class="headerlink" title="函数案例"></a>函数案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</span><br></pre></td></tr></table></figure><h3 id="函数的两种声明方式"><a href="#函数的两种声明方式" class="headerlink" title="函数的两种声明方式"></a>函数的两种声明方式</h3><ul><li><p><strong>自定义函数方式(命名函数)</strong><br><strong>利用函数关键字 function 自定义函数方式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明定义方式</span><br><span class="line">function fn() &#123;...&#125;</span><br><span class="line">// 调用  </span><br><span class="line">fn();  </span><br></pre></td></tr></table></figure><ul><li><strong>因为有名字，所以也被称为命名函数</strong></li><li><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></li></ul></li><li><p><strong>函数表达式方式(匿名函数）</strong><br>**利用函数表达式方式的写法如下： **</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是函数表达式写法，匿名函数后面跟分号结束</span><br><span class="line">var fn = function()&#123;...&#125;；</span><br><span class="line">// 调用的方式，函数调用必须写到函数体下面</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ul><li><strong>因为函数没有名字，所以也被称为匿名函数</strong></li><li>**这个fn 里面存储的是一个函数  **</li><li><strong>函数表达式方式原理跟声明变量方式是一致的</strong></li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ul></li></ul><h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10 - 作用域"></a>10 - 作用域</h2><h3 id="1-1-作用域概述"><a href="#1-1-作用域概述" class="headerlink" title="1.1 作用域概述"></a>1.1 作用域概述</h3><p><strong>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</strong></p><p><strong>JavaScript（es6前）中的作用域有两种：</strong></p><ul><li><strong>全局作用域</strong></li><li><strong>局部作用域（函数作用域）</strong></li></ul><h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于所有代码执行的环境(整个script标签内部)或独立的js文件。</span><br></pre></td></tr></table></figure><h3 id="1-3-局部作用域"><a href="#1-3-局部作用域" class="headerlink" title="1.3 局部作用域"></a>1.3 局部作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用于函数内的代码环境，就是局部作用域。 </span><br><span class="line">因为跟函数有关系，所以也称为函数作用域。</span><br></pre></td></tr></table></figure><h3 id="1-4-jS没有块级作用域"><a href="#1-4-jS没有块级作用域" class="headerlink" title="1.4 jS没有块级作用域"></a>1.4 jS没有块级作用域</h3><ul><li><strong>块作用域由 { } 包括。</strong></li><li><strong>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用；</strong><br><strong>js中没有块级作用域（在ES6之前）</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">  var num = 123;</span><br><span class="line">  //console.log(num); //123</span><br><span class="line">&#125;</span><br><span class="line">console.log(num);   //123</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-变量的作用域"><a href="#1-5-变量的作用域" class="headerlink" title="1.5 变量的作用域"></a>1.5 变量的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在JavaScript中，根据作用域的不同，变量可以分为两种：</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li><li><strong>局部变量</strong></li></ul><p><strong>2.1 全局变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</span><br></pre></td></tr></table></figure><ul><li><strong>全局变量在代码的任何位置都可以使用</strong></li><li><strong>在全局作用域下 var 声明的变量 是全局变量</strong></li><li><strong>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</strong></li></ul><p><strong>2.2 局部变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</span><br></pre></td></tr></table></figure><ul><li><strong>局部变量只能在该函数内部使用</strong></li><li><strong>在函数内部 var 声明的变量是局部变量</strong></li><li><strong>函数的形参实际上就是局部变量</strong></li></ul><p><strong>2.3 全局变量和局部变量的区别</strong></p><ul><li><strong>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</strong></li><li><strong>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</strong></li></ul><h3 id="1-6-作用域链"><a href="#1-6-作用域链" class="headerlink" title="1.6 - 作用域链"></a>1.6 - 作用域链</h3><p><strong>只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在</strong>**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例分析1：</span><br><span class="line">function f1() &#123;</span><br><span class="line">    var num = 123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">        console.log( num );//123</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line">var num = 456;</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域链：采取就近原则的方式来查找变量最终的值</span><br><span class="line">var a = 1;</span><br><span class="line">function fn1() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    var b = &#x27;22&#x27;;</span><br><span class="line">    fn2();</span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        var a = 3;</span><br><span class="line">        fn3();</span><br><span class="line">        function fn3() &#123;</span><br><span class="line">            var a = 4;</span><br><span class="line">            console.log(a); //a的值 4</span><br><span class="line">            console.log(b); //b的值 22</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><p><img src="file://F:/20-%E6%B1%82%E8%81%8C/02-%E5%89%8D%E7%AB%AF/images/js/%E5%9B%BE%E7%89%872-16779152458061.png?lastModify=1710638944"></p><h3 id="1-7-预解析"><a href="#1-7-预解析" class="headerlink" title="1.7 - 预解析"></a>1.7 - 预解析</h3><p><strong>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。</strong></p><p><strong>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：</strong></p><p><strong>预解析和代码执行。</strong></p><ul><li><strong>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</strong>，预解析也叫做变量、函数提升。</li><li><strong>代码执行： 从上到下执行JS语句。</strong><br><strong>注意：****预解析会把变量和函数的声明在代码执行之前执行完成。</strong></li></ul><p><strong>变量预解析：</strong></p><p><strong>变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(num);  // undefined</span><br><span class="line">var num = 10;</span><br><span class="line">//注意：变量提升只提升声明，不提升赋值</span><br></pre></td></tr></table></figure><p><strong>函数预解析：</strong></p><p><strong>函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;打印&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：控制台打印字符串 — ”打印“</strong></p><p><strong>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！</strong></p><p><strong>函数表达式声明函数问题：</strong></p><p><strong>函数表达式创建函数，会执行变量提升</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn();</span><br><span class="line">var  fn = function() &#123;</span><br><span class="line">    console.log(&#x27;想不到吧&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：报错提示 ”fn is not a function”</strong></p><blockquote><p><strong>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理自黑马Pink前端的课程资料；&lt;br&gt;算是入门第一步；&lt;br&gt;后续有时间的话，再看看书，多了解</summary>
      
    
    
    
    <category term="大前端" scheme="https://youxt-njnu.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://youxt-njnu.github.io/tags/JS/"/>
    
    <category term="基础知识" scheme="https://youxt-njnu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>react+vite+hexo|项目呈现</title>
    <link href="https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"/>
    <id>https://youxt-njnu.github.io/2024/03/10/react+vite%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</id>
    <published>2024-03-10T03:51:26.000Z</published>
    <updated>2024-03-09T03:55:48.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yayuya/p/17046666.html">Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/7208946311885586492">通过Hexo + Github Pages部署你的react项目 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yayuya/p/17046666.html&quot;&gt;Vite项目打包配置详解 - 爵岚 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post</summary>
      
    
    
    
    <category term="周边扩展" scheme="https://youxt-njnu.github.io/categories/%E5%91%A8%E8%BE%B9%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
    <category term="Hexo" scheme="https://youxt-njnu.github.io/tags/Hexo/"/>
    
    <category term="个人博客" scheme="https://youxt-njnu.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅱ(补)</title>
    <link href="https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%9821/"/>
    <id>https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%9821/</id>
    <published>2024-03-09T03:34:05.000Z</published>
    <updated>2024-06-13T02:14:51.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关库补充"><a href="#相关库补充" class="headerlink" title="相关库补充"></a>相关库补充</h1><h2 id="react-vertical-timeline-component"><a href="#react-vertical-timeline-component" class="headerlink" title="react-vertical-timeline-component"></a>react-vertical-timeline-component</h2><p><code>react-vertical-timeline-component</code> 是一个React库，用于创建和显示垂直时间线。这个库提供了一种简单而有效的方式来展示按时间顺序排列的事件或步骤，非常适合用于展示项目里程碑、历史事件、工作经历等。它基于React开发，因此可以轻松地集成到现有的React应用中。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>易于使用</strong>：通过提供的组件和属性，开发者可以快速构建出美观、响应式的时间线。</li><li><strong>高度可定制</strong>：支持自定义颜色、图标和内容，使时间线能够匹配应用的风格和主题。</li><li><strong>响应式设计</strong>：时间线会自动适应不同屏幕尺寸，保证在移动设备和桌面设备上都能良好展示。</li><li><strong>动画效果</strong>：内置动画效果，为时间线的展示增添视觉吸引力。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要开始使用 <code>react-vertical-timeline-component</code>，首先需要将它添加到你的React项目中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react-vertical-timeline-component</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">yarn add react-vertical-timeline-component</span><br></pre></td></tr></table></figure><p>接下来，你可以在你的组件中引入并使用时间线组件及其相关的子组件。以下是一个简单的示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">VerticalTimeline</span>,</span><br><span class="line">  <span class="title class_">VerticalTimelineElement</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-vertical-timeline-component&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;react-vertical-timeline-component/style.min.css&#x27;</span>; <span class="comment">// 引入样式文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyTimeline</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">VerticalTimeline</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">VerticalTimelineElement</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element--work&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">date</span>=<span class="string">&quot;2011 - present&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">iconStyle</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> &#x27;<span class="attr">rgb</span>(<span class="attr">33</span>, <span class="attr">150</span>, <span class="attr">243</span>)&#x27;, <span class="attr">color:</span> &#x27;#<span class="attr">fff</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      // <span class="attr">icon</span>=<span class="string">&#123;</span>&lt;<span class="attr">WorkIcon</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span> <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element-title&quot;</span>&gt;</span>Creative Director<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">className</span>=<span class="string">&quot;vertical-timeline-element-subtitle&quot;</span>&gt;</span>Miami, FL<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Creative Direction, User Experience, Visual Design, Project Management, Team Leading</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">VerticalTimelineElement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 可以添加更多的 VerticalTimelineElement 组件来展示其他事件 */&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">VerticalTimeline</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyTimeline</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>VerticalTimeline</code>是容纳所有时间线元素的容器，而 <code>VerticalTimelineElement</code>代表时间线上的单个事件或里程碑。你可以通过传递不同的props来定制每个时间线元素的外观和内容。</p><h3 id="自定义和样式"><a href="#自定义和样式" class="headerlink" title="自定义和样式"></a>自定义和样式</h3><p><code>react-vertical-timeline-component</code>提供了多种方式来定制时间线的样式和行为：</p><ul><li><strong>颜色和图标</strong>：通过 <code>iconStyle</code>属性自定义图标样式，以及通过 <code>icon</code>属性添加自定义图标。</li><li><strong>内容布局</strong>：每个 <code>VerticalTimelineElement</code>可以包含标题、副标题和任意的HTML内容，允许灵活地展示信息。</li><li><strong>自定义类名</strong>：可以为时间线元素添加自定义CSS类名，进一步通过CSS来定制样式。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>react-vertical-timeline-component</code>是一个功能丰富且易于使用的React库，它能够帮助开发者在应用中快速创建出美观、响应式的垂直时间线。通过广泛的定制选项，它能够满足多种展示需求，使得时间线既能传达必要的信息，又具有吸引人的视觉效果。</p><h2 id="emailjs-x2F-browser"><a href="#emailjs-x2F-browser" class="headerlink" title="@emailjs&#x2F;browser"></a>@emailjs&#x2F;browser</h2><p><code>@emailjs/browser</code> 是一个JavaScript库，用于在客户端直接从前端应用中发送电子邮件，无需后端服务器。通过使用 EmailJS 服务，开发者可以在Web页面中集成电子邮件发送功能，而不需要编写服务器端代码或存储用户的电子邮件凭据。这使得在联系表单、通知系统或任何需要发送电子邮件的场景中，实现邮件发送变得异常简单和安全。</p><h3 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>无服务器</strong>：不需要自己的服务器来发送电子邮件，减少了开发和维护成本。</li><li><strong>简单易用</strong>：提供了简洁的API，可以快速在前端代码中集成和使用。</li><li><strong>安全</strong>：不需要在客户端暴露敏感信息，如SMTP服务器登录凭据等。</li><li><strong>灵活性</strong>：支持自定义电子邮件模板，可以根据需要发送不同内容的邮件。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>**通过npm或yarn安装 **<code>@emailjs/browser</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @emailjs/browser</span><br><span class="line"># 或者</span><br><span class="line">yarn add @emailjs/browser</span><br></pre></td></tr></table></figure><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>**要使用 **<code>@emailjs/browser</code>发送电子邮件，首先需要在 EmailJS 网站上注册账户，创建邮件模板，并获取必要的服务ID、模板ID和用户ID。</p><p>**在React项目中使用 **<code>emailjs</code>或任何其他依赖于环境变量的服务时，创建一个 <code>.env.local</code>文件的主要目的是为了安全和配置的灵活性。这个文件被用来存储敏感信息和项目配置，如API密钥、服务ID、用户ID等，这些信息对于应用的运行至关重要，但你不希望它们被直接硬编码到源代码中或被提交到版本控制系统（如Git）中。这样做主要有以下几个原因：</p><ol><li><strong>安全性</strong>：保护你的敏感信息不被公开，如API密钥和密码。如果这些信息被硬编码在应用程序的源代码中，并且源代码被上传到了公开的代码仓库，那么这些敏感信息就有泄露的风险。</li><li><strong>配置的灵活性</strong>：允许你在不同的环境（开发、测试、生产等）中使用不同的配置，而不需要改变代码。比如，在开发环境和生产环境中使用不同的API密钥。</li><li><strong>便于维护</strong>：将配置从代码中分离，使得配置的更改更加容易，而不需要每次都触摸代码本身。</li></ol><p><code>.env.local</code>是一种特殊的 <code>.env</code>文件，它被设计用来在你的本地开发环境中覆盖 <code>.env</code>文件中的默认设置。React和许多其他现代前端框架都支持使用 <code>.env</code>文件来定义环境变量。这些变量在构建过程中会被嵌入到最终的JavaScript包中，因此在运行时可以访问它们。</p><p>**要在React项目中使用 **<code>.env.local</code>中定义的环境变量，你需要遵循以下步骤：</p><ol><li>**在项目根目录下创建一个 **<code>.env.local</code>文件。</li><li>**在 **<code>.env.local</code>文件中添加环境变量，遵循 <code>REACT_APP_</code>前缀的规则。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REACT_APP_EMAILJS_USER_ID=你的用户ID</span><br><span class="line">REACT_APP_EMAILJS_SERVICE_ID=你的服务ID</span><br><span class="line">REACT_APP_EMAILJS_TEMPLATE_ID=你的模板ID</span><br></pre></td></tr></table></figure></li><li>**在你的React应用中，你可以通过 **<code>process.env.REACT_APP_EMAILJS_USER_ID</code>这样的方式访问这些变量。</li></ol><p>**使用 **<code>.env.local</code>文件是一种实践，旨在提高项目的安全性和配置的灵活性，特别是当涉及到处理敏感信息时。这种方法有助于避免将敏感数据暴露给公众，同时还提供了在不同环境下轻松切换配置的能力。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_APP_EMAILJS_SERVICE_ID=service_5bezaam</span><br><span class="line">VITE_APP_EMAILJS_TEMPLATE_ID=template_dafnzfi</span><br><span class="line">VITE_APP_EMAILJS_PUBLIC_KEY=JpbkxBEdlS8faxCrq</span><br></pre></td></tr></table></figure><p><strong>在使用Vite作为构建工具的项目中，环境变量的命名遵循特定的前缀规则，这是为了确保这些变量在构建时被正确地加载和注入到项目中。</strong></p><ol><li><strong><code>VITE_</code>前缀</strong>：Vite要求所有应该暴露给项目前端代码的环境变量都必须以 <code>VITE_</code>为前缀。这是一个约定，用于保护你的环境变量，确保只有带有这个前缀的变量才会被包含在最终的前端构建中。这样可以防止无意间将敏感的服务器端环境变量暴露给客户端。</li><li>**<code>APP</code>**：这个部分不是必需的，但它是一个常见的做法，用于指示这些环境变量是应用级别的。加上 <code>APP</code>（或者其他类似的标识符）有助于在环境变量中创建一个逻辑上的分组，使得它们更易于管理和识别。</li><li>**<code>EMAILJS_SERVICE_ID</code>、<code>EMAILJS_TEMPLATE_ID</code>、<code>EMAILJS_PUBLIC_KEY</code>**：这些部分具体指明了变量的用途。在这个例子中，它们分别用于标识EmailJS服务的ID、模板的ID和公共密钥。这样的命名方法有助于清晰地表达每个环境变量的作用和关联的服务。</li></ol><p>**你可以修改环境变量的名称，但需要保持 **<code>VITE_</code>前缀不变，以确保Vite能够正确地处理这些变量。如果你决定更改变量名称（比如，将 <code>VITE_APP_EMAILJS_PUBLIC_KEY</code>更改为 <code>VITE_APP_EMAILJS_KEY</code>），你需要在项目中引用这些环境变量的地方也做相应的更改，以确保一致性和正确的变量访问。</p><p><strong>然后，可以在前端代码中使用这些ID来发送邮件：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import emailjs from &#x27;@emailjs/browser&#x27;;</span><br><span class="line"></span><br><span class="line">// 在组件加载时初始化 EmailJS 服务（例如，在React组件的useEffect中）</span><br><span class="line">emailjs.init(&quot;your-user-id&quot;); // 使用你的User ID替换&quot;your-user-id&quot;</span><br><span class="line"></span><br><span class="line">// 创建发送邮件的函数</span><br><span class="line">const sendEmail = () =&gt; &#123;</span><br><span class="line">  const templateParams = &#123;</span><br><span class="line">    to_name: &#x27;收件人名字&#x27;,</span><br><span class="line">    from_name: &#x27;发件人名字&#x27;,</span><br><span class="line">    message: &#x27;邮件内容&#x27;,</span><br><span class="line">    // ...其他模板参数</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  emailjs.send(&#x27;your-service-id&#x27;, &#x27;your-template-id&#x27;, templateParams)</span><br><span class="line">    .then((response) =&gt; &#123;</span><br><span class="line">       console.log(&#x27;SUCCESS!&#x27;, response.status, response.text);</span><br><span class="line">    &#125;, (error) =&gt; &#123;</span><br><span class="line">       console.log(&#x27;FAILED...&#x27;, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>@emailjs/browser</code>适用于多种场景，如：</p><ul><li><strong>联系表单</strong>：在静态网站或SPA中收集用户反馈或查询，直接从前端发送邮件。</li><li><strong>注册确认</strong>：在用户注册流程中发送欢迎邮件或确认邮件。</li><li><strong>通知系统</strong>：向用户发送通知邮件，如订单状态更新、活动提醒等。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>@emailjs/browser</code>提供了一种简单而强大的方式，使得在没有后端的情况下直接从浏览器发送电子邮件成为可能。通过减少服务器端的需求和复杂性，开发者可以更专注于用户体验和前端功能的实现，同时保持应用的安全性和可维护性。</p><h2 id="tailwindcss"><a href="#tailwindcss" class="headerlink" title="tailwindcss"></a>tailwindcss</h2><p><a href="https://tailwindcss.com/docs/installation">官方文档</a></p><p><a href="https://segmentfault.com/a/1190000022622923">15分钟入门</a></p><p><a href="http://www.xcj.com/front-end-life/CSS/TailwindCSS.html">入门教程</a></p><p><strong>延申插件：</strong></p><blockquote><p><strong>Typography</strong></p><p><strong>Forms</strong></p><p><strong>Aspect Ratio</strong></p><p><strong>Container Queries</strong></p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><strong>安装和配置Tailwind CSS主要涉及两个步骤，这两个步骤通过上述命令完成。下面是对这两条命令的解释：</strong></p><ol><li><code>npm install -D tailwindcss postcss autoprefixer</code></li></ol><p><strong>这条命令使用npm（Node.js包管理器）来安装三个开发依赖：</strong></p><ul><li>**<code>tailwindcss</code>**：Tailwind CSS库本身，它是一个功能类优先的CSS框架，允许你通过在HTML中添加类来直接应用样式，从而加快开发速度。</li><li>**<code>postcss</code>**：PostCSS是一个用JavaScript工具和插件转换CSS代码的工具。Tailwind CSS依赖于PostCSS，因为它实际上是一组PostCSS插件，用于生成和处理Tailwind的工具类。</li><li>**<code>autoprefixer</code>**：Autoprefixer是一个PostCSS插件，用于自动添加浏览器厂商前缀到CSS规则中，确保CSS属性在不同的浏览器中能够正常工作。这对于兼容性是非常有用的。</li></ul><p><code>-D</code>标志表示这些包被安装为开发依赖项，这意味着它们只在开发过程中需要，在生产环境的构建过程中不会被使用。</p><ol start="2"><li><code>npx tailwindcss init -p</code></li></ol><p><strong>这条命令用于初始化Tailwind CSS的配置文件，并自动生成PostCSS配置文件。</strong></p><ul><li><code>npx</code>是一个npm包运行器，它允许你执行安装在本地node_modules目录中的包而不需要全局安装这些包。</li><li><code>tailwindcss init</code>是Tailwind CLI的一部分，用于生成 <code>tailwind.config.js</code>文件。这个文件是Tailwind CSS的配置文件，你可以在其中自定义你的设计系统，如颜色、字体大小、间距等。</li><li><code>-p</code>标志表示同时生成 <code>postcss.config.js</code>文件，这是PostCSS的配置文件，Tailwind CSS作为PostCSS插件运行时需要这个文件。这个标志确保了 <code>autoprefixer</code>也被包含在PostCSS配置中，因为它通常与Tailwind CSS一起使用以确保最佳的浏览器兼容性。</li></ul><p><strong>总的来说，这两个命令共同完成了Tailwind CSS和其依赖的安装，以及为项目生成必要的配置文件，让你可以开始使用Tailwind CSS来构建项目。</strong></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>**在 **<code>tailwind.config.js</code>文件中，<code>content</code>、<code>theme</code>、和 <code>plugins</code>是Tailwind CSS配置的主要部分，它们各自承担着不同的角色，以便定制和控制Tailwind CSS的行为。下面是它们各自的作用：</p><ol><li><code>content</code></li></ol><p><code>content</code>属性用于指定Tailwind CSS应该扫描哪些文件来寻找类名。这是Tailwind CSS的一个重要特性，称为PurgeCSS（在Tailwind CSS v3.x中，这一特性已经内置且默认启用），它用于移除最终CSS文件中未使用的样式，以减小文件大小和提高加载速度。</p><p>**在 **<code>tailwind.config.js</code>文件中，你可以这样配置 <code>content</code>属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  content: [&#x27;./src/**/*.&#123;html,js,jsx,ts,tsx&#125;&#x27;],</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**这告诉Tailwind CSS扫描你项目中的 **<code>src</code>目录下所有的HTML和JavaScript文件，包括React（<code>.jsx</code>）、TypeScript（<code>.ts</code>、<code>.tsx</code>）等文件，来确定哪些样式是实际被使用的。</p><ol start="2"><li><code>theme</code></li></ol><p><code>theme</code>属性用于定制Tailwind CSS提供的默认设计系统。你可以在这里调整颜色、字体、间距等默认设置，或者添加自己的设计令牌（tokens）。这使得Tailwind CSS极其灵活，能够适应几乎任何设计需求。</p><p><strong>例如，你可以定制主题颜色和字体大小：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;</span><br><span class="line">      colors: &#123;</span><br><span class="line">        &#x27;custom-blue&#x27;: &#x27;#5b6d5b&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      fontSize: &#123;</span><br><span class="line">        &#x27;big&#x27;: &#x27;2rem&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>extend</code>属性用于扩展而不是覆盖默认的主题设置。</p><p>**在 **<code>tailwind.config.js</code>文件的 <code>extend</code>对象中对 <code>colors</code>的设置允许你自定义或扩展默认的颜色系统。这种方式让你可以添加新的颜色或覆盖现有颜色的某些阶级（如100-900这样的权重级别通常用于表示颜色的浅到深）。这里是对给出的设置的详细解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colors: &#123;</span><br><span class="line">  black: &#123;</span><br><span class="line">    DEFAULT: &#x27;#000&#x27;,</span><br><span class="line">    500: &#x27;#1D2235&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>**<code>black</code>**：</p><ul><li><code>DEFAULT</code>：这里指定了 <code>black</code>颜色的默认值为 <code>#000</code>。在Tailwind CSS中，如果你直接使用 <code>text-black</code>或 <code>bg-black</code>这样的类，将会应用这个默认颜色值。</li><li><code>500</code>：除了默认值之外，还定义了一个 <code>500</code>阶级的黑色 <code>black-500</code>为 <code>#1D2235</code>。这意味着你可以通过 <code>text-black-500</code>或 <code>bg-black-500</code>来使用这个特定的深度值。</li></ul><ol start="3"><li><code>plugins</code></li></ol><p><code>plugins</code>属性允许你添加第三方插件或自定义的插件到Tailwind CSS中，以扩展其功能。这些插件可以添加新的工具类、组件，或是在构建过程中使用的功能性钩子。</p><p><strong>你可以这样添加插件：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&#x27;@tailwindcss/forms&#x27;),</span><br><span class="line">    // 其他插件...</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**这个例子中，我们添加了 **<code>@tailwindcss/forms</code>插件，它是一个官方插件，用于重置和定制表单元素的样式。</p><p><strong>总的来说，</strong><code>tailwind.config.js</code>中的 <code>content</code>、<code>theme</code>、和 <code>plugins</code>配置项提供了一个强大的机制来定制和优化你的Tailwind CSS集成，使其更适合你的项目需求。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>**在Tailwind CSS中，使用 **<code>@tailwind</code>指令在 <code>index.css</code>（或任何主CSS文件）中导入Tailwind的层是初始化和使用Tailwind CSS框架的关键步骤。这些指令告诉Tailwind CSS在构建过程中将其功能类和样式注入到CSS文件中。下面是这三个指令的作用：</p><ol><li><code>@tailwind base;</code></li></ol><p>**这个指令导入Tailwind的基础样式，这些样式包括浏览器样式的重置和归一化以及一些基本的HTML元素样式。这为你的项目提供了一个一致的基线样式，确保在不同浏览器中具有一致的外观和感觉。基础样式还包括对标准元素（如 **<code>&lt;h1&gt;</code>到 <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>等）的默认样式设置，这样你可以在不需要额外类的情况下立即开始工作。</p><ol start="2"><li><code>@tailwind components;</code></li></ol><p>**这个指令导入由你或其他人创建的组件类。在Tailwind中，组件不是指UI组件库中的组件，而是一组可以重用的工具类组合，用于构建界面元素。通过在 **<code>tailwind.config.js</code>文件中自定义或扩展，你可以创建自定义的组件样式，这些自定义样式将通过这个指令被引入。这允许你定义一些常用的样式模式，如按钮、卡片等，以便在整个项目中重用。</p><ol start="3"><li><code>@tailwind utilities;</code></li></ol><p><strong>这个指令导入Tailwind的工具类，这是Tailwind CSS最强大的特性之一。工具类包括了边距、填充、文字大小、颜色等几乎所有CSS属性的类。这些类设计为原子类，意味着每个类都具有单一的责任，你可以组合它们来创建复杂的设计。这种方法提供了极高的灵活性和定制性，使得你能够快速构建和调整界面。</strong></p><p>**通过在CSS文件中包含这些 **<code>@tailwind</code>指令，你实际上是在激活Tailwind CSS的强大功能，使其成为构建和设计你的Web项目的基础。这种方法允许你利用Tailwind的所有预定义样式和工具，同时保持了扩展和自定义的能力。</p><h3 id="Tailwind-CSS-IntelliSense"><a href="#Tailwind-CSS-IntelliSense" class="headerlink" title="Tailwind CSS IntelliSense"></a>Tailwind CSS IntelliSense</h3><p><strong>Tailwind CSS IntelliSense 是一个 Visual Studio Code (VSCode) 插件，它极大地增强了在使用VSCode开发时使用Tailwind CSS的体验。这个插件提供了一系列功能，旨在提高开发效率和减少编码错误。主要功能包括：</strong></p><ul><li><strong>类名提示</strong>：在编写HTML或JSX等文件时，<strong>插件会提供Tailwind CSS类名的自动完成建议</strong>。这意味着你开始键入时，它会显示可用的Tailwind 类名列表，让你快速选择而不需要记住每个具体的类名。</li><li><strong>悬停后可以样式预览</strong>：当你将鼠标悬停在某个Tailwind CSS类名上时，IntelliSense会显示一个小弹窗，其中展示了这个类名对应的CSS样式。这使得理解和检查类名的作用变得直接且方便。</li><li><strong>错误检查</strong>：插件能够识别并高亮显示不存在的Tailwind CSS类名，帮助你快速定位并修正错误或拼写问题。</li><li><strong>颜色预览</strong>：对于颜色相关的类名（如背景、文字颜色等），IntelliSense会在类名旁边显示一个小色块，直观地展示这个类名对应的颜色，增强了颜色选择的直观性。</li><li><strong>@apply指令支持</strong>：当使用 <code>@apply</code>指令在CSS或SCSS文件中应用Tailwind CSS实用程序类时，IntelliSense也会提供自动完成和验证功能。</li><li><strong>自定义配置支持</strong>：IntelliSense插件能够读取并根据你的 <code>tailwind.config.js</code>文件提供自定义配置的自动完成建议，这包括你添加或修改的颜色、间距等自定义主题设置。</li></ul><p><strong>总之，Tailwind CSS IntelliSense 插件通过提供强大的代码完成、验证和预览功能，极大地提高了使用Tailwind CSS进行开发的效率和舒适度。它帮助开发者更快地编写代码，减少错误，并在编码时获得即时的样式反馈。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅳ</title>
    <link href="https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%984/"/>
    <id>https://youxt-njnu.github.io/2024/03/09/threejs%E5%AE%9E%E6%88%984/</id>
    <published>2024-03-09T03:26:05.000Z</published>
    <updated>2024-06-13T02:14:58.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>本文是对Island.jsx及其相关文件的学习解读，内容中含ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关案例补充"><a href="#相关案例补充" class="headerlink" title="相关案例补充"></a>相关案例补充</h1><h2 id="Bird案例"><a href="#Bird案例" class="headerlink" title="Bird案例"></a>Bird案例</h2><h3 id="const-x3D-useGLTF-birdScene"><a href="#const-x3D-useGLTF-birdScene" class="headerlink" title="const &#x3D; useGLTF(birdScene)"></a>const &#x3D; useGLTF(birdScene)</h3><p><code>&lt;primitive /&gt;</code> is a component from React Three Fiber that allows you to directly include three.js objects into the React component tree. By setting the <code>object</code> prop to <code>scene</code>, you’re telling React Three Fiber to render the entire GLTF scene, which <code>useGLTF</code> hook returns, without having to manually construct the scene with React components. This is a straightforward way to include complex 3D models and their associated hierarchies into your 3D scene.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这种形式</span><br><span class="line">&lt;mesh</span><br><span class="line">   geometry=&#123;nodes.pCube11_rocks1_0.geometry&#125;</span><br><span class="line">   material=&#123;materials.PaletteMaterial001&#125;</span><br><span class="line">/&gt;</span><br><span class="line">//和这种形式</span><br><span class="line">&lt;mesh</span><br><span class="line">   ref=&#123;birdRef&#125;</span><br><span class="line">   position=&#123;[-5, 2, 1]&#125;</span><br><span class="line">   scale=&#123;[0.003, 0.003, 0.003]&#125;</span><br><span class="line">&gt;</span><br><span class="line">   &lt;primitive object=&#123;scene&#125; /&gt;</span><br><span class="line">&lt;/mesh&gt;</span><br></pre></td></tr></table></figure><p>**第一种形式直接使用了GLTF模型中的具体节点（如 **<code>pCube11_rocks1_0</code>）和材质（如 <code>PaletteMaterial001</code>）来创建一个 <code>&lt;mesh&gt;</code>。这种方式允许你精细控制模型的每个部分，例如指定使用模型中的哪个节点和哪种材质。</p><p>**第二种形式使用了 **<code>&lt;primitive object=&#123;scene&#125; /&gt;</code>来直接渲染整个场景（<code>scene</code>），这里的 <code>scene</code>是 <code>useGLTF</code>钩子返回的整个GLTF场景对象。通过这种方式，你可以简单快捷地在React Three Fiber中渲染整个3D模型，而不需要逐个指定模型的每个部分。这种方法适用于当你想要原封不动地渲染整个模型，而不需要对模型的单独部分进行精细控制。</p><h3 id="Unity中导入glb-x2F-gltf"><a href="#Unity中导入glb-x2F-gltf" class="headerlink" title="Unity中导入glb&#x2F;gltf"></a>Unity中导入glb&#x2F;gltf</h3><p><strong>在Unity中导入GLB模型，可以使用Unity的GLTFUtility插件，支持导入GLB和GLTF格式的3D模型。首先需要从</strong><a href="https://github.com/Siccity/GLTFUtility">GitHub获取URL</a>，然后在Unity中使用package manager来进行安装。导入插件后，你可以直接将GLB模型拖拽到Unity的Assets文件夹中，插件会自动处理模型的导入过程。这个过程简单快速，不需要复杂的配置。</p><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame()"></a>useFrame()</h3><p>**在 **<code>useFrame</code>回调函数中，<code>&#123; clock, camera &#125;</code>是从React Three Fiber的渲染循环中解构出来的对象。<code>clock</code>是一个 <code>THREE.Clock</code>实例，用于追踪时间；<code>camera</code>是当前场景中的相机对象。这种写法允许你直接访问这些对象而不需要从外部传入，因为 <code>useFrame</code>已经为你提供了对它们的引用，这是React Three Fiber框架的一部分，旨在简化动画和渲染逻辑的实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useFrame((&#123; clock, camera &#125;) =&gt; &#123; // 这里需要给clock, camera外面加上&#123;&#125;，不然会报错</span><br><span class="line">    // Update the Y position simulate the flight moving in a sin wave </span><br><span class="line">    birdRef.current.position.y = Math.sin(clock.elapsedTime) * 0.2 + 2;</span><br><span class="line"></span><br><span class="line">    // 控制鸟在island的范围内（相机位置的前后10个单位）</span><br><span class="line">    if (birdRef.current.position.x &gt; camera.position.x + 10) &#123;</span><br><span class="line">      birdRef.current.rotation.y = Math.PI;</span><br><span class="line">    &#125; else if (birdRef.current.position.x &lt; camera.position.x - 10) &#123;</span><br><span class="line">      birdRef.current.rotation.y = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**在 **<code>useFrame</code>中，除了 <code>clock</code>和 <code>camera</code>，你还可以接收到一个 <code>state</code>对象作为参数，它包含了React Three Fiber渲染循环中的当前状态和一些实用的属性和方法。这些包括场景（<code>scene</code>）、渲染器（<code>gl</code>）、大小（<code>size</code>）、鼠标位置（<code>mouse</code>）等。<code>useFrame</code>函数提供了一个强大的接口，让你可以在每一帧中访问和修改这些对象，从而创建动画和交互。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  useFrame((_, delta) =&gt; &#123;</span><br><span class="line">    if (isRotating) &#123;</span><br><span class="line">      skyRef.current.rotation.y += 0.15 * delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>**In the **<code>useFrame</code> hook, the first parameter (<code>_</code> in this case) is the state object provided by React Three Fiber, which contains information about the current render state, such as the scene, camera, etc. The underscore <code>_</code> is often used to indicate that the parameter is not being used in the function. The second parameter, <code>delta</code>, represents the time in seconds since the last frame was rendered. This is useful for creating time-dependent animations or simulations, ensuring smooth and consistent motion regardless of the frame rate.</p><h2 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h2><h3 id="Audio的使用"><a href="#Audio的使用" class="headerlink" title="Audio的使用"></a>Audio的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const audioRef = useRef(new Audio(sakura));</span><br></pre></td></tr></table></figure><p>**The **<code>Audio</code> in refers to the HTML Audio element, which is a standard part of the Web APIs provided by browsers for playing sound. It does not need to be imported from a module because it’s globally available in the browser environment, similar to <code>document</code> or <code>window</code>. This API allows you to programmatically control audio playback, such as play, pause, and volume control directly from your React components.</p><p>**To use the **<code>Audio</code> interface in JavaScript, you simply create a new <code>Audio</code> object, optionally passing the URL of the audio file you wish to play as a parameter. You can then use methods like <code>play()</code>, <code>pause()</code>, and properties such as <code>volume</code> to control playback.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const audio = new Audio(&#x27;path/to/your/audio/file.mp3&#x27;);</span><br><span class="line">audio.play(); // To start playing the audio</span><br><span class="line">audio.pause(); // To pause the audio</span><br><span class="line">audio.volume = 0.5; // To set the volume to 50%</span><br></pre></td></tr></table></figure><p>**In a React component, you might use it with **<code>useRef</code> to keep a reference to the audio object.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [isPlayingMusic, setIsPlayingMusic] = useState(false);</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    if (isPlayingMusic) &#123; audioRef.current.play(); &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      audioRef.current.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [isPlayingMusic]);</span><br><span class="line"></span><br><span class="line">// return里面：</span><br><span class="line">&lt;div className=&#x27;absolute bottom-2 left-2&#x27;&gt;</span><br><span class="line">        &lt;img</span><br><span class="line">          src=&#123;!isPlayingMusic ? soundoff : soundon&#125;</span><br><span class="line">          alt=&quot;sound&quot;</span><br><span class="line">          className=&#x27;w-10 h-10 cursor-pointer object-contain&#x27;</span><br><span class="line">          onClick=&#123;() =&gt; setIsPlayingMusic(!isPlayingMusic)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>**This component plays the audio when it mounts and pauses when it unmounts, with the **<code>src</code> prop specifying the audio file’s path.</p><h3 id="currentStage的切换"><a href="#currentStage的切换" class="headerlink" title="currentStage的切换"></a>currentStage的切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;absolute top-28 left-0 right-0 z-10 flex items-center justify-center&quot;&gt;</span><br><span class="line">        &#123;currentStage &amp;&amp; &lt;HomeInfo currentStage=&#123;currentStage&#125; /&gt;&#125; &lt;/div&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>HomeInfo中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HomeInfo = (&#123; currentStage &#125;) =&gt; &#123;</span><br><span class="line">  return renderContent[currentStage] || null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Island中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (true) &#123;</span><br><span class="line">        case normalizeRotation &gt;= 5.45 &amp;&amp; normalizeRotation &lt;= 5.85:</span><br><span class="line">          setCurrentStage(4);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 0.85 &amp;&amp; normalizeRotation &lt;= 1.3:</span><br><span class="line">          setCurrentStage(3);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 2.4 &amp;&amp; normalizeRotation &lt;= 2.6:</span><br><span class="line">          setCurrentStage(2);</span><br><span class="line">          break;</span><br><span class="line">        case normalizeRotation &gt;= 4.25 &amp;&amp; normalizeRotation &lt;= 4.75:</span><br><span class="line">          setCurrentStage(1);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          setCurrentStage(null); // 当不在特定角度下，currentStage为null，所以Home.jsx里要对currentStage进行判断</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>所以需要先判断currentStage，不是null之后再渲染HomeInfo</strong></p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#x27;flex justify-center items-center&#x27;&gt;</span><br><span class="line">        &lt;div className=&quot;w-20 h-20 border-4 border-opacity-20 border-purple-500 border-t-purple-800 rounded-full animate-spin&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>这段代码是一个使用Tailwind CSS实现的简单旋转动画示例。它创建了一个居中的圆形div，该div具有旋转动画。下面是详细解析：</strong></p><ul><li><code>className=&#39;flex justify-center items-center&#39;</code>：这三个类一起使用，创建了一个flex容器，其中的内容水平（<code>justify-center</code>）和垂直（<code>items-center</code>）居中。这确保了内部的div（旋转元素）在父容器中居中。</li><li>**<code>w-20 h-20</code>**：设置div的宽度和高度为5rem（根据Tailwind CSS的默认配置，<code>20</code>单位等于5rem，如果没有自定义配置的话）。</li><li>**<code>border-4</code>**：设置边框宽度为4像素。</li><li>**<code>border-opacity-20</code>**：设置边框透明度为20%，使边框颜色较浅。</li><li>**<code>border-purple-500</code>**：设置边框的默认颜色为紫色，透明度由 <code>border-opacity-20</code>控制。</li><li>**<code>border-t-purple-800</code>**：特别为上边框设置了较深的紫色（<code>purple-800</code>），这在旋转时会产生视觉效果，使得看起来像是在旋转。</li><li>**<code>rounded-full</code>**：使div变为圆形。</li><li>**<code>animate-spin</code>**：应用Tailwind CSS内置的旋转动画，使div无限期旋转。这个动画是通过CSS的 <code>@keyframes</code>实现的，定义了从0%到100%的转动，实现了连续旋转的效果。Tailwind CSS内部定义了这个动画关键帧，实现了元素的360度旋转。动画是循环播放的，因此旋转动画会一直持续，直到被另外的CSS规则覆盖或者从DOM中移除。</li></ul><h3 id="匿名函数的-和"><a href="#匿名函数的-和" class="headerlink" title="匿名函数的()和{}"></a>匿名函数的()和{}</h3><ul><li>**使用 **<code>()=&gt;()</code>时，箭头函数会直接返回圆括号 <code>()</code>中的表达式结果。这适用于返回单个表达式或JSX元素的简短函数。</li><li>**使用 **<code>()=&gt;&#123;&#125;</code>时，你可以在花括号 <code>&#123;&#125;</code>中执行多个语句，但如果想要返回值，需要显式使用 <code>return</code>语句。这适用于更复杂的函数，其中包含了多条语句。</li></ul><h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><h3 id="useAnimations"><a href="#useAnimations" class="headerlink" title="useAnimations"></a>useAnimations</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const group = useRef();</span><br><span class="line">  const &#123; nodes, materials, animations &#125; = useGLTF(scene);</span><br><span class="line">  const &#123; actions &#125; = useAnimations(animations, group);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(actions);// 可以查看模型有哪些动画</span><br><span class="line">    Object.values(actions).forEach((action) =&gt; &#123; action.stop() &#125;);</span><br><span class="line">    if (actions[currentAnimation]) actions[currentAnimation].play();</span><br><span class="line"></span><br><span class="line">  &#125;, [actions, currentAnimation]);</span><br></pre></td></tr></table></figure><p><code>Object.values()</code> 是一个JavaScript方法，它从一个对象中提取出所有可枚举的属性值，并以数组的形式返回这些值。这个方法让你能够更方便地遍历对象的值。</p><p><strong>使用方法:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const object = &#123; a: 1, b: &#x27;text&#x27;, c: true &#125;;</span><br><span class="line">const values = Object.values(object);</span><br><span class="line">console.log(values); // 输出: [1, &#x27;text&#x27;, true]</span><br></pre></td></tr></table></figure><p><strong>案例:</strong><br><strong>假设你有一个对象，存储了不同动画的状态，你想要停止所有正在播放的动画，可以这样做:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const animations = &#123;</span><br><span class="line">  walk: &#123; /* 动画对象 */ &#125;,</span><br><span class="line">  run: &#123; /* 动画对象 */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 停止所有动画</span><br><span class="line">Object.values(animations).forEach(animation =&gt; &#123;</span><br><span class="line">  animation.stop(); // 假设每个动画对象都有一个stop方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>这样，</strong><code>Object.values()</code>帮助你获取了 <code>animations</code>对象中所有动画的集合，然后你可以使用 <code>forEach</code>遍历这个集合，并对每个动画调用 <code>stop</code>方法。</p><h3 id="useAlert"><a href="#useAlert" class="headerlink" title="useAlert"></a>useAlert</h3><p><strong>新建的一个自定义Hook;</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const useAlert = () =&gt; &#123;</span><br><span class="line">  const [alert, setAlert] = React.useState(&#123;</span><br><span class="line">    show: false,</span><br><span class="line">    text: &#x27;&#x27;,</span><br><span class="line">    type: &#x27;danger&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">  const showAlert = (&#123; text, type = &#x27;danger&#x27; &#125;) =&gt;</span><br><span class="line">    setAlert(&#123; show: true, text, type &#125;)</span><br><span class="line">  const hideAlert = () =&gt; setAlert(&#123; show: false, text: &#x27;&#x27;, type: &#x27;danger&#x27; &#125;)</span><br><span class="line">  return &#123; alert, showAlert, hideAlert &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default useAlert</span><br></pre></td></tr></table></figure><p><strong>在useState的基础上，新建了两个函数，这两个函数都是传入参数+setAlert进行组合；最后返回alert，升级的setAlert(也就是这两个函数)</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅲ</title>
    <link href="https://youxt-njnu.github.io/2024/02/25/threejs%E5%AE%9E%E6%88%983/"/>
    <id>https://youxt-njnu.github.io/2024/02/25/threejs%E5%AE%9E%E6%88%983/</id>
    <published>2024-02-25T03:50:05.000Z</published>
    <updated>2024-06-13T02:15:02.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>本文是对Island.jsx及其相关文件的学习解读，内容中含ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><h2 id="Island-jsx"><a href="#Island-jsx" class="headerlink" title="Island.jsx"></a>Island.jsx</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Auto-generated by: https://github.com/pmndrs/gltfjsx</span></span><br><span class="line"><span class="comment">Author: nimzu (https://sketchfab.com/nimzuk)</span></span><br><span class="line"><span class="comment">License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)</span></span><br><span class="line"><span class="comment">Source: https://sketchfab.com/3d-models/foxs-islands-163b68e09fcc47618450150be7785907</span></span><br><span class="line"><span class="comment">Title: Fox&#x27;s islands</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-spring/three&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useGLTF &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/drei&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useFrame, useThree &#125; <span class="keyword">from</span> <span class="string">&quot;@react-three/fiber&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> isLandScene <span class="keyword">from</span> <span class="string">&#x27;../assets/3d/island.glb&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Island</span> = (<span class="params">&#123; isRotating, setIsRotating, setCurrentStage, ...props &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> islandRef = <span class="title function_">useRef</span>(); <span class="comment">// 对应到了Three的Group, 用于控制整个模型(islandRef.current, 即island的gameobject)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; gl, viewport &#125; = <span class="title function_">useThree</span>();<span class="comment">// 获取Three的渲染器，视口</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nodes, materials &#125; = <span class="title function_">useGLTF</span>(isLandScene); <span class="comment">// 获取模型的nodes和materials</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastX = <span class="title function_">useRef</span>(<span class="number">0</span>); <span class="comment">// 用于记录上一次的鼠标位置。这个值在组件的重渲染之间保持不变，而且这些值的变化不会触发组件的重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> rotationSpeed = <span class="title function_">useRef</span>(<span class="number">0</span>);  <span class="comment">// 这个值在组件的重渲染之间保持不变，而且这些值的变化不会触发组件的重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> dampingFactor = <span class="number">0.95</span>; <span class="comment">// 阻尼系数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerDown</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> clientX = e.<span class="property">touches</span> ? e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span> : e.<span class="property">clientX</span>; <span class="comment">//只需要考虑X方向的</span></span><br><span class="line">    lastX.<span class="property">current</span> = clientX;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerUp</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">setIsRotating</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlePointerMove</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRotating) &#123;</span><br><span class="line">      <span class="keyword">const</span> clientX = e.<span class="property">touches</span> ? e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span> : e.<span class="property">clientX</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> delta = (clientX - lastX.<span class="property">current</span>) / viewport.<span class="property">width</span>;</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += delta * <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      lastX.<span class="property">current</span> = clientX;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = delta * <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyDown</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowLeft&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRotating) <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = <span class="number">0.0125</span>;<span class="comment">// 让旋转的效果更舒适些</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowRight&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRotating) <span class="title function_">setIsRotating</span>(<span class="literal">true</span>);</span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> -= <span class="number">0.01</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> = -<span class="number">0.0125</span>;<span class="comment">// 让旋转的效果更舒适些</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyUp</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ArrowLeft&#x27;</span> || e.<span class="property">key</span> === <span class="string">&#x27;ArrowRight&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">setIsRotating</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRotating) &#123;</span><br><span class="line">      rotationSpeed.<span class="property">current</span> *= dampingFactor; <span class="comment">//每帧都会减小旋转速度</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(rotationSpeed.<span class="property">current</span>) &lt; <span class="number">0.001</span>) &#123; <span class="comment">//设定阈值后，停止旋转</span></span><br><span class="line">        rotationSpeed.<span class="property">current</span> = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += rotationSpeed.<span class="property">current</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rotation = islandRef.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mormalize the rotation value to ensure it stays within the range[0, 2 * Math.PI].</span></span><br><span class="line">      <span class="comment">// The goal is to ensure that the rotation value remains within a specific range to prevent potential issues with very large or negative rotation values.</span></span><br><span class="line">      <span class="comment">//   Here&#x27;s a step-by-step explanation of what this code does:</span></span><br><span class="line">      <span class="comment">// 1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided by 2 * Math.PI.This essentially wraps the rotation value around once it reaches a full circle(360 degrees) so that it stays within the range of 0 to 2 * Math.PI.</span></span><br><span class="line">      <span class="comment">// 2.(rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1. This is done to ensure that the value remains positive and within the range of 0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.</span></span><br><span class="line">      <span class="comment">// 3. Finally, ((rotation%(2*Math.PI))+2*Math.PI)%(2*Math.PI) applies another modulo operation to the value obtained in step 2. This step guarantees that the value always stays with the range of 0 to 2*Math.PI, which is equivalent to a full circle in radians.</span></span><br><span class="line">      <span class="keyword">const</span> normalizeRotation = ((rotation % (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)) + <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) % (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//set the current stage based on the island&#x27;s orientation</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">5.45</span> &amp;&amp; normalizeRotation &lt;= <span class="number">5.85</span>: </span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">0.85</span> &amp;&amp; normalizeRotation &lt;= <span class="number">1.3</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">3</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">2.4</span> &amp;&amp; normalizeRotation &lt;= <span class="number">2.6</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> normalizeRotation &gt;= <span class="number">4.25</span> &amp;&amp; normalizeRotation &lt;= <span class="number">4.75</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="title function_">setCurrentStage</span>(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = gl.<span class="property">domElement</span>;</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, handlePointerDown);</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerup&#x27;</span>, handlePointerUp);</span><br><span class="line">    canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointermove&#x27;</span>, handlePointerMove);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, handleKeyDown);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, handleKeyUp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, handlePointerDown);</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointerup&#x27;</span>, handlePointerUp);</span><br><span class="line">      canvas.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;pointermove&#x27;</span>, handlePointerMove);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, handleKeyDown);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, handleKeyUp);</span><br><span class="line">    &#125;  <span class="comment">// 返回的这个函数将在组件卸载或依赖项改变之前执行</span></span><br><span class="line">  &#125;, [gl, handlePointerDown, handlePointerUp, handlePointerMove]); <span class="comment">//只有当这三个变量改变时，里面函数才会执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a.group</span> <span class="attr">ref</span>=<span class="string">&#123;islandRef&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface945_tree1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface946_tree2_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface947_tree1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface948_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface949_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.pCube11_rocks1_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a.group</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Island</span>;</span><br></pre></td></tr></table></figure><h2 id="Home-jsx"><a href="#Home-jsx" class="headerlink" title="Home.jsx"></a>Home.jsx</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Canvas</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-three/fiber&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span>, useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeInfo</span> <span class="keyword">from</span> <span class="string">&#x27;../components/HomeInfo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loader</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Loader&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Island</span> <span class="keyword">from</span> <span class="string">&#x27;../models/Island&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">const</span> [isRotating, setIsRotating] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [currentStage, setCurrentStage] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">adjustIslandForScreenSize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> screenScale = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> screenPosition = [<span class="number">0</span>, -<span class="number">6.5</span>, -<span class="number">43</span>];</span><br><span class="line">    <span class="keyword">let</span> rotation = [<span class="number">0.1</span>, <span class="number">4.7</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt; <span class="number">768</span>) &#123;</span><br><span class="line">      screenScale = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      screenScale = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [screenScale, screenPosition, rotation];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [islandScale, islandPosition, islandRotation] = <span class="title function_">adjustIslandForScreenSize</span>();</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#x27;w-full h-screen relative&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;absolute top-28 left-0 right-0 z-10 flex items-center justify-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;currentStage &amp;&amp; <span class="tag">&lt;<span class="name">HomeInfo</span> <span class="attr">currentStage</span>=<span class="string">&#123;currentStage&#125;</span> /&gt;</span>&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Canvas</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">w-full</span> <span class="attr">h-screen</span> <span class="attr">bg-transparent</span> $&#123;<span class="attr">isRotating</span> ? &#x27;<span class="attr">cursor-grabbing</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">cursor-grab</span>&#x27;&#125; `&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">camera</span>=<span class="string">&#123;&#123;</span> <span class="attr">near:</span> <span class="attr">0.1</span>, <span class="attr">far:</span> <span class="attr">1000</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* Suspense 用于解决加载组件时的白屏，可以显示其他的内容，而其他内容不允许使用 lazy加载 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loader</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">directionalLight</span> <span class="attr">position</span>=<span class="string">&#123;[1,</span> <span class="attr">1</span>, <span class="attr">1</span>]&#125; <span class="attr">intensity</span>=<span class="string">&#123;2&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          ......</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Island</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">position</span>=<span class="string">&#123;islandPosition&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scale</span>=<span class="string">&#123;islandScale&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">rotation</span>=<span class="string">&#123;islandRotation&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">isRotating</span>=<span class="string">&#123;isRotating&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">setIsRotating</span>=<span class="string">&#123;setIsRotating&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">setCurrentStage</span>=<span class="string">&#123;setCurrentStage&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ......</span></span><br><span class="line"><span class="language-xml">    &lt;/section &gt;</span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">export default Home</span></span><br></pre></td></tr></table></figure><h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><h2 id="Three"><a href="#Three" class="headerlink" title="Three"></a>Three</h2><h3 id="a-in-‘-react-spring-x2F-three’"><a href="#a-in-‘-react-spring-x2F-three’" class="headerlink" title="a in ‘@react-spring&#x2F;three’"></a>a in ‘@react-spring&#x2F;three’</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-spring/three&#x27;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a.group</span> <span class="attr">ref</span>=<span class="string">&#123;islandRef&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">mesh</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">geometry</span>=<span class="string">&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">material</span>=<span class="string">&#123;materials.PaletteMaterial001&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ......</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a.group</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个上下文中，<code>a</code>很可能是 <code>@react-spring/three</code>库的命名导入，用于访问 <code>react-spring</code>提供的用于Three.js对象的动画化包装器。<code>react-spring</code>是一个流行的React库，用于创建流畅和自然的动画效果。<code>@react-spring/three</code>是专门为Three.js集成提供的，使得在Three.js环境中使用 <code>react-spring</code>变得简单。</p><p>在这段代码中：</p><ul><li>**<code>a.group</code>**：这是 <code>@react-spring/three</code>提供的一个组件，它是对Three.js中 <code>THREE.Group</code>的动画化包装。在Three.js中，<code>Group</code>对象用于创建对象的集合，这样你可以作为一个单元来平移、旋转和缩放它们。在 <code>react-spring/three</code>中，<code>a.group</code>允许你对这个组应用动画，比如平移、旋转或透明度变化等。</li><li>**<code>&lt;mesh /&gt;</code>**：这是一个Three.js中用于表示具有几何形状和材质的物体的组件。在这个示例中，<code>mesh</code>组件使用了 <code>geometry</code>（几何体）和 <code>material</code>（材质）两个属性，分别指定了物体的形状和表面处理。这不是 <code>react-spring</code>特有的，而是Three.js中的基本概念，但在这里它被放置在 <code>a.group</code>内部，表明你可以对整个组和组内的单个物体进行动画处理。</li></ul><p><code>a</code>是一个特殊的前缀，用于访问 <code>react-spring/three</code>提供的动画化组件。使用 <code>react-spring/three</code>，你可以给Three.js的对象添加流畅的物理基础动画，比如弹簧动画。<code>react-spring</code>的动画不仅限于简单的过渡，它支持从初始状态到结束状态的自然动画，包括反弹、停止等自然运动的效果。</p><p><code>&lt;a.group&gt;</code>组件继承自Three.js的 <code>Group</code>类，将Three.js对象（如 <code>Group</code>、<code>Mesh</code>等）用 <code>a.</code>前缀包装，并通过 <code>@react-spring/three</code>获得了动画能力。在Three.js中，<code>Group</code>是一个用于包含和管理多个其他对象（例如，几何体、网格等）的容器。它本身是 <code>Object3D</code>的一个子类，这意味着它继承了 <code>Object3D</code>的所有属性，包括 <code>position</code>、<code>scale</code>和 <code>rotation</code>。</p><h3 id="useThree-“-react-three-x2F-fiber”"><a href="#useThree-“-react-three-x2F-fiber”" class="headerlink" title="useThree “@react-three&#x2F;fiber”"></a>useThree “@react-three&#x2F;fiber”</h3><p>在 <code>@react-three/fiber</code> 中，<code>useThree</code> 是一个 React Hook，它提供了访问 Three.js 渲染上下文中的各种属性和方法的能力。</p><p>当你在组件中调用 <code>useThree()</code> 时，它返回一个对象，这个对象包含了当前 Three.js 渲染上下文的多个属性和实例。这样，你就可以在你的组件中直接访问和使用这些属性和实例，而无需手动管理它们。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gl, viewport &#125; = <span class="title function_">useThree</span>();</span><br></pre></td></tr></table></figure><p>这行代码的作用是从 <code>useThree()</code> 返回的上下文对象中解构出 <code>gl</code> 和 <code>viewport</code> 两个属性：</p><ul><li>**<code>gl</code>**：这是对 WebGLRenderer 的引用，即 Three.js 使用的 WebGL 渲染器实例。通过这个实例，你可以控制渲染过程，比如调整清除颜色、执行后处理等。</li><li>**<code>viewport</code>**：这包含了关于当前视口的信息，如视口的宽度和高度，以及一些用于将屏幕坐标转换为Three.js世界坐标的工具函数。这对于响应式设计和动态布局非常有用。</li></ul><p>在Three.js中，<code>WebGLRenderer</code>是用来渲染场景（<code>THREE.Scene</code>）到一个Web页面上的canvas元素中。它使用WebGL API来绘制定义好的3D对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br></pre></td></tr></table></figure><p><code>WebGLRenderer</code>生成的canvas元素需要被添加到HTML文档中，这样渲染的结果才能显示给用户。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span><br><span class="line">......</span><br><span class="line">renderer.<span class="title function_">render</span>(scene, camera);</span><br></pre></td></tr></table></figure><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame()"></a>useFrame()</h3><p><code>useFrame</code> 是一个来自 <code>@react-three/fiber</code> 的 React Hook，它允许你在 React 的函数组件中插入和使用渲染循环。在 3D 应用和游戏开发中，渲染循环（也称为动画循环）是核心概念之一，负责在每一帧更新场景、相机、物体状态等，以及执行渲染操作。</p><p><code>useFrame</code> 接受一个回调函数作为参数，这个回调函数会在浏览器的动画帧循环中被不断调用。通常，这个回调函数接受两个参数：一个是渲染器的 <code>state</code>，另一个是渲染的 <code>delta</code> 时间（即从上一帧到当前帧的时间差，单位为秒）。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useFrame</span>(<span class="function">(<span class="params">state, delta</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里编写每帧要执行的操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设你想在一个三维场景中旋转一个立方体，你可以使用 <code>useFrame</code> 来更新立方体的旋转状态：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useFrame &#125; <span class="keyword">from</span> <span class="string">&#x27;@react-three/fiber&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Mesh</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">RotatingBox</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;<span class="title class_">Mesh</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useFrame</span>(<span class="function">(<span class="params">state, delta</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.<span class="property">current</span>) &#123;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">x</span> += delta;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="property">rotation</span>.<span class="property">y</span> += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">mesh</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">boxGeometry</span> <span class="attr">args</span>=<span class="string">&#123;[1,</span> <span class="attr">1</span>, <span class="attr">1</span>]&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">meshStandardMaterial</span> <span class="attr">color</span>=<span class="string">&quot;orange&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">mesh</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，每一帧都会增加立方体的 <code>x</code> 和 <code>y</code> 轴旋转，<code>delta</code> 参数确保了旋转速度与帧率无关，提供了平滑一致的动画效果。</p><p>注意事项</p><ul><li>使用 <code>useFrame</code> 时要考虑性能。因为回调函数会在每一帧被调用，避免在其中执行复杂的计算或状态更新，这可能会导致性能问题。</li><li><code>useFrame</code> 是 <code>@react-three/fiber</code> 特有的，不是 React 官方 API 的一部分。它专门用于在 <code>@react-three/fiber</code> 提供的 <code>&lt;Canvas&gt;</code> 组件中使用，这个组件用于渲染 Three.js 的 3D 场景。</li></ul><h3 id="交互事件pointerdown"><a href="#交互事件pointerdown" class="headerlink" title="交互事件pointerdown"></a>交互事件pointerdown</h3><p>在Three.js中，虽然库本身主要聚焦于3D场景的渲染，但它通常用于Web环境，因此经常与HTML元素（如 <code>canvas</code>）以及Web事件模型进行交互。<code>pointerdown</code>、<code>pointerup</code>和 <code>pointermove</code>是指针事件，是Web标准的一部分，用于处理各种指针设备（如鼠标、触摸屏和笔设备）的输入。这些事件可以被用来增强Three.js场景的交互性。下面是每个事件的基本说明：</p><p>pointerdown</p><ul><li><strong>操作</strong>：当用户按下任何指针设备（例如，鼠标按键、触摸屏的触摸）时触发。</li><li><strong>用途</strong>：在Three.js应用中，<code>pointerdown</code>可以用来检测用户开始与场景中的对象进行交互的时刻，比如开始拖动物体、选中一个物体等。</li></ul><p>pointerup</p><ul><li><strong>操作</strong>：当用户释放之前按下的指针设备时触发。</li><li><strong>用途</strong>：在Three.js应用中，<code>pointerup</code>事件可以用来检测用户结束交互的时刻，例如放开拖动的物体、确认选中的物体等。</li></ul><p>pointermove</p><ul><li><strong>操作</strong>：当指针设备在屏幕上移动时触发，不论是否按下。</li><li><strong>用途</strong>：<code>pointermove</code>在Three.js中非常有用，可以用来实现对象的拖拽效果、在场景中导航（如旋转视角、缩放场景）或实时追踪鼠标&#x2F;触摸的位置以创建动态效果。</li></ul><p>为了在Three.js的 <code>canvas</code>元素上监听这些事件，你可以直接在 <code>canvas</code>元素上添加事件监听器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = renderer.<span class="property">domElement</span>; <span class="comment">// 假设你已经有一个Three.js渲染器</span></span><br><span class="line"></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pointerdown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Pointer down&#x27;</span>, event);</span><br><span class="line">    <span class="comment">// 在这里添加当指针按下时的处理逻辑</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Pointer Type: <span class="subst">$&#123;event.pointerType&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Pointer Position: (<span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>)`</span>);</span><br><span class="line">    <span class="comment">// 阻止默认行为和事件冒泡</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>event</code>对象的作用</p><ul><li><strong>事件类型识别</strong>：<code>event.type</code>属性可以告诉你事件的具体类型（如 <code>&quot;pointerdown&quot;</code>），有助于在使用同一个事件处理函数处理多种事件类型时进行区分。</li><li><strong>获取指针位置</strong>：<code>event.clientX</code>和 <code>event.clientY</code>属性提供了指针在视口中的坐标位置，而 <code>event.pageX</code>和 <code>event.pageY</code>则提供了指针在整个页面中的位置。这对于实现拖拽功能或在画布上绘图等功能非常有用。</li><li><strong>区分指针设备</strong>：<code>event.pointerType</code>属性可以告诉你触发事件的指针设备类型（如 <code>&quot;mouse&quot;</code>、<code>&quot;pen&quot;</code>或 <code>&quot;touch&quot;</code>），这有助于实现针对不同设备的特定交互响应。</li><li><strong>阻止默认行为</strong>：<code>event.preventDefault()</code>方法可以用来阻止事件的默认行为（如果有的话），例如阻止点击链接导航到新页面的默认行为。</li><li><strong>停止事件冒泡</strong>：<code>event.stopPropagation()</code>方法可以阻止事件进一步传播到其他事件监听器。</li></ul><p>注意事项</p><ul><li>使用指针事件可以让你的应用更好地适应不同的输入设备，而不仅仅是鼠标。</li><li>确保合理使用事件监听器，避免在高频事件（如 <code>pointermove</code>）中执行计算量大的操作，这可能会影响性能。</li><li>在处理这些事件时，考虑事件对象（<code>event</code>）提供的信息，如指针位置、按下的按钮等，这些信息对于实现精确的交互逻辑非常有用。</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 是React的一个Hook，它允许你在函数组件中添加状态。在React 16.8之前，函数组件被称为无状态组件，意味着你不能在其中使用状态（state）或生命周期方法。<code>useState</code>的引入改变了这一点，让函数组件也能够拥有和类组件一样的状态管理能力。</p><p><code>useState</code>的基本用法非常简单。它接受一个参数，这个参数是状态的初始值，然后返回一个数组，这个数组包含两个元素：当前的状态值和一个更新这个状态值的函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  // 声明一个新的状态变量，我们将其称之为 &quot;count&quot;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>useState(0)</code>声明了一个新的状态变量 <code>count</code>，并将其初始值设为0。<code>setCount</code>是一个函数，用于更新 <code>count</code>的值。当你点击按钮时，调用 <code>setCount(count + 1)</code>来增加 <code>count</code>的值。</p><p><strong>你可以在一个组件中多次调用</strong> <code>useState</code>，以声明多个状态变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  // 声明多个状态变量</span><br><span class="line">  const [age, setAge] = useState(42);</span><br><span class="line">  const [fruit, setFruit] = useState(&#x27;banana&#x27;);</span><br><span class="line">  const [todos, setTodos] = useState([&#123; text: &#x27;学习 Hook&#x27; &#125;]);</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数式更新：如果新的状态依赖于前一个状态，你可以给更新函数传入一个函数，这个函数将接收前一个状态作为参数，并返回一个新状态。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The count is &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="惰性初始状态"><a href="#惰性初始状态" class="headerlink" title="惰性初始状态"></a>惰性初始状态</h4><p><code>useState</code>允许你传入一个函数来延迟计算初始状态，这对于初始状态计算开销较大的情况非常有用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [state, setState] = useState(() =&gt; &#123;</span><br><span class="line">  const initialState = someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>someExpensiveComputation</code>只会在组件初次渲染时被调用，从而避免了在每次渲染时都重新计算初始状态的开销。</p><p><strong>通过</strong> <code>useState</code>，React为函数组件提供了状态管理的能力，使得开发者能够在不使用类组件的情况下，以一种简洁且易于理解的方式构建动态且响应式的用户界面。</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 是React的一个Hook，它用于在函数组件中存储一个可变的引用对象，这个对象在组件的整个生命周期内保持不变。<code>useRef</code>最常见的用途有两个：一是访问DOM节点，二是存储任何可变值。</p><h4 id="访问DOM节点"><a href="#访问DOM节点" class="headerlink" title="访问DOM节点"></a>访问DOM节点</h4><p><strong>当你需要直接操作DOM元素时，比如设置焦点、测量元素大小或位置等，</strong><code>useRef</code>可以用来获取DOM节点的引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function TextInputWithFocusButton() &#123;</span><br><span class="line">  // 初始化一个ref</span><br><span class="line">  const inputEl = useRef(null);</span><br><span class="line"></span><br><span class="line">  const onButtonClick = () =&gt; &#123;</span><br><span class="line">    // 当按钮被点击时，使用current属性访问DOM节点，并调用focus方法</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;/* 使用ref属性将inputEl ref附加到输入元素上 */&#125;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储任何可变值"><a href="#存储任何可变值" class="headerlink" title="存储任何可变值"></a>存储任何可变值</h4><p><code>useRef</code>也可以用来存储任何可变值，<strong>这个值在组件的重渲染之间保持不变。这对于存储任意值，如计时器ID、外部库的实例等特别有用，而且这些值的变化不会触发组件的重新渲染</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function TimerComponent() &#123;</span><br><span class="line">  const intervalId = useRef(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    intervalId.current = setInterval(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Timer tick&#x27;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      clearInterval(intervalId.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;Check the console for timer ticks.&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中，</strong><code>intervalId</code>用于存储计时器ID，以便可以在组件卸载时清除计时器，防止内存泄露。</p><h4 id="useRef-vs-useState"><a href="#useRef-vs-useState" class="headerlink" title="useRef vs. useState"></a><code>useRef</code> vs. <code>useState</code></h4><p><strong>虽然</strong> <code>useState</code>也可以用于存储数据，但与 <code>useRef</code>相比，当状态更新时，<code>useState</code>会触发组件的重新渲染，而 <code>useRef</code>中的变化不会。因此，如果你需要在组件的多次渲染之间保持不变的数据，且这些数据的变化不应该触发组件的重新渲染，<code>useRef</code>是更合适的选择。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>useRef</code>在React函数组件中提供了一种简单的方式来访问DOM节点和存储可变数据。通过 <code>useRef</code>，你可以在组件的整个生命周期内保持对某个值的引用，而不会引起额外的渲染。这使得 <code>useRef</code>成为在需要直接操作DOM或需要跨渲染周期保持数据不变时的理想选择。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect</code> 是 React 的一个 Hook，它允许你在函数组件中执行副作用操作。副作用可以包括数据获取、订阅或手动修改 DOM 等操作，这些操作通常在组件渲染到屏幕之后执行。<code>useEffect</code> 的用法提供了一个优雅的方式来处理这些操作。<code>useEffect</code> 提供了一种在函数组件中处理生命周期事件的灵活方式，使得开发者能够更容易地管理副作用和资源。</p><p><code>useEffect</code> 接收两个参数：一个是副作用函数，另一个是依赖数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 在这里执行副作用操作</span><br><span class="line">&#125;, [/* 依赖项列表 */]);</span><br></pre></td></tr></table></figure><h4 id="没有依赖的-useEffect"><a href="#没有依赖的-useEffect" class="headerlink" title="没有依赖的 useEffect"></a>没有依赖的 useEffect</h4><p>如果 <code>b</code> 的依赖项列表为空（<code>[]</code>），副作用函数只会在组件挂载（mount）后执行一次。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 只会在组件挂载后执行一次</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h4 id="带有依赖的-useEffect"><a href="#带有依赖的-useEffect" class="headerlink" title="带有依赖的 useEffect"></a>带有依赖的 useEffect</h4><p><strong>当你在依赖项列表中指定变量时，只有当这些变量改变时，副作用函数才会执行。这提供了一种方式来优化性能，避免不必要的副作用操作。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 当 `count` 变化时，这个副作用就会执行</span><br><span class="line">  document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">&#125;, [count]); // 依赖项列表中包含 `count`</span><br></pre></td></tr></table></figure><h4 id="清理副作用"><a href="#清理副作用" class="headerlink" title="清理副作用"></a>清理副作用</h4><p><strong>有时候，你可能需要在组件卸载（unmount）或下一次副作用执行之前执行一些清理操作，比如取消订阅或清除定时器等。为此，你的副作用函数可以返回一个清理函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    // 执行一些重复的操作</span><br><span class="line">  &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  // 返回的这个函数将在组件卸载或依赖项改变之前执行</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [/* 依赖项 */]);</span><br></pre></td></tr></table></figure><h4 id="没有依赖项的-useEffect"><a href="#没有依赖项的-useEffect" class="headerlink" title="没有依赖项的 useEffect"></a>没有依赖项的 useEffect</h4><p>**如果 **<code>useEffect</code> 被调用时没有提供依赖项列表，副作用函数将在组件每次渲染后执行。这通常不推荐，因为它可能会导致性能问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 每次组件渲染后都会执行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="…props"><a href="#…props" class="headerlink" title="…props"></a>…props</h3><p><strong>在JSX中，</strong><code>...props</code>是一个使用了JavaScript的展开运算符（Spread Operator）的表达式，它用于将一个对象的所有可枚举属性，复制到当前对象中。在React组件中，这种语法经常用来传递 <code>props</code>（属性）。</p><p><strong>当你在JSX标签中使用</strong> <code>...props</code>时，你实际上是将一个包含多个属性的对象“展开”，并将这些属性作为单独的props传递给组件。这样做的好处是可以保持组件接口的灵活性，同时减少了代码的冗余。</p><p><strong>假设你有一个组件</strong> <code>&lt;MyComponent /&gt;</code>，你想传递给它多个props，如 <code>title</code>和 <code>onClick</code>等，而这些props是通过一个对象 <code>props</code>管理的，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const props = &#123;</span><br><span class="line">  title: &#x27;Hello World&#x27;,</span><br><span class="line">  onClick: () =&gt; console.log(&#x27;Clicked&#x27;),</span><br><span class="line">  // 更多props...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在不使用展开运算符的情况下，你需要逐一传递每个属性：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent title=&#123;props.title&#125; onClick=&#123;props.onClick&#125; /&gt;</span><br></pre></td></tr></table></figure><p><strong>使用展开运算符，上面的代码可以简化为：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent &#123;...props&#125; /&gt;</span><br></pre></td></tr></table></figure><p><strong>这行代码的作用是将</strong> <code>props</code>对象中的每个属性都作为单独的prop传递给 <code>MyComponent</code>组件。这不仅使代码更简洁，还使得 <code>MyComponent</code>组件能够接收任何通过 <code>props</code>对象传递的额外属性，而无需每次都显式声明它们。</p><p><strong>虽然使用展开运算符可以提高代码的灵活性和可读性，但在某些情况下也需要谨慎使用，因为：</strong></p><ul><li><strong>性能影响</strong>：如果对象很大，或这种操作在一个大型应用中频繁执行，它可能会对性能产生影响。</li><li><strong>属性覆盖</strong>：如果存在多个相同的属性名，后面的属性会覆盖前面的属性。在使用展开运算符时，需要注意属性的顺序和重复性。</li><li><strong>类型检查</strong>：在TypeScript等静态类型检查的环境中，使用展开运算符传递props时，可能需要确保传递的对象属性与组件的props类型兼容。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用为：</span><br><span class="line">&lt;Island</span><br><span class="line">position=&#123;islandPosition&#125;</span><br><span class="line">scale=&#123;islandScale&#125;</span><br><span class="line">rotation=&#123;islandRotation&#125;</span><br><span class="line">isRotating=&#123;isRotating&#125;</span><br><span class="line">setIsRotating=&#123;setIsRotating&#125;</span><br><span class="line">setCurrentStage=&#123;setCurrentStage&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">内容为：</span><br><span class="line">const Island = (&#123; isRotating, setIsRotating, setCurrentStage, ...props &#125;) =&gt; &#123; </span><br><span class="line">    ......</span><br><span class="line">    return (</span><br><span class="line">        &lt;a.group ref=&#123;islandRef&#125; &#123;...props&#125;&gt;</span><br><span class="line">            &lt;mesh</span><br><span class="line">                geometry=&#123;nodes.polySurface944_tree_body_0.geometry&#125;</span><br><span class="line">                material=&#123;materials.PaletteMaterial001&#125; </span><br><span class="line">                /&gt;</span><br><span class="line">            ......</span><br><span class="line">    )&#125; </span><br></pre></td></tr></table></figure><p><strong>在这个示例中，</strong><code>&lt;Island /&gt;</code>组件接收了多个属性（<code>props</code>），包括 <code>isRotating</code>、<code>setIsRotating</code>、<code>setCurrentStage</code>以及其他可能的属性（如 <code>position</code>、<code>scale</code>、<code>rotation</code>等, 这些属性对于Three.js中的对象来说是常见的变换属性）。在 <code>Island</code>组件的函数签名中，<code>...props</code>使用了JavaScript的展开运算符来收集除 <code>isRotating</code>、<code>setIsRotating</code>、<code>setCurrentStage</code>之外的所有传递给组件的属性。</p><p><strong>在</strong> <code>Island</code>组件内部，<code>...props</code>的作用是将这些额外的属性传递给 <code>&lt;a.group&gt;</code>组件。这样做有几个好处：</p><ol><li><strong>灵活性</strong>：允许 <code>Island</code>组件接收任何额外的属性，并将它们直接传递给内部的 <code>&lt;a.group&gt;</code>组件，而无需组件显式地声明或处理这些属性。这使得 <code>Island</code>组件更加灵活，可以适应不同的使用场景。</li><li><strong>简洁性</strong>：避免了需要显式地为每个可能的属性编写传递逻辑，从而使组件代码更加简洁和易于维护。</li><li><strong>组件封装</strong>：保持了 <code>Island</code>组件对于其内部实现的封装性。调用者无需关心 <code>Island</code>如何处理或转发这些属性，只需要知道它可以接收并适当地使用这些属性。</li></ol><p><code>&lt;a.group&gt;</code>组件继承自Three.js的 <code>Group</code>类，将Three.js对象（如 <code>Group</code>、<code>Mesh</code>等）用 <code>a.</code>前缀包装，并通过 <code>@react-spring/three</code>获得了动画能力。在Three.js中，<code>Group</code>是一个用于包含和管理多个其他对象（例如，几何体、网格等）的容器。它本身是 <code>Object3D</code>的一个子类，这意味着它继承了 <code>Object3D</code>的所有属性，包括 <code>position</code>、<code>scale</code>和 <code>rotation</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>three+react|个人主页实战Ⅱ</title>
    <link href="https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%982/"/>
    <id>https://youxt-njnu.github.io/2024/02/25/three%E5%AE%9E%E6%88%982/</id>
    <published>2024-02-25T03:28:05.000Z</published>
    <updated>2024-06-13T02:14:37.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><a href="https://github.com/youxt-njnu/3d_portfolio_primary">模仿项目地址</a>，<a href="https://www.youtube.com/watch?v=FkowOdMjvYo">参考的视频教程出处</a>，<a href="https://juejin.cn/post/6960262593265025031">react入门</a></p><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">react three fiber</a></p><p>ChatGPT辅助生成❗自辨❗❗❗</p><h1 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h1><h2 id="React-Three"><a href="#React-Three" class="headerlink" title="React Three"></a>React Three</h2><p><code>@react-three/fiber</code>表明这个包是React Three（一个专注于在React中使用three.js的项目）下的一个模块或子项目。这有助于开发者快速识别包的来源，同时也方便了对项目包的管理。</p><p>作用域包的结构让开发者更容易地发现和维护相关的包。例如，React Three项目可能包含多个相关包（如 <code>@react-three/fiber</code>、<code>@react-three/drei</code>等），这些都被归类在 <code>@react-three</code>这个作用域下。这种组织方式使得维护者和使用者能够轻松地识别和更新这些相互关联的包。</p><h3 id="1-react-three-fiber"><a href="#1-react-three-fiber" class="headerlink" title="1. @react-three/fiber"></a>1. <code>@react-three/fiber</code></h3><ul><li><strong>作用</strong>：这是React Three Fiber项目的核心库，提供了将three.js集成到React的基础架构。它是一个React渲染器，允许你以声明式的方式在React应用中创建和控制3D场景。</li><li><strong>区别</strong>：作为基础库，它不提供额外的three.js对象或抽象，而是专注于提供与React兼容的three.js渲染环境。</li></ul><h3 id="2-react-three-drei"><a href="#2-react-three-drei" class="headerlink" title="2. @react-three/drei"></a>2. <code>@react-three/drei</code></h3><ul><li><strong>作用</strong>：<code>drei</code>是一个工具包，提供了许多有用的辅助组件和钩子（hooks），以简化在React Three Fiber中开发3D场景的过程。这些组件包括环境灯光、效果、加载器、抽象的3D对象等。</li><li><strong>区别</strong>：与 <code>@react-three/fiber</code>相比，<code>drei</code>更多地提供了构建3D场景时的”快捷方式”，帮助开发者减少样板代码和加快开发流程。</li></ul><h3 id="3-react-three-cannon"><a href="#3-react-three-cannon" class="headerlink" title="3. @react-three/cannon"></a>3. <code>@react-three/cannon</code></h3><ul><li><strong>作用</strong>：这个包提供了物理引擎的集成，基于 <code>cannon.js</code>物理引擎。它允许开发者在React Three Fiber创建的3D场景中添加物理效果，如碰撞检测、重力和弹性。</li><li><strong>区别</strong>：专注于为3D对象添加物理特性，而不是3D渲染或组件的直接创建。</li></ul><h3 id="4-react-three-postprocessing"><a href="#4-react-three-postprocessing" class="headerlink" title="4. @react-three/postprocessing"></a>4. <code>@react-three/postprocessing</code></h3><ul><li><strong>作用</strong>：该包提供了对后处理效果的支持，允许开发者在React Three Fiber场景中添加和配置后处理效果，如模糊、光晕、色彩校正等。</li><li><strong>区别</strong>：专注于渲染流程中的后期处理效果，改善或增加场景的视觉效果。</li></ul><h3 id="5-react-three-gui"><a href="#5-react-three-gui" class="headerlink" title="5. @react-three/gui"></a>5. <code>@react-three/gui</code></h3><ul><li><strong>作用</strong>：提供了一个简易的图形用户界面（GUI），用于在开发过程中调试和修改three.js场景的参数。</li><li><strong>区别</strong>：主要用于开发和调试阶段，通过图形界面快速调整场景参数，而不直接影响3D内容的渲染或逻辑。</li></ul><h3 id="6-react-three-xr"><a href="#6-react-three-xr" class="headerlink" title="6. @react-three/xr"></a>6. <code>@react-three/xr</code></h3><ul><li><strong>作用</strong>：支持构建虚拟现实（VR）和增强现实（AR）体验。它提供了创建和管理XR会话的工具，允许开发者在兼容的设备上提供沉浸式的3D体验。</li><li><strong>区别</strong>：专门针对XR应用的开发，提供了与VR和AR技术集成的工具和组件</li></ul><h1 id="React-Three-Fiber"><a href="#React-Three-Fiber" class="headerlink" title="React Three Fiber"></a>React Three Fiber</h1><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/your-first-scene#adding-lights">官网教程</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a><a href="https://docs.pmnd.rs/react-three-fiber/api/canvas">Canvas</a></h2><p><strong>Scene+Camera+raycaster+(shadow)</strong></p><p>**Canvas里面的内容，可以用驼峰法写，不需要导入，直接是原生的JSX组件。如 **<code>&lt;mesh&gt;&lt;/mesh&gt;</code>, <code>&lt;boxGeometry /&gt;</code>, <code>&lt;meshStandardMaterial /&gt;</code>。但从v8以后，不会自动化导入这些，可以导入react-three-fiber，然后可以直接写这些；或者是通过import ‘three’</p><p><strong>ThreeJS里的类的构造器的参数传入，</strong><code>&lt;boxGeometry args=&#123;[w,h,d]&#125;/&gt;</code></p><h2 id="与threejs的转换"><a href="#与threejs的转换" class="headerlink" title="与threejs的转换"></a>与threejs的转换</h2><p><a href="https://docs.pmnd.rs/react-three-fiber/api/objects">对象，属性和构造器参数设置</a>（说明了从ThreeJS过渡到react-three-fiber的一些注意点）</p><p><strong>有set方法的对象</strong></p><blockquote><p><strong>可以直接用&#x3D;，如果有多个参数，可以放入array</strong></p><p><code>color=&quot;hotpink&quot;</code> not <code>color=&#123;new THREE.Color(&#39;hotpink&#39;)&#125;</code></p><p><code>position=&#123;[100,0,0]&#125;</code> not set</p></blockquote><p><strong>有setScalar这种类似的方法，可以直接用属性scale</strong></p><blockquote><p><code>&lt;mesh scale=&#123;1&#125; /&gt;</code> or <code>&lt;mesh scale=&#123;[1,1,1]&#125; /&gt;</code></p></blockquote><p><strong>有类似mesh.rotation.x这种串接的方法，使用-来连接</strong></p><blockquote><p><code>&lt;mesh rotation-x =&#123;1&#125; /&gt;</code></p></blockquote><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>**在 **<code>react-three-fiber</code>（R3F）中，<code>attach</code>属性是一个非常重要的概念，用于将React组件的某些属性或对象“附加”到Three.js的父对象上。这样做的目的是为了在R3F的React元素树中保持Three.js场景图的结构和属性同步。</p><p><code>attach</code>属性通常用于 <code>&lt;primitive&gt;</code>组件或任何自定义组件内部，来指定如何将当前组件的Three.js对象（如材质、几何体、相机等）附加到其父Three.js对象上。例如，你可以将一个材质附加到一个网格上，或者将一个相机附加到场景中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mesh&gt;</span><br><span class="line">  &lt;boxGeometry attach=&quot;geometry&quot; args=&#123;[1, 1, 1]&#125; /&gt;</span><br><span class="line">  &lt;meshStandardMaterial attach=&quot;material&quot; color=&quot;orange&quot; /&gt;</span><br><span class="line">&lt;/mesh&gt;</span><br></pre></td></tr></table></figure><p><strong>在这个例子中：</strong></p><ul><li><code>&lt;boxGeometry&gt;</code>的 <code>geometry</code>对象被附加到父 <code>&lt;mesh&gt;</code>的 <code>geometry</code>属性上。</li><li><code>&lt;meshStandardMaterial&gt;</code>的 <code>material</code>对象被附加到相同 <code>&lt;mesh&gt;</code>的 <code>material</code>属性上。</li></ul><p><strong>在传统的Three.js应用中，你需要手动管理场景图的所有方面，包括创建对象、设置属性、添加到场景中等。而在R3F中，</strong><code>attach</code>属性简化了这一过程，允许你直接在JSX中以声明式的方式组织和连接Three.js的对象。</p><p><strong>例如，传统Three.js中创建和添加一个带材质的立方体可能需要这样：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const geometry = new THREE.BoxGeometry(1, 1, 1);</span><br><span class="line">const material = new THREE.MeshStandardMaterial(&#123;color: &#x27;orange&#x27;&#125;);</span><br><span class="line">const mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><p>**而在R3F中，相同的操作可以通过使用 **<code>attach</code>属性在JSX中直接声明，如前面的例子所示，这使得代码更加简洁并且保持了React的声明式风格。</p><p><strong>总之，</strong><code>attach</code>属性是 <code>react-three-fiber</code>中连接React组件属性和Three.js对象的强大工具，它简化了在React中构建和管理复杂3D场景的过程。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><strong>只能使用在Canvas元素里，因为Hooks依赖于context.</strong></p><h3 id="useThree"><a href="#useThree" class="headerlink" title="useThree"></a>useThree</h3><p><strong>const state &#x3D; useThree()</strong></p><p><strong>state.gl, .scene, .camera, .raycaster, .pointer(.mouse), .clock, .linear, .legacy, .frameloop, .performace, .size, .viewport, .set(), .get(), .invalidate(), .setSize(), .setDpr(), .setFrameloop(), .setEvents(), .onPointerMissed(), .events</strong></p><h3 id="useFrame"><a href="#useFrame" class="headerlink" title="useFrame"></a>useFrame</h3><p><strong>useFrame((state, clock_delta, xrFrame) &#x3D;&gt;{})</strong></p><h3 id="useLoader"><a href="#useLoader" class="headerlink" title="useLoader"></a>useLoader</h3><h3 id="useGraph"><a href="#useGraph" class="headerlink" title="useGraph"></a>useGraph</h3><p><a href="https://docs.pmnd.rs/react-three-fiber/getting-started/examples">官方案例</a></p><h2 id="react-spring"><a href="#react-spring" class="headerlink" title="@react-spring"></a>@react-spring</h2><p><code>@react-spring</code>是一个基于Spring物理原理的现代React动画库，它允许开发者以声明式的方式在React应用中创建流畅、自然的动画效果。<code>@react-spring</code>的设计旨在简化动画的创建和管理，提供了一种简单而强大的方法来实现复杂的动画效果，无论是简单的值变化、列表的动态排序，还是复杂的交互动画。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>简洁的API</strong>：通过简单的API，开发者可以轻松创建和控制动画。</li><li><strong>物理原理驱动</strong>：动画效果基于真实的物理原理，使得动画看起来更自然。</li><li><strong>高性能</strong>：优化的性能确保即使在复杂动画中也能保持流畅。</li><li><strong>适用范围广</strong>：支持Web（React）、React Native和其他平台，通过相同的API在不同平台上创建动画。</li></ul><h3 id="主要子项目"><a href="#主要子项目" class="headerlink" title="主要子项目"></a>主要子项目</h3><p><code>@react-spring</code>项目包含了几个子项目，分别针对不同的平台或提供特定的功能：</p><ol><li>**<code>@react-spring/web</code>**：专为Web平台设计，用于在Web应用中创建动画。它提供了与DOM元素交互的能力，是构建Web界面动画的理想选择。</li><li>**<code>@react-spring/native</code>**：专为React Native设计，允许在React Native应用中创建流畅的原生动画效果。它利用React Native的动画库来实现高性能的动画。</li><li>**<code>@react-spring/core</code>**：是 <code>@react-spring</code>库的核心，提供了动画功能的基本实现。其他子项目如 <code>@react-spring/web</code>和 <code>@react-spring/native</code>都是在这个核心基础上扩展而来，以支持特定平台的动画效果。</li><li>**<code>@react-spring/three</code>**：为three.js提供动画支持，允许在使用React Three Fiber开发的3D场景中创建和管理动画。这使得开发者可以在3D应用中实现复杂的动画效果。</li><li>**<code>@react-spring/konva</code>**：用于在React Konva（一个用于在React中绘制2D canvas图形的库）项目中创建动画。这使得开发者可以为2D图形和图像添加动画效果。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><strong>平台支持</strong>：主要区别在于各个子项目针对的平台或库不同。<code>@react-spring/web</code>专注于Web平台，<code>@react-spring/native</code>专注于React Native，而 <code>@react-spring/three</code>和 <code>@react-spring/konva</code>则分别针对three.js和Konva。</li><li><strong>使用场景</strong>：虽然这些子项目在API设计上保持一致性，但它们提供的动画能力和使用场景各有侧重，例如 <code>@react-spring/three</code>专门处理3D动画，而 <code>@react-spring/konva</code>处理2D canvas动画。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@react-spring</code>提供了一个跨平台的动画解决方案，通过不同的子项目满足了在Web、React Native、3D场景和2D canvas图形中创建动画的需求。</p><h2 id="React-router-dom"><a href="#React-router-dom" class="headerlink" title="React router dom"></a>React router dom</h2><p>**在React应用中使用 **<code>react-router-dom</code>库时，<code>Route</code>、<code>BrowserRouter</code>（在这里使用别名 <code>Router</code>），和 <code>Routes</code>组件是构建单页面应用（SPA）路由系统的核心。下面是每个组件的作用以及为什么它们通常会一起被导入和使用：</p><p><strong>BrowserRouter (别名 Router)</strong></p><ul><li><strong>作用</strong>：<code>BrowserRouter</code>是一个使用HTML5历史API（<code>pushState</code>、<code>replaceState</code>和 <code>popstate</code>事件）来保持UI与URL同步的路由器。它为React应用提供了一个路由的上下文环境。使用 <code>BrowserRouter</code>时，你的网址看起来很“干净”，不会有 <code>#</code>符号。</li></ul><p><strong>Routes</strong></p><ul><li><strong>作用</strong>：<code>Routes</code>组件在 <code>react-router-dom</code> v6中引入，用于替代v5中的 <code>Switch</code>组件。它负责根据当前的URL决定哪一个子 <code>Route</code>组件应该被渲染。<code>Routes</code>组件会选择与当前URL匹配的最佳 <code>Route</code>来渲染，并提供了嵌套路由的支持。</li></ul><p><strong>Route</strong></p><ul><li><strong>作用</strong>：<code>Route</code>组件用于在路由系统中定义单个路由规则。它接受一个 <code>path</code>属性，用于指定路由的匹配路径，以及一个 <code>element</code>属性，用于指定当该路由匹配时应该渲染的组件。</li></ul><p><strong>这三个组件通常一起使用来构建React应用的路由系统。</strong><code>BrowserRouter</code>提供了一个高阶的路由容器，<code>Routes</code>用于管理路由的选择逻辑，而 <code>Route</code>用于定义具体的路由规则和对应渲染的组件。没有 <code>BrowserRouter</code>，路由系统将无法工作，因为它提供了路由的上下文；没有 <code>Routes</code>和 <code>Route</code>，你就无法定义和管理你的路由规则。这种模式允许React开发者以一种声明式的方式来组织和管理用户在应用中的导航路径，同时确保应用的UI与URL保持同步，从而提高用户体验和应用的可维护性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Routes&gt;</span><br><span class="line">    &#123;/* 路由配置 */&#125;</span><br><span class="line">    &lt;Route path=&quot;/&quot; element=&#123;&lt;HomePage /&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; element=&#123;&lt;AboutPage /&gt;&#125; /&gt;</span><br><span class="line">  &lt;/Routes&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/youxt-njnu/3d_portfolio_primary&quot;&gt;模仿项目地址&lt;/a</summary>
      
    
    
    
    <category term="3DGIS" scheme="https://youxt-njnu.github.io/categories/3DGIS/"/>
    
    <category term="WebGL" scheme="https://youxt-njnu.github.io/categories/3DGIS/WebGL/"/>
    
    
    <category term="threejs" scheme="https://youxt-njnu.github.io/tags/threejs/"/>
    
    <category term="react" scheme="https://youxt-njnu.github.io/tags/react/"/>
    
  </entry>
  
</feed>
